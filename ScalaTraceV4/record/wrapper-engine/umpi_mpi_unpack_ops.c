/* !!!!! This file is automatically generated by a wrapper-engine !!!!! */


#include "umpi_internal.h"

int umpi_unpack_op_MPI_Abort(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.comm), sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

bcopy (&buf[index], &(op->data.mpi.errorcode), sizeof(op->data.mpi.errorcode));
index += sizeof(op->data.mpi.errorcode);

return index;
} /* umpi_unpack_op_MPI_Abort */


int umpi_unpack_op_MPI_Address(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.location), sizeof(op->data.mpi.location));
index += sizeof(op->data.mpi.location);

bcopy (&buf[index], &(op->data.mpi.address), sizeof(op->data.mpi.address));
index += sizeof(op->data.mpi.address);

return index;
} /* umpi_unpack_op_MPI_Address */


int umpi_unpack_op_MPI_Allgather(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.buf), sizeof(op->data.mpi.buf));
index += sizeof(op->data.mpi.buf);

bcopy (&buf[index], &(op->data.mpi.count), sizeof(op->data.mpi.count));
index += sizeof(op->data.mpi.count);

bcopy (&buf[index], &(op->data.mpi.datatype), sizeof(op->data.mpi.datatype));
index += sizeof(op->data.mpi.datatype);

bcopy (&buf[index], &(op->data.mpi.recvbuf), sizeof(op->data.mpi.recvbuf));
index += sizeof(op->data.mpi.recvbuf);

bcopy (&buf[index], &(op->data.mpi.recvcount), sizeof(op->data.mpi.recvcount));
index += sizeof(op->data.mpi.recvcount);

bcopy (&buf[index], &(op->data.mpi.recvtype), sizeof(op->data.mpi.recvtype));
index += sizeof(op->data.mpi.recvtype);

bcopy (&buf[index], &(op->data.mpi.comm), sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

return index;
} /* umpi_unpack_op_MPI_Allgather */


int umpi_unpack_op_MPI_Allgatherv(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.buf), sizeof(op->data.mpi.buf));
index += sizeof(op->data.mpi.buf);

bcopy (&buf[index], &(op->data.mpi.count), sizeof(op->data.mpi.count));
index += sizeof(op->data.mpi.count);

bcopy (&buf[index], &(op->data.mpi.datatype), sizeof(op->data.mpi.datatype));
index += sizeof(op->data.mpi.datatype);

bcopy (&buf[index], &(op->data.mpi.recvbuf), sizeof(op->data.mpi.recvbuf));
index += sizeof(op->data.mpi.recvbuf);

bcopy (&buf[index], &(temp), sizeof(int));
index += sizeof(int);

if (temp) {
op->data.mpi.recvcounts =
(int *) malloc (sizeof(op->data.mpi.recvcounts[0])*temp);
assert (op->data.mpi.recvcounts);
bcopy (&buf[index], op->data.mpi.recvcounts, sizeof(op->data.mpi.recvcounts[0])*temp);
index += (sizeof(op->data.mpi.recvcounts[0])*temp);
} else {
op->data.mpi.recvcounts = NULL;
}

bcopy (&buf[index], &(temp), sizeof(int));
index += sizeof(int);

if (temp) {
op->data.mpi.displs =
(int *) malloc (sizeof(op->data.mpi.displs[0])*temp);
assert (op->data.mpi.displs);
bcopy (&buf[index], op->data.mpi.displs, sizeof(op->data.mpi.displs[0])*temp);
index += (sizeof(op->data.mpi.displs[0])*temp);
} else {
op->data.mpi.displs = NULL;
}

bcopy (&buf[index], &(op->data.mpi.recvtype), sizeof(op->data.mpi.recvtype));
index += sizeof(op->data.mpi.recvtype);

bcopy (&buf[index], &(op->data.mpi.comm), sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

bcopy (&buf[index], &(op->data.mpi.size), sizeof(op->data.mpi.size));
index += sizeof(op->data.mpi.size);

return index;
} /* umpi_unpack_op_MPI_Allgatherv */


int umpi_unpack_op_MPI_Allreduce(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.buf), sizeof(op->data.mpi.buf));
index += sizeof(op->data.mpi.buf);

bcopy (&buf[index], &(op->data.mpi.recvbuf), sizeof(op->data.mpi.recvbuf));
index += sizeof(op->data.mpi.recvbuf);

bcopy (&buf[index], &(op->data.mpi.count), sizeof(op->data.mpi.count));
index += sizeof(op->data.mpi.count);

bcopy (&buf[index], &(op->data.mpi.datatype), sizeof(op->data.mpi.datatype));
index += sizeof(op->data.mpi.datatype);

bcopy (&buf[index], &(op->data.mpi.op), sizeof(op->data.mpi.op));
index += sizeof(op->data.mpi.op);

bcopy (&buf[index], &(op->data.mpi.comm), sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

return index;
} /* umpi_unpack_op_MPI_Allreduce */


int umpi_unpack_op_MPI_Alltoall(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.buf), sizeof(op->data.mpi.buf));
index += sizeof(op->data.mpi.buf);

bcopy (&buf[index], &(op->data.mpi.count), sizeof(op->data.mpi.count));
index += sizeof(op->data.mpi.count);

bcopy (&buf[index], &(op->data.mpi.datatype), sizeof(op->data.mpi.datatype));
index += sizeof(op->data.mpi.datatype);

bcopy (&buf[index], &(op->data.mpi.recvbuf), sizeof(op->data.mpi.recvbuf));
index += sizeof(op->data.mpi.recvbuf);

bcopy (&buf[index], &(op->data.mpi.recvcount), sizeof(op->data.mpi.recvcount));
index += sizeof(op->data.mpi.recvcount);

bcopy (&buf[index], &(op->data.mpi.recvtype), sizeof(op->data.mpi.recvtype));
index += sizeof(op->data.mpi.recvtype);

bcopy (&buf[index], &(op->data.mpi.comm), sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

return index;
} /* umpi_unpack_op_MPI_Alltoall */


int umpi_unpack_op_MPI_Alltoallv(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.buf), sizeof(op->data.mpi.buf));
index += sizeof(op->data.mpi.buf);

bcopy (&buf[index], &(temp), sizeof(int));
index += sizeof(int);

if (temp) {
op->data.mpi.counts =
(int *) malloc (sizeof(op->data.mpi.counts[0])*temp);
assert (op->data.mpi.counts);
bcopy (&buf[index], op->data.mpi.counts, sizeof(op->data.mpi.counts[0])*temp);
index += (sizeof(op->data.mpi.counts[0])*temp);
} else {
op->data.mpi.counts = NULL;
}

bcopy (&buf[index], &(temp), sizeof(int));
index += sizeof(int);

if (temp) {
op->data.mpi.sdispls =
(int *) malloc (sizeof(op->data.mpi.sdispls[0])*temp);
assert (op->data.mpi.sdispls);
bcopy (&buf[index], op->data.mpi.sdispls, sizeof(op->data.mpi.sdispls[0])*temp);
index += (sizeof(op->data.mpi.sdispls[0])*temp);
} else {
op->data.mpi.sdispls = NULL;
}

bcopy (&buf[index], &(op->data.mpi.datatype), sizeof(op->data.mpi.datatype));
index += sizeof(op->data.mpi.datatype);

bcopy (&buf[index], &(op->data.mpi.recvbuf), sizeof(op->data.mpi.recvbuf));
index += sizeof(op->data.mpi.recvbuf);

bcopy (&buf[index], &(temp), sizeof(int));
index += sizeof(int);

if (temp) {
op->data.mpi.recvcounts =
(int *) malloc (sizeof(op->data.mpi.recvcounts[0])*temp);
assert (op->data.mpi.recvcounts);
bcopy (&buf[index], op->data.mpi.recvcounts, sizeof(op->data.mpi.recvcounts[0])*temp);
index += (sizeof(op->data.mpi.recvcounts[0])*temp);
} else {
op->data.mpi.recvcounts = NULL;
}

bcopy (&buf[index], &(temp), sizeof(int));
index += sizeof(int);

if (temp) {
op->data.mpi.rdispls =
(int *) malloc (sizeof(op->data.mpi.rdispls[0])*temp);
assert (op->data.mpi.rdispls);
bcopy (&buf[index], op->data.mpi.rdispls, sizeof(op->data.mpi.rdispls[0])*temp);
index += (sizeof(op->data.mpi.rdispls[0])*temp);
} else {
op->data.mpi.rdispls = NULL;
}

bcopy (&buf[index], &(op->data.mpi.recvtype), sizeof(op->data.mpi.recvtype));
index += sizeof(op->data.mpi.recvtype);

bcopy (&buf[index], &(op->data.mpi.comm), sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

bcopy (&buf[index], &(op->data.mpi.size), sizeof(op->data.mpi.size));
index += sizeof(op->data.mpi.size);

return index;
} /* umpi_unpack_op_MPI_Alltoallv */


int umpi_unpack_op_MPI_Attr_delete(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.comm), sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

bcopy (&buf[index], &(op->data.mpi.keyval), sizeof(op->data.mpi.keyval));
index += sizeof(op->data.mpi.keyval);

return index;
} /* umpi_unpack_op_MPI_Attr_delete */


int umpi_unpack_op_MPI_Attr_get(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.comm), sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

bcopy (&buf[index], &(op->data.mpi.keyval), sizeof(op->data.mpi.keyval));
index += sizeof(op->data.mpi.keyval);

bcopy (&buf[index], &(op->data.mpi.attr_value), sizeof(op->data.mpi.attr_value));
index += sizeof(op->data.mpi.attr_value);

bcopy (&buf[index], &(op->data.mpi.flag), sizeof(op->data.mpi.flag));
index += sizeof(op->data.mpi.flag);

return index;
} /* umpi_unpack_op_MPI_Attr_get */


int umpi_unpack_op_MPI_Attr_put(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.comm), sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

bcopy (&buf[index], &(op->data.mpi.keyval), sizeof(op->data.mpi.keyval));
index += sizeof(op->data.mpi.keyval);

bcopy (&buf[index], &(op->data.mpi.attr_value), sizeof(op->data.mpi.attr_value));
index += sizeof(op->data.mpi.attr_value);

return index;
} /* umpi_unpack_op_MPI_Attr_put */


int umpi_unpack_op_MPI_Barrier(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.comm), sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

return index;
} /* umpi_unpack_op_MPI_Barrier */


int umpi_unpack_op_MPI_Bcast(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.buf), sizeof(op->data.mpi.buf));
index += sizeof(op->data.mpi.buf);

bcopy (&buf[index], &(op->data.mpi.count), sizeof(op->data.mpi.count));
index += sizeof(op->data.mpi.count);

bcopy (&buf[index], &(op->data.mpi.datatype), sizeof(op->data.mpi.datatype));
index += sizeof(op->data.mpi.datatype);

bcopy (&buf[index], &(op->data.mpi.root), sizeof(op->data.mpi.root));
index += sizeof(op->data.mpi.root);

bcopy (&buf[index], &(op->data.mpi.comm), sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

return index;
} /* umpi_unpack_op_MPI_Bcast */


int umpi_unpack_op_MPI_Bsend(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.buf), sizeof(op->data.mpi.buf));
index += sizeof(op->data.mpi.buf);

bcopy (&buf[index], &(op->data.mpi.count), sizeof(op->data.mpi.count));
index += sizeof(op->data.mpi.count);

bcopy (&buf[index], &(op->data.mpi.datatype), sizeof(op->data.mpi.datatype));
index += sizeof(op->data.mpi.datatype);

bcopy (&buf[index], &(op->data.mpi.dest), sizeof(op->data.mpi.dest));
index += sizeof(op->data.mpi.dest);

bcopy (&buf[index], &(op->data.mpi.tag), sizeof(op->data.mpi.tag));
index += sizeof(op->data.mpi.tag);

bcopy (&buf[index], &(op->data.mpi.comm), sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

return index;
} /* umpi_unpack_op_MPI_Bsend */


int umpi_unpack_op_MPI_Bsend_init(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.buf), sizeof(op->data.mpi.buf));
index += sizeof(op->data.mpi.buf);

bcopy (&buf[index], &(op->data.mpi.count), sizeof(op->data.mpi.count));
index += sizeof(op->data.mpi.count);

bcopy (&buf[index], &(op->data.mpi.datatype), sizeof(op->data.mpi.datatype));
index += sizeof(op->data.mpi.datatype);

bcopy (&buf[index], &(op->data.mpi.dest), sizeof(op->data.mpi.dest));
index += sizeof(op->data.mpi.dest);

bcopy (&buf[index], &(op->data.mpi.tag), sizeof(op->data.mpi.tag));
index += sizeof(op->data.mpi.tag);

bcopy (&buf[index], &(op->data.mpi.comm), sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

bcopy (&buf[index], &(op->data.mpi.request), sizeof(op->data.mpi.request));
index += sizeof(op->data.mpi.request);

return index;
} /* umpi_unpack_op_MPI_Bsend_init */


int umpi_unpack_op_MPI_Buffer_attach(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.buf), sizeof(op->data.mpi.buf));
index += sizeof(op->data.mpi.buf);

bcopy (&buf[index], &(op->data.mpi.size), sizeof(op->data.mpi.size));
index += sizeof(op->data.mpi.size);

return index;
} /* umpi_unpack_op_MPI_Buffer_attach */


int umpi_unpack_op_MPI_Buffer_detach(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.bufptr), sizeof(op->data.mpi.bufptr));
index += sizeof(op->data.mpi.bufptr);

bcopy (&buf[index], &(op->data.mpi.size), sizeof(op->data.mpi.size));
index += sizeof(op->data.mpi.size);

return index;
} /* umpi_unpack_op_MPI_Buffer_detach */


int umpi_unpack_op_MPI_Cancel(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.request), sizeof(op->data.mpi.request));
index += sizeof(op->data.mpi.request);

return index;
} /* umpi_unpack_op_MPI_Cancel */


int umpi_unpack_op_MPI_Cart_coords(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.comm), sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

bcopy (&buf[index], &(op->data.mpi.rank), sizeof(op->data.mpi.rank));
index += sizeof(op->data.mpi.rank);

bcopy (&buf[index], &(op->data.mpi.count), sizeof(op->data.mpi.count));
index += sizeof(op->data.mpi.count);

bcopy (&buf[index], &(temp), sizeof(int));
index += sizeof(int);

if (temp) {
op->data.mpi.array_of_coords =
(int *) malloc (sizeof(op->data.mpi.array_of_coords[0])*temp);
assert (op->data.mpi.array_of_coords);
bcopy (&buf[index], op->data.mpi.array_of_coords, sizeof(op->data.mpi.array_of_coords[0])*temp);
index += (sizeof(op->data.mpi.array_of_coords[0])*temp);
} else {
op->data.mpi.array_of_coords = NULL;
}

return index;
} /* umpi_unpack_op_MPI_Cart_coords */


int umpi_unpack_op_MPI_Cart_create(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.comm), sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

bcopy (&buf[index], &(op->data.mpi.count), sizeof(op->data.mpi.count));
index += sizeof(op->data.mpi.count);

bcopy (&buf[index], &(temp), sizeof(int));
index += sizeof(int);

if (temp) {
op->data.mpi.array_of_dims =
(int *) malloc (sizeof(op->data.mpi.array_of_dims[0])*temp);
assert (op->data.mpi.array_of_dims);
bcopy (&buf[index], op->data.mpi.array_of_dims, sizeof(op->data.mpi.array_of_dims[0])*temp);
index += (sizeof(op->data.mpi.array_of_dims[0])*temp);
} else {
op->data.mpi.array_of_dims = NULL;
}

bcopy (&buf[index], &(temp), sizeof(int));
index += sizeof(int);

if (temp) {
op->data.mpi.array_of_periods =
(int *) malloc (sizeof(op->data.mpi.array_of_periods[0])*temp);
assert (op->data.mpi.array_of_periods);
bcopy (&buf[index], op->data.mpi.array_of_periods, sizeof(op->data.mpi.array_of_periods[0])*temp);
index += (sizeof(op->data.mpi.array_of_periods[0])*temp);
} else {
op->data.mpi.array_of_periods = NULL;
}

bcopy (&buf[index], &(op->data.mpi.reorder), sizeof(op->data.mpi.reorder));
index += sizeof(op->data.mpi.reorder);

bcopy (&buf[index], &(op->data.mpi.comm_out), sizeof(op->data.mpi.comm_out));
index += sizeof(op->data.mpi.comm_out);

return index;
} /* umpi_unpack_op_MPI_Cart_create */


int umpi_unpack_op_MPI_Cart_get(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.comm), sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

bcopy (&buf[index], &(op->data.mpi.count), sizeof(op->data.mpi.count));
index += sizeof(op->data.mpi.count);

bcopy (&buf[index], &(temp), sizeof(int));
index += sizeof(int);

if (temp) {
op->data.mpi.array_of_dims =
(int *) malloc (sizeof(op->data.mpi.array_of_dims[0])*temp);
assert (op->data.mpi.array_of_dims);
bcopy (&buf[index], op->data.mpi.array_of_dims, sizeof(op->data.mpi.array_of_dims[0])*temp);
index += (sizeof(op->data.mpi.array_of_dims[0])*temp);
} else {
op->data.mpi.array_of_dims = NULL;
}

bcopy (&buf[index], &(temp), sizeof(int));
index += sizeof(int);

if (temp) {
op->data.mpi.array_of_periods =
(int *) malloc (sizeof(op->data.mpi.array_of_periods[0])*temp);
assert (op->data.mpi.array_of_periods);
bcopy (&buf[index], op->data.mpi.array_of_periods, sizeof(op->data.mpi.array_of_periods[0])*temp);
index += (sizeof(op->data.mpi.array_of_periods[0])*temp);
} else {
op->data.mpi.array_of_periods = NULL;
}

bcopy (&buf[index], &(temp), sizeof(int));
index += sizeof(int);

if (temp) {
op->data.mpi.array_of_coords =
(int *) malloc (sizeof(op->data.mpi.array_of_coords[0])*temp);
assert (op->data.mpi.array_of_coords);
bcopy (&buf[index], op->data.mpi.array_of_coords, sizeof(op->data.mpi.array_of_coords[0])*temp);
index += (sizeof(op->data.mpi.array_of_coords[0])*temp);
} else {
op->data.mpi.array_of_coords = NULL;
}

return index;
} /* umpi_unpack_op_MPI_Cart_get */


int umpi_unpack_op_MPI_Cart_map(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.comm), sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

bcopy (&buf[index], &(op->data.mpi.count), sizeof(op->data.mpi.count));
index += sizeof(op->data.mpi.count);

bcopy (&buf[index], &(temp), sizeof(int));
index += sizeof(int);

if (temp) {
op->data.mpi.array_of_dims =
(int *) malloc (sizeof(op->data.mpi.array_of_dims[0])*temp);
assert (op->data.mpi.array_of_dims);
bcopy (&buf[index], op->data.mpi.array_of_dims, sizeof(op->data.mpi.array_of_dims[0])*temp);
index += (sizeof(op->data.mpi.array_of_dims[0])*temp);
} else {
op->data.mpi.array_of_dims = NULL;
}

bcopy (&buf[index], &(temp), sizeof(int));
index += sizeof(int);

if (temp) {
op->data.mpi.array_of_periods =
(int *) malloc (sizeof(op->data.mpi.array_of_periods[0])*temp);
assert (op->data.mpi.array_of_periods);
bcopy (&buf[index], op->data.mpi.array_of_periods, sizeof(op->data.mpi.array_of_periods[0])*temp);
index += (sizeof(op->data.mpi.array_of_periods[0])*temp);
} else {
op->data.mpi.array_of_periods = NULL;
}

bcopy (&buf[index], &(op->data.mpi.newrank), sizeof(op->data.mpi.newrank));
index += sizeof(op->data.mpi.newrank);

return index;
} /* umpi_unpack_op_MPI_Cart_map */


int umpi_unpack_op_MPI_Cart_rank(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.comm), sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

bcopy (&buf[index], &(temp), sizeof(int));
index += sizeof(int);

if (temp) {
op->data.mpi.retcoords =
(int *) malloc (sizeof(op->data.mpi.retcoords[0])*temp);
assert (op->data.mpi.retcoords);
bcopy (&buf[index], op->data.mpi.retcoords, sizeof(op->data.mpi.retcoords[0])*temp);
index += (sizeof(op->data.mpi.retcoords[0])*temp);
} else {
op->data.mpi.retcoords = NULL;
}

bcopy (&buf[index], &(op->data.mpi.rank), sizeof(op->data.mpi.rank));
index += sizeof(op->data.mpi.rank);

bcopy (&buf[index], &(op->data.mpi.size), sizeof(op->data.mpi.size));
index += sizeof(op->data.mpi.size);

return index;
} /* umpi_unpack_op_MPI_Cart_rank */


int umpi_unpack_op_MPI_Cart_shift(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.comm), sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

bcopy (&buf[index], &(op->data.mpi.direction), sizeof(op->data.mpi.direction));
index += sizeof(op->data.mpi.direction);

bcopy (&buf[index], &(op->data.mpi.displ), sizeof(op->data.mpi.displ));
index += sizeof(op->data.mpi.displ);

bcopy (&buf[index], &(op->data.mpi.cart_src), sizeof(op->data.mpi.cart_src));
index += sizeof(op->data.mpi.cart_src);

bcopy (&buf[index], &(op->data.mpi.cart_dest), sizeof(op->data.mpi.cart_dest));
index += sizeof(op->data.mpi.cart_dest);

return index;
} /* umpi_unpack_op_MPI_Cart_shift */


int umpi_unpack_op_MPI_Cart_sub(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.comm), sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

bcopy (&buf[index], &(temp), sizeof(int));
index += sizeof(int);

if (temp) {
op->data.mpi.dimsp =
(int *) malloc (sizeof(op->data.mpi.dimsp[0])*temp);
assert (op->data.mpi.dimsp);
bcopy (&buf[index], op->data.mpi.dimsp, sizeof(op->data.mpi.dimsp[0])*temp);
index += (sizeof(op->data.mpi.dimsp[0])*temp);
} else {
op->data.mpi.dimsp = NULL;
}

bcopy (&buf[index], &(op->data.mpi.comm_out), sizeof(op->data.mpi.comm_out));
index += sizeof(op->data.mpi.comm_out);

bcopy (&buf[index], &(op->data.mpi.size), sizeof(op->data.mpi.size));
index += sizeof(op->data.mpi.size);

return index;
} /* umpi_unpack_op_MPI_Cart_sub */


int umpi_unpack_op_MPI_Cartdim_get(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.comm), sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

bcopy (&buf[index], &(op->data.mpi.ndims_p), sizeof(op->data.mpi.ndims_p));
index += sizeof(op->data.mpi.ndims_p);

return index;
} /* umpi_unpack_op_MPI_Cartdim_get */


int umpi_unpack_op_MPI_Comm_compare(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.comm1), sizeof(op->data.mpi.comm1));
index += sizeof(op->data.mpi.comm1);

bcopy (&buf[index], &(op->data.mpi.comm2), sizeof(op->data.mpi.comm2));
index += sizeof(op->data.mpi.comm2);

bcopy (&buf[index], &(op->data.mpi.result), sizeof(op->data.mpi.result));
index += sizeof(op->data.mpi.result);

return index;
} /* umpi_unpack_op_MPI_Comm_compare */


int umpi_unpack_op_MPI_Comm_create(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.comm), sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

bcopy (&buf[index], &(op->data.mpi.group), sizeof(op->data.mpi.group));
index += sizeof(op->data.mpi.group);

bcopy (&buf[index], &(op->data.mpi.comm_out), sizeof(op->data.mpi.comm_out));
index += sizeof(op->data.mpi.comm_out);

return index;
} /* umpi_unpack_op_MPI_Comm_create */


int umpi_unpack_op_MPI_Comm_dup(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.comm), sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

bcopy (&buf[index], &(op->data.mpi.comm_out), sizeof(op->data.mpi.comm_out));
index += sizeof(op->data.mpi.comm_out);

return index;
} /* umpi_unpack_op_MPI_Comm_dup */


int umpi_unpack_op_MPI_Comm_free(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.commp), sizeof(op->data.mpi.commp));
index += sizeof(op->data.mpi.commp);

bcopy (&buf[index], &(op->data.mpi.comm), sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

return index;
} /* umpi_unpack_op_MPI_Comm_free */


int umpi_unpack_op_MPI_Comm_get_name(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.comm), sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

bcopy (&buf[index], &(op->data.mpi.namep), sizeof(op->data.mpi.namep));
index += sizeof(op->data.mpi.namep);

bcopy (&buf[index], &(op->data.mpi.reslen), sizeof(op->data.mpi.reslen));
index += sizeof(op->data.mpi.reslen);

return index;
} /* umpi_unpack_op_MPI_Comm_get_name */


int umpi_unpack_op_MPI_Comm_group(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.comm), sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

bcopy (&buf[index], &(op->data.mpi.group_out), sizeof(op->data.mpi.group_out));
index += sizeof(op->data.mpi.group_out);

return index;
} /* umpi_unpack_op_MPI_Comm_group */


int umpi_unpack_op_MPI_Comm_rank(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.comm), sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

bcopy (&buf[index], &(op->data.mpi.rank), sizeof(op->data.mpi.rank));
index += sizeof(op->data.mpi.rank);

return index;
} /* umpi_unpack_op_MPI_Comm_rank */


int umpi_unpack_op_MPI_Comm_remote_group(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.comm), sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

bcopy (&buf[index], &(op->data.mpi.group_out), sizeof(op->data.mpi.group_out));
index += sizeof(op->data.mpi.group_out);

return index;
} /* umpi_unpack_op_MPI_Comm_remote_group */


int umpi_unpack_op_MPI_Comm_remote_size(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.comm), sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

bcopy (&buf[index], &(op->data.mpi.size), sizeof(op->data.mpi.size));
index += sizeof(op->data.mpi.size);

return index;
} /* umpi_unpack_op_MPI_Comm_remote_size */


int umpi_unpack_op_MPI_Comm_set_name(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.comm), sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

bcopy (&buf[index], &(op->data.mpi.name), sizeof(op->data.mpi.name));
index += sizeof(op->data.mpi.name);

return index;
} /* umpi_unpack_op_MPI_Comm_set_name */


int umpi_unpack_op_MPI_Comm_size(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.comm), sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

bcopy (&buf[index], &(op->data.mpi.size), sizeof(op->data.mpi.size));
index += sizeof(op->data.mpi.size);

return index;
} /* umpi_unpack_op_MPI_Comm_size */


int umpi_unpack_op_MPI_Comm_split(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.comm), sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

bcopy (&buf[index], &(op->data.mpi.color), sizeof(op->data.mpi.color));
index += sizeof(op->data.mpi.color);

bcopy (&buf[index], &(op->data.mpi.key), sizeof(op->data.mpi.key));
index += sizeof(op->data.mpi.key);

bcopy (&buf[index], &(op->data.mpi.comm_out), sizeof(op->data.mpi.comm_out));
index += sizeof(op->data.mpi.comm_out);

return index;
} /* umpi_unpack_op_MPI_Comm_split */


int umpi_unpack_op_MPI_Comm_test_inter(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.comm), sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

bcopy (&buf[index], &(op->data.mpi.flag), sizeof(op->data.mpi.flag));
index += sizeof(op->data.mpi.flag);

return index;
} /* umpi_unpack_op_MPI_Comm_test_inter */


int umpi_unpack_op_MPI_Dims_create(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.nnodes), sizeof(op->data.mpi.nnodes));
index += sizeof(op->data.mpi.nnodes);

bcopy (&buf[index], &(op->data.mpi.count), sizeof(op->data.mpi.count));
index += sizeof(op->data.mpi.count);

bcopy (&buf[index], &(temp), sizeof(int));
index += sizeof(int);

if (temp) {
op->data.mpi.array_of_dims =
(int *) malloc (sizeof(op->data.mpi.array_of_dims[0])*temp);
assert (op->data.mpi.array_of_dims);
bcopy (&buf[index], op->data.mpi.array_of_dims, sizeof(op->data.mpi.array_of_dims[0])*temp);
index += (sizeof(op->data.mpi.array_of_dims[0])*temp);
} else {
op->data.mpi.array_of_dims = NULL;
}

return index;
} /* umpi_unpack_op_MPI_Dims_create */


int umpi_unpack_op_MPI_Errhandler_create(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.function), sizeof(op->data.mpi.function));
index += sizeof(op->data.mpi.function);

bcopy (&buf[index], &(op->data.mpi.errhandler), sizeof(op->data.mpi.errhandler));
index += sizeof(op->data.mpi.errhandler);

return index;
} /* umpi_unpack_op_MPI_Errhandler_create */


int umpi_unpack_op_MPI_Errhandler_free(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.errhandler), sizeof(op->data.mpi.errhandler));
index += sizeof(op->data.mpi.errhandler);

return index;
} /* umpi_unpack_op_MPI_Errhandler_free */


int umpi_unpack_op_MPI_Errhandler_get(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.comm), sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

bcopy (&buf[index], &(op->data.mpi.errhandler), sizeof(op->data.mpi.errhandler));
index += sizeof(op->data.mpi.errhandler);

return index;
} /* umpi_unpack_op_MPI_Errhandler_get */


int umpi_unpack_op_MPI_Errhandler_set(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.comm), sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

bcopy (&buf[index], &(op->data.mpi.errhandler_notptr), sizeof(op->data.mpi.errhandler_notptr));
index += sizeof(op->data.mpi.errhandler_notptr);

return index;
} /* umpi_unpack_op_MPI_Errhandler_set */


int umpi_unpack_op_MPI_Error_class(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.errorcode), sizeof(op->data.mpi.errorcode));
index += sizeof(op->data.mpi.errorcode);

bcopy (&buf[index], &(op->data.mpi.errorclass), sizeof(op->data.mpi.errorclass));
index += sizeof(op->data.mpi.errorclass);

return index;
} /* umpi_unpack_op_MPI_Error_class */


int umpi_unpack_op_MPI_Error_string(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.errorcode), sizeof(op->data.mpi.errorcode));
index += sizeof(op->data.mpi.errorcode);

bcopy (&buf[index], &(op->data.mpi.string), sizeof(op->data.mpi.string));
index += sizeof(op->data.mpi.string);

bcopy (&buf[index], &(op->data.mpi.reslen), sizeof(op->data.mpi.reslen));
index += sizeof(op->data.mpi.reslen);

return index;
} /* umpi_unpack_op_MPI_Error_string */


int umpi_unpack_op_MPI_Finalize(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
return index;
} /* umpi_unpack_op_MPI_Finalize */


int umpi_unpack_op_MPI_Finalized(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.flag), sizeof(op->data.mpi.flag));
index += sizeof(op->data.mpi.flag);

return index;
} /* umpi_unpack_op_MPI_Finalized */


int umpi_unpack_op_MPI_Gather(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.buf), sizeof(op->data.mpi.buf));
index += sizeof(op->data.mpi.buf);

bcopy (&buf[index], &(op->data.mpi.count), sizeof(op->data.mpi.count));
index += sizeof(op->data.mpi.count);

bcopy (&buf[index], &(op->data.mpi.datatype), sizeof(op->data.mpi.datatype));
index += sizeof(op->data.mpi.datatype);

bcopy (&buf[index], &(op->data.mpi.recvbuf), sizeof(op->data.mpi.recvbuf));
index += sizeof(op->data.mpi.recvbuf);

bcopy (&buf[index], &(op->data.mpi.recvcount), sizeof(op->data.mpi.recvcount));
index += sizeof(op->data.mpi.recvcount);

bcopy (&buf[index], &(op->data.mpi.recvtype), sizeof(op->data.mpi.recvtype));
index += sizeof(op->data.mpi.recvtype);

bcopy (&buf[index], &(op->data.mpi.root), sizeof(op->data.mpi.root));
index += sizeof(op->data.mpi.root);

bcopy (&buf[index], &(op->data.mpi.comm), sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

return index;
} /* umpi_unpack_op_MPI_Gather */


int umpi_unpack_op_MPI_Gatherv(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.buf), sizeof(op->data.mpi.buf));
index += sizeof(op->data.mpi.buf);

bcopy (&buf[index], &(op->data.mpi.count), sizeof(op->data.mpi.count));
index += sizeof(op->data.mpi.count);

bcopy (&buf[index], &(op->data.mpi.datatype), sizeof(op->data.mpi.datatype));
index += sizeof(op->data.mpi.datatype);

bcopy (&buf[index], &(op->data.mpi.recvbuf), sizeof(op->data.mpi.recvbuf));
index += sizeof(op->data.mpi.recvbuf);

bcopy (&buf[index], &(temp), sizeof(int));
index += sizeof(int);

if (temp) {
op->data.mpi.recvcounts =
(int *) malloc (sizeof(op->data.mpi.recvcounts[0])*temp);
assert (op->data.mpi.recvcounts);
bcopy (&buf[index], op->data.mpi.recvcounts, sizeof(op->data.mpi.recvcounts[0])*temp);
index += (sizeof(op->data.mpi.recvcounts[0])*temp);
} else {
op->data.mpi.recvcounts = NULL;
}

bcopy (&buf[index], &(temp), sizeof(int));
index += sizeof(int);

if (temp) {
op->data.mpi.displs =
(int *) malloc (sizeof(op->data.mpi.displs[0])*temp);
assert (op->data.mpi.displs);
bcopy (&buf[index], op->data.mpi.displs, sizeof(op->data.mpi.displs[0])*temp);
index += (sizeof(op->data.mpi.displs[0])*temp);
} else {
op->data.mpi.displs = NULL;
}

bcopy (&buf[index], &(op->data.mpi.recvtype), sizeof(op->data.mpi.recvtype));
index += sizeof(op->data.mpi.recvtype);

bcopy (&buf[index], &(op->data.mpi.root), sizeof(op->data.mpi.root));
index += sizeof(op->data.mpi.root);

bcopy (&buf[index], &(op->data.mpi.comm), sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

bcopy (&buf[index], &(op->data.mpi.size), sizeof(op->data.mpi.size));
index += sizeof(op->data.mpi.size);

return index;
} /* umpi_unpack_op_MPI_Gatherv */


int umpi_unpack_op_MPI_Get_count(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.status_src), sizeof(op->data.mpi.status_src));
index += sizeof(op->data.mpi.status_src);

bcopy (&buf[index], &(op->data.mpi.datatype), sizeof(op->data.mpi.datatype));
index += sizeof(op->data.mpi.datatype);

bcopy (&buf[index], &(op->data.mpi.countp), sizeof(op->data.mpi.countp));
index += sizeof(op->data.mpi.countp);

bcopy (&buf[index], &(op->data.mpi.status_src), sizeof(op->data.mpi.status_src));
index += sizeof(op->data.mpi.status_src);

bcopy (&buf[index], &(op->data.mpi.statuses_srcs), sizeof(op->data.mpi.statuses_srcs));
index += sizeof(op->data.mpi.statuses_srcs);

return index;
} /* umpi_unpack_op_MPI_Get_count */


int umpi_unpack_op_MPI_Get_elements(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.status_src), sizeof(op->data.mpi.status_src));
index += sizeof(op->data.mpi.status_src);

bcopy (&buf[index], &(op->data.mpi.datatype), sizeof(op->data.mpi.datatype));
index += sizeof(op->data.mpi.datatype);

bcopy (&buf[index], &(op->data.mpi.elements), sizeof(op->data.mpi.elements));
index += sizeof(op->data.mpi.elements);

return index;
} /* umpi_unpack_op_MPI_Get_elements */


int umpi_unpack_op_MPI_Get_processor_name(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.name), sizeof(op->data.mpi.name));
index += sizeof(op->data.mpi.name);

bcopy (&buf[index], &(op->data.mpi.reslen), sizeof(op->data.mpi.reslen));
index += sizeof(op->data.mpi.reslen);

return index;
} /* umpi_unpack_op_MPI_Get_processor_name */


int umpi_unpack_op_MPI_Get_version(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.version), sizeof(op->data.mpi.version));
index += sizeof(op->data.mpi.version);

bcopy (&buf[index], &(op->data.mpi.subversion), sizeof(op->data.mpi.subversion));
index += sizeof(op->data.mpi.subversion);

return index;
} /* umpi_unpack_op_MPI_Get_version */


int umpi_unpack_op_MPI_Graph_create(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.comm), sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

bcopy (&buf[index], &(op->data.mpi.count), sizeof(op->data.mpi.count));
index += sizeof(op->data.mpi.count);

bcopy (&buf[index], &(temp), sizeof(int));
index += sizeof(int);

if (temp) {
op->data.mpi.array_of_degrees =
(int *) malloc (sizeof(op->data.mpi.array_of_degrees[0])*temp);
assert (op->data.mpi.array_of_degrees);
bcopy (&buf[index], op->data.mpi.array_of_degrees, sizeof(op->data.mpi.array_of_degrees[0])*temp);
index += (sizeof(op->data.mpi.array_of_degrees[0])*temp);
} else {
op->data.mpi.array_of_degrees = NULL;
}

bcopy (&buf[index], &(temp), sizeof(int));
index += sizeof(int);

if (temp) {
op->data.mpi.edges =
(int *) malloc (sizeof(op->data.mpi.edges[0])*temp);
assert (op->data.mpi.edges);
bcopy (&buf[index], op->data.mpi.edges, sizeof(op->data.mpi.edges[0])*temp);
index += (sizeof(op->data.mpi.edges[0])*temp);
} else {
op->data.mpi.edges = NULL;
}

bcopy (&buf[index], &(op->data.mpi.reorder), sizeof(op->data.mpi.reorder));
index += sizeof(op->data.mpi.reorder);

bcopy (&buf[index], &(op->data.mpi.comm_out), sizeof(op->data.mpi.comm_out));
index += sizeof(op->data.mpi.comm_out);

return index;
} /* umpi_unpack_op_MPI_Graph_create */


int umpi_unpack_op_MPI_Graph_get(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.comm), sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

bcopy (&buf[index], &(op->data.mpi.count), sizeof(op->data.mpi.count));
index += sizeof(op->data.mpi.count);

bcopy (&buf[index], &(op->data.mpi.edgecount), sizeof(op->data.mpi.edgecount));
index += sizeof(op->data.mpi.edgecount);

bcopy (&buf[index], &(temp), sizeof(int));
index += sizeof(int);

if (temp) {
op->data.mpi.array_of_degrees =
(int *) malloc (sizeof(op->data.mpi.array_of_degrees[0])*temp);
assert (op->data.mpi.array_of_degrees);
bcopy (&buf[index], op->data.mpi.array_of_degrees, sizeof(op->data.mpi.array_of_degrees[0])*temp);
index += (sizeof(op->data.mpi.array_of_degrees[0])*temp);
} else {
op->data.mpi.array_of_degrees = NULL;
}

bcopy (&buf[index], &(temp), sizeof(int));
index += sizeof(int);

if (temp) {
op->data.mpi.retedges =
(int *) malloc (sizeof(op->data.mpi.retedges[0])*temp);
assert (op->data.mpi.retedges);
bcopy (&buf[index], op->data.mpi.retedges, sizeof(op->data.mpi.retedges[0])*temp);
index += (sizeof(op->data.mpi.retedges[0])*temp);
} else {
op->data.mpi.retedges = NULL;
}

return index;
} /* umpi_unpack_op_MPI_Graph_get */


int umpi_unpack_op_MPI_Graph_map(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.comm), sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

bcopy (&buf[index], &(op->data.mpi.count), sizeof(op->data.mpi.count));
index += sizeof(op->data.mpi.count);

bcopy (&buf[index], &(temp), sizeof(int));
index += sizeof(int);

if (temp) {
op->data.mpi.array_of_degrees =
(int *) malloc (sizeof(op->data.mpi.array_of_degrees[0])*temp);
assert (op->data.mpi.array_of_degrees);
bcopy (&buf[index], op->data.mpi.array_of_degrees, sizeof(op->data.mpi.array_of_degrees[0])*temp);
index += (sizeof(op->data.mpi.array_of_degrees[0])*temp);
} else {
op->data.mpi.array_of_degrees = NULL;
}

bcopy (&buf[index], &(temp), sizeof(int));
index += sizeof(int);

if (temp) {
op->data.mpi.edges =
(int *) malloc (sizeof(op->data.mpi.edges[0])*temp);
assert (op->data.mpi.edges);
bcopy (&buf[index], op->data.mpi.edges, sizeof(op->data.mpi.edges[0])*temp);
index += (sizeof(op->data.mpi.edges[0])*temp);
} else {
op->data.mpi.edges = NULL;
}

bcopy (&buf[index], &(op->data.mpi.newrank), sizeof(op->data.mpi.newrank));
index += sizeof(op->data.mpi.newrank);

return index;
} /* umpi_unpack_op_MPI_Graph_map */


int umpi_unpack_op_MPI_Graph_neighbors(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.comm), sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

bcopy (&buf[index], &(op->data.mpi.rank), sizeof(op->data.mpi.rank));
index += sizeof(op->data.mpi.rank);

bcopy (&buf[index], &(op->data.mpi.count), sizeof(op->data.mpi.count));
index += sizeof(op->data.mpi.count);

bcopy (&buf[index], &(temp), sizeof(int));
index += sizeof(int);

if (temp) {
op->data.mpi.array_of_neighbors =
(int *) malloc (sizeof(op->data.mpi.array_of_neighbors[0])*temp);
assert (op->data.mpi.array_of_neighbors);
bcopy (&buf[index], op->data.mpi.array_of_neighbors, sizeof(op->data.mpi.array_of_neighbors[0])*temp);
index += (sizeof(op->data.mpi.array_of_neighbors[0])*temp);
} else {
op->data.mpi.array_of_neighbors = NULL;
}

return index;
} /* umpi_unpack_op_MPI_Graph_neighbors */


int umpi_unpack_op_MPI_Graph_neighbors_count(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.comm), sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

bcopy (&buf[index], &(op->data.mpi.rank), sizeof(op->data.mpi.rank));
index += sizeof(op->data.mpi.rank);

bcopy (&buf[index], &(op->data.mpi.nneighbors), sizeof(op->data.mpi.nneighbors));
index += sizeof(op->data.mpi.nneighbors);

return index;
} /* umpi_unpack_op_MPI_Graph_neighbors_count */


int umpi_unpack_op_MPI_Graphdims_get(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.comm), sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

bcopy (&buf[index], &(op->data.mpi.nnodes), sizeof(op->data.mpi.nnodes));
index += sizeof(op->data.mpi.nnodes);

bcopy (&buf[index], &(op->data.mpi.edgecountp), sizeof(op->data.mpi.edgecountp));
index += sizeof(op->data.mpi.edgecountp);

return index;
} /* umpi_unpack_op_MPI_Graphdims_get */


int umpi_unpack_op_MPI_Group_compare(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.group1), sizeof(op->data.mpi.group1));
index += sizeof(op->data.mpi.group1);

bcopy (&buf[index], &(op->data.mpi.group2), sizeof(op->data.mpi.group2));
index += sizeof(op->data.mpi.group2);

bcopy (&buf[index], &(op->data.mpi.result), sizeof(op->data.mpi.result));
index += sizeof(op->data.mpi.result);

return index;
} /* umpi_unpack_op_MPI_Group_compare */


int umpi_unpack_op_MPI_Group_difference(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.group1), sizeof(op->data.mpi.group1));
index += sizeof(op->data.mpi.group1);

bcopy (&buf[index], &(op->data.mpi.group2), sizeof(op->data.mpi.group2));
index += sizeof(op->data.mpi.group2);

bcopy (&buf[index], &(op->data.mpi.group_out), sizeof(op->data.mpi.group_out));
index += sizeof(op->data.mpi.group_out);

return index;
} /* umpi_unpack_op_MPI_Group_difference */


int umpi_unpack_op_MPI_Group_excl(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.group), sizeof(op->data.mpi.group));
index += sizeof(op->data.mpi.group);

bcopy (&buf[index], &(op->data.mpi.count), sizeof(op->data.mpi.count));
index += sizeof(op->data.mpi.count);

bcopy (&buf[index], &(temp), sizeof(int));
index += sizeof(int);

if (temp) {
op->data.mpi.array_of_ranks =
(int *) malloc (sizeof(op->data.mpi.array_of_ranks[0])*temp);
assert (op->data.mpi.array_of_ranks);
bcopy (&buf[index], op->data.mpi.array_of_ranks, sizeof(op->data.mpi.array_of_ranks[0])*temp);
index += (sizeof(op->data.mpi.array_of_ranks[0])*temp);
} else {
op->data.mpi.array_of_ranks = NULL;
}

bcopy (&buf[index], &(op->data.mpi.group_out), sizeof(op->data.mpi.group_out));
index += sizeof(op->data.mpi.group_out);

return index;
} /* umpi_unpack_op_MPI_Group_excl */


int umpi_unpack_op_MPI_Group_free(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.group_out), sizeof(op->data.mpi.group_out));
index += sizeof(op->data.mpi.group_out);

return index;
} /* umpi_unpack_op_MPI_Group_free */


int umpi_unpack_op_MPI_Group_incl(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.group), sizeof(op->data.mpi.group));
index += sizeof(op->data.mpi.group);

bcopy (&buf[index], &(op->data.mpi.count), sizeof(op->data.mpi.count));
index += sizeof(op->data.mpi.count);

bcopy (&buf[index], &(temp), sizeof(int));
index += sizeof(int);

if (temp) {
op->data.mpi.array_of_ranks =
(int *) malloc (sizeof(op->data.mpi.array_of_ranks[0])*temp);
assert (op->data.mpi.array_of_ranks);
bcopy (&buf[index], op->data.mpi.array_of_ranks, sizeof(op->data.mpi.array_of_ranks[0])*temp);
index += (sizeof(op->data.mpi.array_of_ranks[0])*temp);
} else {
op->data.mpi.array_of_ranks = NULL;
}

bcopy (&buf[index], &(op->data.mpi.group_out), sizeof(op->data.mpi.group_out));
index += sizeof(op->data.mpi.group_out);

return index;
} /* umpi_unpack_op_MPI_Group_incl */


int umpi_unpack_op_MPI_Group_intersection(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.group1), sizeof(op->data.mpi.group1));
index += sizeof(op->data.mpi.group1);

bcopy (&buf[index], &(op->data.mpi.group2), sizeof(op->data.mpi.group2));
index += sizeof(op->data.mpi.group2);

bcopy (&buf[index], &(op->data.mpi.group_out), sizeof(op->data.mpi.group_out));
index += sizeof(op->data.mpi.group_out);

return index;
} /* umpi_unpack_op_MPI_Group_intersection */


int umpi_unpack_op_MPI_Group_range_excl(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.group), sizeof(op->data.mpi.group));
index += sizeof(op->data.mpi.group);

bcopy (&buf[index], &(op->data.mpi.count), sizeof(op->data.mpi.count));
index += sizeof(op->data.mpi.count);

bcopy (&buf[index], &(temp), sizeof(int));
index += sizeof(int);

if (temp) {
op->data.mpi.ranges =
(int *) malloc (sizeof(op->data.mpi.ranges[0])*temp);
assert (op->data.mpi.ranges);
bcopy (&buf[index], op->data.mpi.ranges, sizeof(op->data.mpi.ranges[0])*temp);
index += (sizeof(op->data.mpi.ranges[0])*temp);
} else {
op->data.mpi.ranges = NULL;
}

bcopy (&buf[index], &(op->data.mpi.group_out), sizeof(op->data.mpi.group_out));
index += sizeof(op->data.mpi.group_out);

return index;
} /* umpi_unpack_op_MPI_Group_range_excl */


int umpi_unpack_op_MPI_Group_range_incl(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.group), sizeof(op->data.mpi.group));
index += sizeof(op->data.mpi.group);

bcopy (&buf[index], &(op->data.mpi.count), sizeof(op->data.mpi.count));
index += sizeof(op->data.mpi.count);

bcopy (&buf[index], &(temp), sizeof(int));
index += sizeof(int);

if (temp) {
op->data.mpi.ranges =
(int *) malloc (sizeof(op->data.mpi.ranges[0])*temp);
assert (op->data.mpi.ranges);
bcopy (&buf[index], op->data.mpi.ranges, sizeof(op->data.mpi.ranges[0])*temp);
index += (sizeof(op->data.mpi.ranges[0])*temp);
} else {
op->data.mpi.ranges = NULL;
}

bcopy (&buf[index], &(op->data.mpi.group_out), sizeof(op->data.mpi.group_out));
index += sizeof(op->data.mpi.group_out);

return index;
} /* umpi_unpack_op_MPI_Group_range_incl */


int umpi_unpack_op_MPI_Group_rank(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.group), sizeof(op->data.mpi.group));
index += sizeof(op->data.mpi.group);

bcopy (&buf[index], &(op->data.mpi.rank), sizeof(op->data.mpi.rank));
index += sizeof(op->data.mpi.rank);

return index;
} /* umpi_unpack_op_MPI_Group_rank */


int umpi_unpack_op_MPI_Group_size(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.group), sizeof(op->data.mpi.group));
index += sizeof(op->data.mpi.group);

bcopy (&buf[index], &(op->data.mpi.size), sizeof(op->data.mpi.size));
index += sizeof(op->data.mpi.size);

return index;
} /* umpi_unpack_op_MPI_Group_size */


int umpi_unpack_op_MPI_Group_translate_ranks(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.group1), sizeof(op->data.mpi.group1));
index += sizeof(op->data.mpi.group1);

bcopy (&buf[index], &(op->data.mpi.count), sizeof(op->data.mpi.count));
index += sizeof(op->data.mpi.count);

bcopy (&buf[index], &(temp), sizeof(int));
index += sizeof(int);

if (temp) {
op->data.mpi.array_of_ranks =
(int *) malloc (sizeof(op->data.mpi.array_of_ranks[0])*temp);
assert (op->data.mpi.array_of_ranks);
bcopy (&buf[index], op->data.mpi.array_of_ranks, sizeof(op->data.mpi.array_of_ranks[0])*temp);
index += (sizeof(op->data.mpi.array_of_ranks[0])*temp);
} else {
op->data.mpi.array_of_ranks = NULL;
}

bcopy (&buf[index], &(op->data.mpi.group2), sizeof(op->data.mpi.group2));
index += sizeof(op->data.mpi.group2);

bcopy (&buf[index], &(temp), sizeof(int));
index += sizeof(int);

if (temp) {
op->data.mpi.array_of_ranks2 =
(int *) malloc (sizeof(op->data.mpi.array_of_ranks2[0])*temp);
assert (op->data.mpi.array_of_ranks2);
bcopy (&buf[index], op->data.mpi.array_of_ranks2, sizeof(op->data.mpi.array_of_ranks2[0])*temp);
index += (sizeof(op->data.mpi.array_of_ranks2[0])*temp);
} else {
op->data.mpi.array_of_ranks2 = NULL;
}

return index;
} /* umpi_unpack_op_MPI_Group_translate_ranks */


int umpi_unpack_op_MPI_Group_union(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.group1), sizeof(op->data.mpi.group1));
index += sizeof(op->data.mpi.group1);

bcopy (&buf[index], &(op->data.mpi.group2), sizeof(op->data.mpi.group2));
index += sizeof(op->data.mpi.group2);

bcopy (&buf[index], &(op->data.mpi.group_out), sizeof(op->data.mpi.group_out));
index += sizeof(op->data.mpi.group_out);

return index;
} /* umpi_unpack_op_MPI_Group_union */


int umpi_unpack_op_MPI_Handle2int(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.c_handle), sizeof(op->data.mpi.c_handle));
index += sizeof(op->data.mpi.c_handle);

bcopy (&buf[index], &(op->data.mpi.handle_kind), sizeof(op->data.mpi.handle_kind));
index += sizeof(op->data.mpi.handle_kind);

return index;
} /* umpi_unpack_op_MPI_Handle2int */


int umpi_unpack_op_MPI_Ibsend(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.buf), sizeof(op->data.mpi.buf));
index += sizeof(op->data.mpi.buf);

bcopy (&buf[index], &(op->data.mpi.count), sizeof(op->data.mpi.count));
index += sizeof(op->data.mpi.count);

bcopy (&buf[index], &(op->data.mpi.datatype), sizeof(op->data.mpi.datatype));
index += sizeof(op->data.mpi.datatype);

bcopy (&buf[index], &(op->data.mpi.dest), sizeof(op->data.mpi.dest));
index += sizeof(op->data.mpi.dest);

bcopy (&buf[index], &(op->data.mpi.tag), sizeof(op->data.mpi.tag));
index += sizeof(op->data.mpi.tag);

bcopy (&buf[index], &(op->data.mpi.comm), sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

bcopy (&buf[index], &(op->data.mpi.request), sizeof(op->data.mpi.request));
index += sizeof(op->data.mpi.request);

return index;
} /* umpi_unpack_op_MPI_Ibsend */


int umpi_unpack_op_MPI_Info_c2f(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.info), sizeof(op->data.mpi.info));
index += sizeof(op->data.mpi.info);

return index;
} /* umpi_unpack_op_MPI_Info_c2f */


int umpi_unpack_op_MPI_Info_create(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.info), sizeof(op->data.mpi.info));
index += sizeof(op->data.mpi.info);

return index;
} /* umpi_unpack_op_MPI_Info_create */


int umpi_unpack_op_MPI_Info_delete(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.info), sizeof(op->data.mpi.info));
index += sizeof(op->data.mpi.info);

bcopy (&buf[index], &(op->data.mpi.key), sizeof(op->data.mpi.key));
index += sizeof(op->data.mpi.key);

return index;
} /* umpi_unpack_op_MPI_Info_delete */


int umpi_unpack_op_MPI_Info_dup(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.info), sizeof(op->data.mpi.info));
index += sizeof(op->data.mpi.info);

bcopy (&buf[index], &(op->data.mpi.newinfo), sizeof(op->data.mpi.newinfo));
index += sizeof(op->data.mpi.newinfo);

return index;
} /* umpi_unpack_op_MPI_Info_dup */


int umpi_unpack_op_MPI_Info_f2c(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.info), sizeof(op->data.mpi.info));
index += sizeof(op->data.mpi.info);

return index;
} /* umpi_unpack_op_MPI_Info_f2c */


int umpi_unpack_op_MPI_Info_free(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.info), sizeof(op->data.mpi.info));
index += sizeof(op->data.mpi.info);

return index;
} /* umpi_unpack_op_MPI_Info_free */


int umpi_unpack_op_MPI_Info_get(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.info), sizeof(op->data.mpi.info));
index += sizeof(op->data.mpi.info);

bcopy (&buf[index], &(op->data.mpi.key), sizeof(op->data.mpi.key));
index += sizeof(op->data.mpi.key);

bcopy (&buf[index], &(op->data.mpi.valuelen), sizeof(op->data.mpi.valuelen));
index += sizeof(op->data.mpi.valuelen);

bcopy (&buf[index], &(op->data.mpi.value), sizeof(op->data.mpi.value));
index += sizeof(op->data.mpi.value);

bcopy (&buf[index], &(op->data.mpi.flag), sizeof(op->data.mpi.flag));
index += sizeof(op->data.mpi.flag);

return index;
} /* umpi_unpack_op_MPI_Info_get */


int umpi_unpack_op_MPI_Info_get_nkeys(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.info), sizeof(op->data.mpi.info));
index += sizeof(op->data.mpi.info);

bcopy (&buf[index], &(op->data.mpi.nkeys), sizeof(op->data.mpi.nkeys));
index += sizeof(op->data.mpi.nkeys);

return index;
} /* umpi_unpack_op_MPI_Info_get_nkeys */


int umpi_unpack_op_MPI_Info_get_nthkey(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.info), sizeof(op->data.mpi.info));
index += sizeof(op->data.mpi.info);

bcopy (&buf[index], &(op->data.mpi.count), sizeof(op->data.mpi.count));
index += sizeof(op->data.mpi.count);

bcopy (&buf[index], &(op->data.mpi.key), sizeof(op->data.mpi.key));
index += sizeof(op->data.mpi.key);

return index;
} /* umpi_unpack_op_MPI_Info_get_nthkey */


int umpi_unpack_op_MPI_Info_get_valuelen(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.info), sizeof(op->data.mpi.info));
index += sizeof(op->data.mpi.info);

bcopy (&buf[index], &(op->data.mpi.key), sizeof(op->data.mpi.key));
index += sizeof(op->data.mpi.key);

bcopy (&buf[index], &(op->data.mpi.valuelen), sizeof(op->data.mpi.valuelen));
index += sizeof(op->data.mpi.valuelen);

bcopy (&buf[index], &(op->data.mpi.flag), sizeof(op->data.mpi.flag));
index += sizeof(op->data.mpi.flag);

return index;
} /* umpi_unpack_op_MPI_Info_get_valuelen */


int umpi_unpack_op_MPI_Info_set(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.info), sizeof(op->data.mpi.info));
index += sizeof(op->data.mpi.info);

bcopy (&buf[index], &(op->data.mpi.key), sizeof(op->data.mpi.key));
index += sizeof(op->data.mpi.key);

bcopy (&buf[index], &(op->data.mpi.value), sizeof(op->data.mpi.value));
index += sizeof(op->data.mpi.value);

return index;
} /* umpi_unpack_op_MPI_Info_set */


int umpi_unpack_op_MPI_Init(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.argc), sizeof(op->data.mpi.argc));
index += sizeof(op->data.mpi.argc);

bcopy (&buf[index], &(op->data.mpi.argv), sizeof(op->data.mpi.argv));
index += sizeof(op->data.mpi.argv);

return index;
} /* umpi_unpack_op_MPI_Init */


int umpi_unpack_op_MPI_Initialized(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.flag), sizeof(op->data.mpi.flag));
index += sizeof(op->data.mpi.flag);

return index;
} /* umpi_unpack_op_MPI_Initialized */


int umpi_unpack_op_MPI_Int2handle(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.f_handle), sizeof(op->data.mpi.f_handle));
index += sizeof(op->data.mpi.f_handle);

bcopy (&buf[index], &(op->data.mpi.handle_kind), sizeof(op->data.mpi.handle_kind));
index += sizeof(op->data.mpi.handle_kind);

return index;
} /* umpi_unpack_op_MPI_Int2handle */


int umpi_unpack_op_MPI_Intercomm_create(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.comm), sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

bcopy (&buf[index], &(op->data.mpi.local_leader), sizeof(op->data.mpi.local_leader));
index += sizeof(op->data.mpi.local_leader);

bcopy (&buf[index], &(op->data.mpi.peer_comm), sizeof(op->data.mpi.peer_comm));
index += sizeof(op->data.mpi.peer_comm);

bcopy (&buf[index], &(op->data.mpi.remote_leader), sizeof(op->data.mpi.remote_leader));
index += sizeof(op->data.mpi.remote_leader);

bcopy (&buf[index], &(op->data.mpi.tag), sizeof(op->data.mpi.tag));
index += sizeof(op->data.mpi.tag);

bcopy (&buf[index], &(op->data.mpi.comm_out), sizeof(op->data.mpi.comm_out));
index += sizeof(op->data.mpi.comm_out);

bcopy (&buf[index], &(op->data.mpi.comm1), sizeof(op->data.mpi.comm1));
index += sizeof(op->data.mpi.comm1);

return index;
} /* umpi_unpack_op_MPI_Intercomm_create */


int umpi_unpack_op_MPI_Intercomm_merge(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.comm), sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

bcopy (&buf[index], &(op->data.mpi.high), sizeof(op->data.mpi.high));
index += sizeof(op->data.mpi.high);

bcopy (&buf[index], &(op->data.mpi.comm_out), sizeof(op->data.mpi.comm_out));
index += sizeof(op->data.mpi.comm_out);

return index;
} /* umpi_unpack_op_MPI_Intercomm_merge */


int umpi_unpack_op_MPI_Iprobe(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.source), sizeof(op->data.mpi.source));
index += sizeof(op->data.mpi.source);

bcopy (&buf[index], &(op->data.mpi.tag), sizeof(op->data.mpi.tag));
index += sizeof(op->data.mpi.tag);

bcopy (&buf[index], &(op->data.mpi.comm), sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

bcopy (&buf[index], &(op->data.mpi.flag), sizeof(op->data.mpi.flag));
index += sizeof(op->data.mpi.flag);

bcopy (&buf[index], &(op->data.mpi.status_src), sizeof(op->data.mpi.status_src));
index += sizeof(op->data.mpi.status_src);

return index;
} /* umpi_unpack_op_MPI_Iprobe */


int umpi_unpack_op_MPI_Irecv(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.buf), sizeof(op->data.mpi.buf));
index += sizeof(op->data.mpi.buf);

bcopy (&buf[index], &(op->data.mpi.count), sizeof(op->data.mpi.count));
index += sizeof(op->data.mpi.count);

bcopy (&buf[index], &(op->data.mpi.datatype), sizeof(op->data.mpi.datatype));
index += sizeof(op->data.mpi.datatype);

bcopy (&buf[index], &(op->data.mpi.source), sizeof(op->data.mpi.source));
index += sizeof(op->data.mpi.source);

bcopy (&buf[index], &(op->data.mpi.tag), sizeof(op->data.mpi.tag));
index += sizeof(op->data.mpi.tag);

bcopy (&buf[index], &(op->data.mpi.comm), sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

bcopy (&buf[index], &(op->data.mpi.request), sizeof(op->data.mpi.request));
index += sizeof(op->data.mpi.request);

return index;
} /* umpi_unpack_op_MPI_Irecv */


int umpi_unpack_op_MPI_Irsend(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.buf), sizeof(op->data.mpi.buf));
index += sizeof(op->data.mpi.buf);

bcopy (&buf[index], &(op->data.mpi.count), sizeof(op->data.mpi.count));
index += sizeof(op->data.mpi.count);

bcopy (&buf[index], &(op->data.mpi.datatype), sizeof(op->data.mpi.datatype));
index += sizeof(op->data.mpi.datatype);

bcopy (&buf[index], &(op->data.mpi.dest), sizeof(op->data.mpi.dest));
index += sizeof(op->data.mpi.dest);

bcopy (&buf[index], &(op->data.mpi.tag), sizeof(op->data.mpi.tag));
index += sizeof(op->data.mpi.tag);

bcopy (&buf[index], &(op->data.mpi.comm), sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

bcopy (&buf[index], &(op->data.mpi.request), sizeof(op->data.mpi.request));
index += sizeof(op->data.mpi.request);

return index;
} /* umpi_unpack_op_MPI_Irsend */


int umpi_unpack_op_MPI_Isend(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.buf), sizeof(op->data.mpi.buf));
index += sizeof(op->data.mpi.buf);

bcopy (&buf[index], &(op->data.mpi.count), sizeof(op->data.mpi.count));
index += sizeof(op->data.mpi.count);

bcopy (&buf[index], &(op->data.mpi.datatype), sizeof(op->data.mpi.datatype));
index += sizeof(op->data.mpi.datatype);

bcopy (&buf[index], &(op->data.mpi.dest), sizeof(op->data.mpi.dest));
index += sizeof(op->data.mpi.dest);

bcopy (&buf[index], &(op->data.mpi.tag), sizeof(op->data.mpi.tag));
index += sizeof(op->data.mpi.tag);

bcopy (&buf[index], &(op->data.mpi.comm), sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

bcopy (&buf[index], &(op->data.mpi.request), sizeof(op->data.mpi.request));
index += sizeof(op->data.mpi.request);

return index;
} /* umpi_unpack_op_MPI_Isend */


int umpi_unpack_op_MPI_Issend(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.buf), sizeof(op->data.mpi.buf));
index += sizeof(op->data.mpi.buf);

bcopy (&buf[index], &(op->data.mpi.count), sizeof(op->data.mpi.count));
index += sizeof(op->data.mpi.count);

bcopy (&buf[index], &(op->data.mpi.datatype), sizeof(op->data.mpi.datatype));
index += sizeof(op->data.mpi.datatype);

bcopy (&buf[index], &(op->data.mpi.dest), sizeof(op->data.mpi.dest));
index += sizeof(op->data.mpi.dest);

bcopy (&buf[index], &(op->data.mpi.tag), sizeof(op->data.mpi.tag));
index += sizeof(op->data.mpi.tag);

bcopy (&buf[index], &(op->data.mpi.comm), sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

bcopy (&buf[index], &(op->data.mpi.request), sizeof(op->data.mpi.request));
index += sizeof(op->data.mpi.request);

return index;
} /* umpi_unpack_op_MPI_Issend */


int umpi_unpack_op_MPI_Keyval_create(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.copy_function), sizeof(op->data.mpi.copy_function));
index += sizeof(op->data.mpi.copy_function);

bcopy (&buf[index], &(op->data.mpi.delete_function), sizeof(op->data.mpi.delete_function));
index += sizeof(op->data.mpi.delete_function);

bcopy (&buf[index], &(op->data.mpi.keyval), sizeof(op->data.mpi.keyval));
index += sizeof(op->data.mpi.keyval);

bcopy (&buf[index], &(op->data.mpi.extra_state), sizeof(op->data.mpi.extra_state));
index += sizeof(op->data.mpi.extra_state);

return index;
} /* umpi_unpack_op_MPI_Keyval_create */


int umpi_unpack_op_MPI_Keyval_free(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.keyval), sizeof(op->data.mpi.keyval));
index += sizeof(op->data.mpi.keyval);

return index;
} /* umpi_unpack_op_MPI_Keyval_free */


int umpi_unpack_op_MPI_Op_create(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.function), sizeof(op->data.mpi.function));
index += sizeof(op->data.mpi.function);

bcopy (&buf[index], &(op->data.mpi.commute), sizeof(op->data.mpi.commute));
index += sizeof(op->data.mpi.commute);

bcopy (&buf[index], &(op->data.mpi.op), sizeof(op->data.mpi.op));
index += sizeof(op->data.mpi.op);

return index;
} /* umpi_unpack_op_MPI_Op_create */


int umpi_unpack_op_MPI_Op_free(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.op), sizeof(op->data.mpi.op));
index += sizeof(op->data.mpi.op);

return index;
} /* umpi_unpack_op_MPI_Op_free */


int umpi_unpack_op_MPI_Pack(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.inbuf), sizeof(op->data.mpi.inbuf));
index += sizeof(op->data.mpi.inbuf);

bcopy (&buf[index], &(op->data.mpi.incount), sizeof(op->data.mpi.incount));
index += sizeof(op->data.mpi.incount);

bcopy (&buf[index], &(op->data.mpi.datatype), sizeof(op->data.mpi.datatype));
index += sizeof(op->data.mpi.datatype);

bcopy (&buf[index], &(op->data.mpi.outbuf), sizeof(op->data.mpi.outbuf));
index += sizeof(op->data.mpi.outbuf);

bcopy (&buf[index], &(op->data.mpi.outcount), sizeof(op->data.mpi.outcount));
index += sizeof(op->data.mpi.outcount);

bcopy (&buf[index], &(op->data.mpi.position), sizeof(op->data.mpi.position));
index += sizeof(op->data.mpi.position);

bcopy (&buf[index], &(op->data.mpi.comm), sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

return index;
} /* umpi_unpack_op_MPI_Pack */


int umpi_unpack_op_MPI_Pack_size(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.incount), sizeof(op->data.mpi.incount));
index += sizeof(op->data.mpi.incount);

bcopy (&buf[index], &(op->data.mpi.datatype), sizeof(op->data.mpi.datatype));
index += sizeof(op->data.mpi.datatype);

bcopy (&buf[index], &(op->data.mpi.comm), sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

bcopy (&buf[index], &(op->data.mpi.size), sizeof(op->data.mpi.size));
index += sizeof(op->data.mpi.size);

return index;
} /* umpi_unpack_op_MPI_Pack_size */


int umpi_unpack_op_MPI_Pcontrol(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.level), sizeof(op->data.mpi.level));
index += sizeof(op->data.mpi.level);

return index;
} /* umpi_unpack_op_MPI_Pcontrol */


int umpi_unpack_op_MPI_Probe(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.source), sizeof(op->data.mpi.source));
index += sizeof(op->data.mpi.source);

bcopy (&buf[index], &(op->data.mpi.tag), sizeof(op->data.mpi.tag));
index += sizeof(op->data.mpi.tag);

bcopy (&buf[index], &(op->data.mpi.comm), sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

bcopy (&buf[index], &(op->data.mpi.status_src), sizeof(op->data.mpi.status_src));
index += sizeof(op->data.mpi.status_src);

return index;
} /* umpi_unpack_op_MPI_Probe */


int umpi_unpack_op_MPI_Recv(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.buf), sizeof(op->data.mpi.buf));
index += sizeof(op->data.mpi.buf);

bcopy (&buf[index], &(op->data.mpi.count), sizeof(op->data.mpi.count));
index += sizeof(op->data.mpi.count);

bcopy (&buf[index], &(op->data.mpi.datatype), sizeof(op->data.mpi.datatype));
index += sizeof(op->data.mpi.datatype);

bcopy (&buf[index], &(op->data.mpi.source), sizeof(op->data.mpi.source));
index += sizeof(op->data.mpi.source);

bcopy (&buf[index], &(op->data.mpi.tag), sizeof(op->data.mpi.tag));
index += sizeof(op->data.mpi.tag);

bcopy (&buf[index], &(op->data.mpi.comm), sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

bcopy (&buf[index], &(op->data.mpi.status_src), sizeof(op->data.mpi.status_src));
index += sizeof(op->data.mpi.status_src);

return index;
} /* umpi_unpack_op_MPI_Recv */


int umpi_unpack_op_MPI_Recv_init(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.buf), sizeof(op->data.mpi.buf));
index += sizeof(op->data.mpi.buf);

bcopy (&buf[index], &(op->data.mpi.count), sizeof(op->data.mpi.count));
index += sizeof(op->data.mpi.count);

bcopy (&buf[index], &(op->data.mpi.datatype), sizeof(op->data.mpi.datatype));
index += sizeof(op->data.mpi.datatype);

bcopy (&buf[index], &(op->data.mpi.source), sizeof(op->data.mpi.source));
index += sizeof(op->data.mpi.source);

bcopy (&buf[index], &(op->data.mpi.tag), sizeof(op->data.mpi.tag));
index += sizeof(op->data.mpi.tag);

bcopy (&buf[index], &(op->data.mpi.comm), sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

bcopy (&buf[index], &(op->data.mpi.request), sizeof(op->data.mpi.request));
index += sizeof(op->data.mpi.request);

return index;
} /* umpi_unpack_op_MPI_Recv_init */


int umpi_unpack_op_MPI_Reduce(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.buf), sizeof(op->data.mpi.buf));
index += sizeof(op->data.mpi.buf);

bcopy (&buf[index], &(op->data.mpi.recvbuf), sizeof(op->data.mpi.recvbuf));
index += sizeof(op->data.mpi.recvbuf);

bcopy (&buf[index], &(op->data.mpi.count), sizeof(op->data.mpi.count));
index += sizeof(op->data.mpi.count);

bcopy (&buf[index], &(op->data.mpi.datatype), sizeof(op->data.mpi.datatype));
index += sizeof(op->data.mpi.datatype);

bcopy (&buf[index], &(op->data.mpi.op), sizeof(op->data.mpi.op));
index += sizeof(op->data.mpi.op);

bcopy (&buf[index], &(op->data.mpi.root), sizeof(op->data.mpi.root));
index += sizeof(op->data.mpi.root);

bcopy (&buf[index], &(op->data.mpi.comm), sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

return index;
} /* umpi_unpack_op_MPI_Reduce */


int umpi_unpack_op_MPI_Reduce_scatter(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.buf), sizeof(op->data.mpi.buf));
index += sizeof(op->data.mpi.buf);

bcopy (&buf[index], &(op->data.mpi.recvbuf), sizeof(op->data.mpi.recvbuf));
index += sizeof(op->data.mpi.recvbuf);

bcopy (&buf[index], &(temp), sizeof(int));
index += sizeof(int);

if (temp) {
op->data.mpi.recvcounts =
(int *) malloc (sizeof(op->data.mpi.recvcounts[0])*temp);
assert (op->data.mpi.recvcounts);
bcopy (&buf[index], op->data.mpi.recvcounts, sizeof(op->data.mpi.recvcounts[0])*temp);
index += (sizeof(op->data.mpi.recvcounts[0])*temp);
} else {
op->data.mpi.recvcounts = NULL;
}

bcopy (&buf[index], &(op->data.mpi.datatype), sizeof(op->data.mpi.datatype));
index += sizeof(op->data.mpi.datatype);

bcopy (&buf[index], &(op->data.mpi.op), sizeof(op->data.mpi.op));
index += sizeof(op->data.mpi.op);

bcopy (&buf[index], &(op->data.mpi.comm), sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

bcopy (&buf[index], &(op->data.mpi.size), sizeof(op->data.mpi.size));
index += sizeof(op->data.mpi.size);

return index;
} /* umpi_unpack_op_MPI_Reduce_scatter */


int umpi_unpack_op_MPI_Request_c2f(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.c_request), sizeof(op->data.mpi.c_request));
index += sizeof(op->data.mpi.c_request);

return index;
} /* umpi_unpack_op_MPI_Request_c2f */


int umpi_unpack_op_MPI_Request_free(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.request), sizeof(op->data.mpi.request));
index += sizeof(op->data.mpi.request);

return index;
} /* umpi_unpack_op_MPI_Request_free */


int umpi_unpack_op_MPI_Rsend(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.buf), sizeof(op->data.mpi.buf));
index += sizeof(op->data.mpi.buf);

bcopy (&buf[index], &(op->data.mpi.count), sizeof(op->data.mpi.count));
index += sizeof(op->data.mpi.count);

bcopy (&buf[index], &(op->data.mpi.datatype), sizeof(op->data.mpi.datatype));
index += sizeof(op->data.mpi.datatype);

bcopy (&buf[index], &(op->data.mpi.dest), sizeof(op->data.mpi.dest));
index += sizeof(op->data.mpi.dest);

bcopy (&buf[index], &(op->data.mpi.tag), sizeof(op->data.mpi.tag));
index += sizeof(op->data.mpi.tag);

bcopy (&buf[index], &(op->data.mpi.comm), sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

return index;
} /* umpi_unpack_op_MPI_Rsend */


int umpi_unpack_op_MPI_Rsend_init(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.buf), sizeof(op->data.mpi.buf));
index += sizeof(op->data.mpi.buf);

bcopy (&buf[index], &(op->data.mpi.count), sizeof(op->data.mpi.count));
index += sizeof(op->data.mpi.count);

bcopy (&buf[index], &(op->data.mpi.datatype), sizeof(op->data.mpi.datatype));
index += sizeof(op->data.mpi.datatype);

bcopy (&buf[index], &(op->data.mpi.dest), sizeof(op->data.mpi.dest));
index += sizeof(op->data.mpi.dest);

bcopy (&buf[index], &(op->data.mpi.tag), sizeof(op->data.mpi.tag));
index += sizeof(op->data.mpi.tag);

bcopy (&buf[index], &(op->data.mpi.comm), sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

bcopy (&buf[index], &(op->data.mpi.request), sizeof(op->data.mpi.request));
index += sizeof(op->data.mpi.request);

return index;
} /* umpi_unpack_op_MPI_Rsend_init */


int umpi_unpack_op_MPI_Scan(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.buf), sizeof(op->data.mpi.buf));
index += sizeof(op->data.mpi.buf);

bcopy (&buf[index], &(op->data.mpi.recvbuf), sizeof(op->data.mpi.recvbuf));
index += sizeof(op->data.mpi.recvbuf);

bcopy (&buf[index], &(op->data.mpi.count), sizeof(op->data.mpi.count));
index += sizeof(op->data.mpi.count);

bcopy (&buf[index], &(op->data.mpi.datatype), sizeof(op->data.mpi.datatype));
index += sizeof(op->data.mpi.datatype);

bcopy (&buf[index], &(op->data.mpi.op), sizeof(op->data.mpi.op));
index += sizeof(op->data.mpi.op);

bcopy (&buf[index], &(op->data.mpi.comm), sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

return index;
} /* umpi_unpack_op_MPI_Scan */


int umpi_unpack_op_MPI_Scatter(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.buf), sizeof(op->data.mpi.buf));
index += sizeof(op->data.mpi.buf);

bcopy (&buf[index], &(op->data.mpi.count), sizeof(op->data.mpi.count));
index += sizeof(op->data.mpi.count);

bcopy (&buf[index], &(op->data.mpi.datatype), sizeof(op->data.mpi.datatype));
index += sizeof(op->data.mpi.datatype);

bcopy (&buf[index], &(op->data.mpi.recvbuf), sizeof(op->data.mpi.recvbuf));
index += sizeof(op->data.mpi.recvbuf);

bcopy (&buf[index], &(op->data.mpi.recvcount), sizeof(op->data.mpi.recvcount));
index += sizeof(op->data.mpi.recvcount);

bcopy (&buf[index], &(op->data.mpi.recvtype), sizeof(op->data.mpi.recvtype));
index += sizeof(op->data.mpi.recvtype);

bcopy (&buf[index], &(op->data.mpi.root), sizeof(op->data.mpi.root));
index += sizeof(op->data.mpi.root);

bcopy (&buf[index], &(op->data.mpi.comm), sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

return index;
} /* umpi_unpack_op_MPI_Scatter */


int umpi_unpack_op_MPI_Scatterv(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.buf), sizeof(op->data.mpi.buf));
index += sizeof(op->data.mpi.buf);

bcopy (&buf[index], &(temp), sizeof(int));
index += sizeof(int);

if (temp) {
op->data.mpi.counts =
(int *) malloc (sizeof(op->data.mpi.counts[0])*temp);
assert (op->data.mpi.counts);
bcopy (&buf[index], op->data.mpi.counts, sizeof(op->data.mpi.counts[0])*temp);
index += (sizeof(op->data.mpi.counts[0])*temp);
} else {
op->data.mpi.counts = NULL;
}

bcopy (&buf[index], &(temp), sizeof(int));
index += sizeof(int);

if (temp) {
op->data.mpi.displs =
(int *) malloc (sizeof(op->data.mpi.displs[0])*temp);
assert (op->data.mpi.displs);
bcopy (&buf[index], op->data.mpi.displs, sizeof(op->data.mpi.displs[0])*temp);
index += (sizeof(op->data.mpi.displs[0])*temp);
} else {
op->data.mpi.displs = NULL;
}

bcopy (&buf[index], &(op->data.mpi.datatype), sizeof(op->data.mpi.datatype));
index += sizeof(op->data.mpi.datatype);

bcopy (&buf[index], &(op->data.mpi.recvbuf), sizeof(op->data.mpi.recvbuf));
index += sizeof(op->data.mpi.recvbuf);

bcopy (&buf[index], &(op->data.mpi.recvcount), sizeof(op->data.mpi.recvcount));
index += sizeof(op->data.mpi.recvcount);

bcopy (&buf[index], &(op->data.mpi.recvtype), sizeof(op->data.mpi.recvtype));
index += sizeof(op->data.mpi.recvtype);

bcopy (&buf[index], &(op->data.mpi.root), sizeof(op->data.mpi.root));
index += sizeof(op->data.mpi.root);

bcopy (&buf[index], &(op->data.mpi.comm), sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

bcopy (&buf[index], &(op->data.mpi.size), sizeof(op->data.mpi.size));
index += sizeof(op->data.mpi.size);

return index;
} /* umpi_unpack_op_MPI_Scatterv */


int umpi_unpack_op_MPI_Send(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.buf), sizeof(op->data.mpi.buf));
index += sizeof(op->data.mpi.buf);

bcopy (&buf[index], &(op->data.mpi.count), sizeof(op->data.mpi.count));
index += sizeof(op->data.mpi.count);

bcopy (&buf[index], &(op->data.mpi.datatype), sizeof(op->data.mpi.datatype));
index += sizeof(op->data.mpi.datatype);

bcopy (&buf[index], &(op->data.mpi.dest), sizeof(op->data.mpi.dest));
index += sizeof(op->data.mpi.dest);

bcopy (&buf[index], &(op->data.mpi.tag), sizeof(op->data.mpi.tag));
index += sizeof(op->data.mpi.tag);

bcopy (&buf[index], &(op->data.mpi.comm), sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

return index;
} /* umpi_unpack_op_MPI_Send */


int umpi_unpack_op_MPI_Send_init(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.buf), sizeof(op->data.mpi.buf));
index += sizeof(op->data.mpi.buf);

bcopy (&buf[index], &(op->data.mpi.count), sizeof(op->data.mpi.count));
index += sizeof(op->data.mpi.count);

bcopy (&buf[index], &(op->data.mpi.datatype), sizeof(op->data.mpi.datatype));
index += sizeof(op->data.mpi.datatype);

bcopy (&buf[index], &(op->data.mpi.dest), sizeof(op->data.mpi.dest));
index += sizeof(op->data.mpi.dest);

bcopy (&buf[index], &(op->data.mpi.tag), sizeof(op->data.mpi.tag));
index += sizeof(op->data.mpi.tag);

bcopy (&buf[index], &(op->data.mpi.comm), sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

bcopy (&buf[index], &(op->data.mpi.request), sizeof(op->data.mpi.request));
index += sizeof(op->data.mpi.request);

return index;
} /* umpi_unpack_op_MPI_Send_init */


int umpi_unpack_op_MPI_Sendrecv(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.buf), sizeof(op->data.mpi.buf));
index += sizeof(op->data.mpi.buf);

bcopy (&buf[index], &(op->data.mpi.count), sizeof(op->data.mpi.count));
index += sizeof(op->data.mpi.count);

bcopy (&buf[index], &(op->data.mpi.datatype), sizeof(op->data.mpi.datatype));
index += sizeof(op->data.mpi.datatype);

bcopy (&buf[index], &(op->data.mpi.dest), sizeof(op->data.mpi.dest));
index += sizeof(op->data.mpi.dest);

bcopy (&buf[index], &(op->data.mpi.sendtag), sizeof(op->data.mpi.sendtag));
index += sizeof(op->data.mpi.sendtag);

bcopy (&buf[index], &(op->data.mpi.recvbuf), sizeof(op->data.mpi.recvbuf));
index += sizeof(op->data.mpi.recvbuf);

bcopy (&buf[index], &(op->data.mpi.recvcount), sizeof(op->data.mpi.recvcount));
index += sizeof(op->data.mpi.recvcount);

bcopy (&buf[index], &(op->data.mpi.recvtype), sizeof(op->data.mpi.recvtype));
index += sizeof(op->data.mpi.recvtype);

bcopy (&buf[index], &(op->data.mpi.source), sizeof(op->data.mpi.source));
index += sizeof(op->data.mpi.source);

bcopy (&buf[index], &(op->data.mpi.recvtag), sizeof(op->data.mpi.recvtag));
index += sizeof(op->data.mpi.recvtag);

bcopy (&buf[index], &(op->data.mpi.comm), sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

bcopy (&buf[index], &(op->data.mpi.status_src), sizeof(op->data.mpi.status_src));
index += sizeof(op->data.mpi.status_src);

return index;
} /* umpi_unpack_op_MPI_Sendrecv */


int umpi_unpack_op_MPI_Sendrecv_replace(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.buf), sizeof(op->data.mpi.buf));
index += sizeof(op->data.mpi.buf);

bcopy (&buf[index], &(op->data.mpi.count), sizeof(op->data.mpi.count));
index += sizeof(op->data.mpi.count);

bcopy (&buf[index], &(op->data.mpi.datatype), sizeof(op->data.mpi.datatype));
index += sizeof(op->data.mpi.datatype);

bcopy (&buf[index], &(op->data.mpi.dest), sizeof(op->data.mpi.dest));
index += sizeof(op->data.mpi.dest);

bcopy (&buf[index], &(op->data.mpi.sendtag), sizeof(op->data.mpi.sendtag));
index += sizeof(op->data.mpi.sendtag);

bcopy (&buf[index], &(op->data.mpi.source), sizeof(op->data.mpi.source));
index += sizeof(op->data.mpi.source);

bcopy (&buf[index], &(op->data.mpi.recvtag), sizeof(op->data.mpi.recvtag));
index += sizeof(op->data.mpi.recvtag);

bcopy (&buf[index], &(op->data.mpi.comm), sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

bcopy (&buf[index], &(op->data.mpi.status_src), sizeof(op->data.mpi.status_src));
index += sizeof(op->data.mpi.status_src);

bcopy (&buf[index], &(op->data.mpi.recvbuf), sizeof(op->data.mpi.recvbuf));
index += sizeof(op->data.mpi.recvbuf);

bcopy (&buf[index], &(op->data.mpi.recvcount), sizeof(op->data.mpi.recvcount));
index += sizeof(op->data.mpi.recvcount);

bcopy (&buf[index], &(op->data.mpi.recvtype), sizeof(op->data.mpi.recvtype));
index += sizeof(op->data.mpi.recvtype);

return index;
} /* umpi_unpack_op_MPI_Sendrecv_replace */


int umpi_unpack_op_MPI_Ssend(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.buf), sizeof(op->data.mpi.buf));
index += sizeof(op->data.mpi.buf);

bcopy (&buf[index], &(op->data.mpi.count), sizeof(op->data.mpi.count));
index += sizeof(op->data.mpi.count);

bcopy (&buf[index], &(op->data.mpi.datatype), sizeof(op->data.mpi.datatype));
index += sizeof(op->data.mpi.datatype);

bcopy (&buf[index], &(op->data.mpi.dest), sizeof(op->data.mpi.dest));
index += sizeof(op->data.mpi.dest);

bcopy (&buf[index], &(op->data.mpi.tag), sizeof(op->data.mpi.tag));
index += sizeof(op->data.mpi.tag);

bcopy (&buf[index], &(op->data.mpi.comm), sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

return index;
} /* umpi_unpack_op_MPI_Ssend */


int umpi_unpack_op_MPI_Ssend_init(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.buf), sizeof(op->data.mpi.buf));
index += sizeof(op->data.mpi.buf);

bcopy (&buf[index], &(op->data.mpi.count), sizeof(op->data.mpi.count));
index += sizeof(op->data.mpi.count);

bcopy (&buf[index], &(op->data.mpi.datatype), sizeof(op->data.mpi.datatype));
index += sizeof(op->data.mpi.datatype);

bcopy (&buf[index], &(op->data.mpi.dest), sizeof(op->data.mpi.dest));
index += sizeof(op->data.mpi.dest);

bcopy (&buf[index], &(op->data.mpi.tag), sizeof(op->data.mpi.tag));
index += sizeof(op->data.mpi.tag);

bcopy (&buf[index], &(op->data.mpi.comm), sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

bcopy (&buf[index], &(op->data.mpi.request), sizeof(op->data.mpi.request));
index += sizeof(op->data.mpi.request);

return index;
} /* umpi_unpack_op_MPI_Ssend_init */


int umpi_unpack_op_MPI_Start(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.request), sizeof(op->data.mpi.request));
index += sizeof(op->data.mpi.request);

return index;
} /* umpi_unpack_op_MPI_Start */


int umpi_unpack_op_MPI_Startall(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.count), sizeof(op->data.mpi.count));
index += sizeof(op->data.mpi.count);

bcopy (&buf[index], &(temp), sizeof(int));
index += sizeof(int);

if (temp) {
op->data.mpi.array_of_requests =
(int *) malloc (sizeof(op->data.mpi.array_of_requests[0])*temp);
assert (op->data.mpi.array_of_requests);
bcopy (&buf[index], op->data.mpi.array_of_requests, sizeof(op->data.mpi.array_of_requests[0])*temp);
index += (sizeof(op->data.mpi.array_of_requests[0])*temp);
} else {
op->data.mpi.array_of_requests = NULL;
}

return index;
} /* umpi_unpack_op_MPI_Startall */


int umpi_unpack_op_MPI_Status_c2f(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.c_status), sizeof(op->data.mpi.c_status));
index += sizeof(op->data.mpi.c_status);

bcopy (&buf[index], &(op->data.mpi.f_status), sizeof(op->data.mpi.f_status));
index += sizeof(op->data.mpi.f_status);

return index;
} /* umpi_unpack_op_MPI_Status_c2f */


int umpi_unpack_op_MPI_Status_f2c(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.f_status), sizeof(op->data.mpi.f_status));
index += sizeof(op->data.mpi.f_status);

bcopy (&buf[index], &(op->data.mpi.c_status), sizeof(op->data.mpi.c_status));
index += sizeof(op->data.mpi.c_status);

return index;
} /* umpi_unpack_op_MPI_Status_f2c */


int umpi_unpack_op_MPI_Test(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.request), sizeof(op->data.mpi.request));
index += sizeof(op->data.mpi.request);

bcopy (&buf[index], &(op->data.mpi.flag), sizeof(op->data.mpi.flag));
index += sizeof(op->data.mpi.flag);

bcopy (&buf[index], &(op->data.mpi.status_src), sizeof(op->data.mpi.status_src));
index += sizeof(op->data.mpi.status_src);

return index;
} /* umpi_unpack_op_MPI_Test */


int umpi_unpack_op_MPI_Test_cancelled(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.status_src), sizeof(op->data.mpi.status_src));
index += sizeof(op->data.mpi.status_src);

bcopy (&buf[index], &(op->data.mpi.flag), sizeof(op->data.mpi.flag));
index += sizeof(op->data.mpi.flag);

return index;
} /* umpi_unpack_op_MPI_Test_cancelled */


int umpi_unpack_op_MPI_Testall(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.count), sizeof(op->data.mpi.count));
index += sizeof(op->data.mpi.count);

bcopy (&buf[index], &(temp), sizeof(int));
index += sizeof(int);

if (temp) {
op->data.mpi.array_of_requests =
(int *) malloc (sizeof(op->data.mpi.array_of_requests[0])*temp);
assert (op->data.mpi.array_of_requests);
bcopy (&buf[index], op->data.mpi.array_of_requests, sizeof(op->data.mpi.array_of_requests[0])*temp);
index += (sizeof(op->data.mpi.array_of_requests[0])*temp);
} else {
op->data.mpi.array_of_requests = NULL;
}

bcopy (&buf[index], &(op->data.mpi.flag), sizeof(op->data.mpi.flag));
index += sizeof(op->data.mpi.flag);

bcopy (&buf[index], &(temp), sizeof(int));
index += sizeof(int);

if (temp) {
op->data.mpi.statuses_srcs =
(int *) malloc (sizeof(op->data.mpi.statuses_srcs[0])*temp);
assert (op->data.mpi.statuses_srcs);
bcopy (&buf[index], op->data.mpi.statuses_srcs, sizeof(op->data.mpi.statuses_srcs[0])*temp);
index += (sizeof(op->data.mpi.statuses_srcs[0])*temp);
} else {
op->data.mpi.statuses_srcs = NULL;
}

return index;
} /* umpi_unpack_op_MPI_Testall */


int umpi_unpack_op_MPI_Testany(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.count), sizeof(op->data.mpi.count));
index += sizeof(op->data.mpi.count);

bcopy (&buf[index], &(temp), sizeof(int));
index += sizeof(int);

if (temp) {
op->data.mpi.array_of_requests =
(int *) malloc (sizeof(op->data.mpi.array_of_requests[0])*temp);
assert (op->data.mpi.array_of_requests);
bcopy (&buf[index], op->data.mpi.array_of_requests, sizeof(op->data.mpi.array_of_requests[0])*temp);
index += (sizeof(op->data.mpi.array_of_requests[0])*temp);
} else {
op->data.mpi.array_of_requests = NULL;
}

bcopy (&buf[index], &(op->data.mpi.index), sizeof(op->data.mpi.index));
index += sizeof(op->data.mpi.index);

bcopy (&buf[index], &(op->data.mpi.flag), sizeof(op->data.mpi.flag));
index += sizeof(op->data.mpi.flag);

bcopy (&buf[index], &(op->data.mpi.status_src), sizeof(op->data.mpi.status_src));
index += sizeof(op->data.mpi.status_src);

return index;
} /* umpi_unpack_op_MPI_Testany */


int umpi_unpack_op_MPI_Testsome(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.count), sizeof(op->data.mpi.count));
index += sizeof(op->data.mpi.count);

bcopy (&buf[index], &(temp), sizeof(int));
index += sizeof(int);

if (temp) {
op->data.mpi.array_of_requests =
(int *) malloc (sizeof(op->data.mpi.array_of_requests[0])*temp);
assert (op->data.mpi.array_of_requests);
bcopy (&buf[index], op->data.mpi.array_of_requests, sizeof(op->data.mpi.array_of_requests[0])*temp);
index += (sizeof(op->data.mpi.array_of_requests[0])*temp);
} else {
op->data.mpi.array_of_requests = NULL;
}

bcopy (&buf[index], &(op->data.mpi.outcount), sizeof(op->data.mpi.outcount));
index += sizeof(op->data.mpi.outcount);

bcopy (&buf[index], &(temp), sizeof(int));
index += sizeof(int);

if (temp) {
op->data.mpi.array_of_indices =
(int *) malloc (sizeof(op->data.mpi.array_of_indices[0])*temp);
assert (op->data.mpi.array_of_indices);
bcopy (&buf[index], op->data.mpi.array_of_indices, sizeof(op->data.mpi.array_of_indices[0])*temp);
index += (sizeof(op->data.mpi.array_of_indices[0])*temp);
} else {
op->data.mpi.array_of_indices = NULL;
}

bcopy (&buf[index], &(temp), sizeof(int));
index += sizeof(int);

if (temp) {
op->data.mpi.statuses_srcs =
(int *) malloc (sizeof(op->data.mpi.statuses_srcs[0])*temp);
assert (op->data.mpi.statuses_srcs);
bcopy (&buf[index], op->data.mpi.statuses_srcs, sizeof(op->data.mpi.statuses_srcs[0])*temp);
index += (sizeof(op->data.mpi.statuses_srcs[0])*temp);
} else {
op->data.mpi.statuses_srcs = NULL;
}

bcopy (&buf[index], &(op->data.mpi.flag), sizeof(op->data.mpi.flag));
index += sizeof(op->data.mpi.flag);

return index;
} /* umpi_unpack_op_MPI_Testsome */


int umpi_unpack_op_MPI_Topo_test(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.comm), sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

bcopy (&buf[index], &(op->data.mpi.top_type), sizeof(op->data.mpi.top_type));
index += sizeof(op->data.mpi.top_type);

return index;
} /* umpi_unpack_op_MPI_Topo_test */


int umpi_unpack_op_MPI_Type_commit(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.newtype), sizeof(op->data.mpi.newtype));
index += sizeof(op->data.mpi.newtype);

//umpi_unpack_typemap (buf, &(op->themap), &index);

return index;
} /* umpi_unpack_op_MPI_Type_commit */


int umpi_unpack_op_MPI_Type_contiguous(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.count), sizeof(op->data.mpi.count));
index += sizeof(op->data.mpi.count);

bcopy (&buf[index], &(op->data.mpi.old_type), sizeof(op->data.mpi.old_type));
index += sizeof(op->data.mpi.old_type);

bcopy (&buf[index], &(op->data.mpi.newtype), sizeof(op->data.mpi.newtype));
index += sizeof(op->data.mpi.newtype);

return index;
} /* umpi_unpack_op_MPI_Type_contiguous */


int umpi_unpack_op_MPI_Type_count(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.datatype), sizeof(op->data.mpi.datatype));
index += sizeof(op->data.mpi.datatype);

bcopy (&buf[index], &(op->data.mpi.count), sizeof(op->data.mpi.count));
index += sizeof(op->data.mpi.count);

return index;
} /* umpi_unpack_op_MPI_Type_count */


int umpi_unpack_op_MPI_Type_create_darray(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.size), sizeof(op->data.mpi.size));
index += sizeof(op->data.mpi.size);

bcopy (&buf[index], &(op->data.mpi.rank), sizeof(op->data.mpi.rank));
index += sizeof(op->data.mpi.rank);

bcopy (&buf[index], &(op->data.mpi.count), sizeof(op->data.mpi.count));
index += sizeof(op->data.mpi.count);

bcopy (&buf[index], &(temp), sizeof(int));
index += sizeof(int);

if (temp) {
op->data.mpi.array_of_gsizes =
(int *) malloc (sizeof(op->data.mpi.array_of_gsizes[0])*temp);
assert (op->data.mpi.array_of_gsizes);
bcopy (&buf[index], op->data.mpi.array_of_gsizes, sizeof(op->data.mpi.array_of_gsizes[0])*temp);
index += (sizeof(op->data.mpi.array_of_gsizes[0])*temp);
} else {
op->data.mpi.array_of_gsizes = NULL;
}

bcopy (&buf[index], &(temp), sizeof(int));
index += sizeof(int);

if (temp) {
op->data.mpi.array_of_distribs =
(int *) malloc (sizeof(op->data.mpi.array_of_distribs[0])*temp);
assert (op->data.mpi.array_of_distribs);
bcopy (&buf[index], op->data.mpi.array_of_distribs, sizeof(op->data.mpi.array_of_distribs[0])*temp);
index += (sizeof(op->data.mpi.array_of_distribs[0])*temp);
} else {
op->data.mpi.array_of_distribs = NULL;
}

bcopy (&buf[index], &(temp), sizeof(int));
index += sizeof(int);

if (temp) {
op->data.mpi.array_of_dargs =
(int *) malloc (sizeof(op->data.mpi.array_of_dargs[0])*temp);
assert (op->data.mpi.array_of_dargs);
bcopy (&buf[index], op->data.mpi.array_of_dargs, sizeof(op->data.mpi.array_of_dargs[0])*temp);
index += (sizeof(op->data.mpi.array_of_dargs[0])*temp);
} else {
op->data.mpi.array_of_dargs = NULL;
}

bcopy (&buf[index], &(temp), sizeof(int));
index += sizeof(int);

if (temp) {
op->data.mpi.array_of_psizes =
(int *) malloc (sizeof(op->data.mpi.array_of_psizes[0])*temp);
assert (op->data.mpi.array_of_psizes);
bcopy (&buf[index], op->data.mpi.array_of_psizes, sizeof(op->data.mpi.array_of_psizes[0])*temp);
index += (sizeof(op->data.mpi.array_of_psizes[0])*temp);
} else {
op->data.mpi.array_of_psizes = NULL;
}

bcopy (&buf[index], &(op->data.mpi.order), sizeof(op->data.mpi.order));
index += sizeof(op->data.mpi.order);

bcopy (&buf[index], &(op->data.mpi.datatype), sizeof(op->data.mpi.datatype));
index += sizeof(op->data.mpi.datatype);

bcopy (&buf[index], &(op->data.mpi.newtype), sizeof(op->data.mpi.newtype));
index += sizeof(op->data.mpi.newtype);

return index;
} /* umpi_unpack_op_MPI_Type_create_darray */


int umpi_unpack_op_MPI_Type_create_indexed_block(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.count), sizeof(op->data.mpi.count));
index += sizeof(op->data.mpi.count);

bcopy (&buf[index], &(op->data.mpi.blocklength), sizeof(op->data.mpi.blocklength));
index += sizeof(op->data.mpi.blocklength);

bcopy (&buf[index], &(temp), sizeof(int));
index += sizeof(int);

if (temp) {
op->data.mpi.array_of_displacements =
(int *) malloc (sizeof(op->data.mpi.array_of_displacements[0])*temp);
assert (op->data.mpi.array_of_displacements);
bcopy (&buf[index], op->data.mpi.array_of_displacements, sizeof(op->data.mpi.array_of_displacements[0])*temp);
index += (sizeof(op->data.mpi.array_of_displacements[0])*temp);
} else {
op->data.mpi.array_of_displacements = NULL;
}

bcopy (&buf[index], &(op->data.mpi.datatype), sizeof(op->data.mpi.datatype));
index += sizeof(op->data.mpi.datatype);

bcopy (&buf[index], &(op->data.mpi.newtype), sizeof(op->data.mpi.newtype));
index += sizeof(op->data.mpi.newtype);

return index;
} /* umpi_unpack_op_MPI_Type_create_indexed_block */


int umpi_unpack_op_MPI_Type_create_subarray(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.count), sizeof(op->data.mpi.count));
index += sizeof(op->data.mpi.count);

bcopy (&buf[index], &(temp), sizeof(int));
index += sizeof(int);

if (temp) {
op->data.mpi.array_of_sizes =
(int *) malloc (sizeof(op->data.mpi.array_of_sizes[0])*temp);
assert (op->data.mpi.array_of_sizes);
bcopy (&buf[index], op->data.mpi.array_of_sizes, sizeof(op->data.mpi.array_of_sizes[0])*temp);
index += (sizeof(op->data.mpi.array_of_sizes[0])*temp);
} else {
op->data.mpi.array_of_sizes = NULL;
}

bcopy (&buf[index], &(temp), sizeof(int));
index += sizeof(int);

if (temp) {
op->data.mpi.array_of_subsizes =
(int *) malloc (sizeof(op->data.mpi.array_of_subsizes[0])*temp);
assert (op->data.mpi.array_of_subsizes);
bcopy (&buf[index], op->data.mpi.array_of_subsizes, sizeof(op->data.mpi.array_of_subsizes[0])*temp);
index += (sizeof(op->data.mpi.array_of_subsizes[0])*temp);
} else {
op->data.mpi.array_of_subsizes = NULL;
}

bcopy (&buf[index], &(temp), sizeof(int));
index += sizeof(int);

if (temp) {
op->data.mpi.array_of_starts =
(int *) malloc (sizeof(op->data.mpi.array_of_starts[0])*temp);
assert (op->data.mpi.array_of_starts);
bcopy (&buf[index], op->data.mpi.array_of_starts, sizeof(op->data.mpi.array_of_starts[0])*temp);
index += (sizeof(op->data.mpi.array_of_starts[0])*temp);
} else {
op->data.mpi.array_of_starts = NULL;
}

bcopy (&buf[index], &(op->data.mpi.order), sizeof(op->data.mpi.order));
index += sizeof(op->data.mpi.order);

bcopy (&buf[index], &(op->data.mpi.datatype), sizeof(op->data.mpi.datatype));
index += sizeof(op->data.mpi.datatype);

bcopy (&buf[index], &(op->data.mpi.newtype), sizeof(op->data.mpi.newtype));
index += sizeof(op->data.mpi.newtype);

return index;
} /* umpi_unpack_op_MPI_Type_create_subarray */


int umpi_unpack_op_MPI_Type_extent(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.datatype), sizeof(op->data.mpi.datatype));
index += sizeof(op->data.mpi.datatype);

bcopy (&buf[index], &(op->data.mpi.extent), sizeof(op->data.mpi.extent));
index += sizeof(op->data.mpi.extent);

return index;
} /* umpi_unpack_op_MPI_Type_extent */


int umpi_unpack_op_MPI_Type_free(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.newtype), sizeof(op->data.mpi.newtype));
index += sizeof(op->data.mpi.newtype);

return index;
} /* umpi_unpack_op_MPI_Type_free */


int umpi_unpack_op_MPI_Type_get_contents(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.datatype), sizeof(op->data.mpi.datatype));
index += sizeof(op->data.mpi.datatype);

bcopy (&buf[index], &(op->data.mpi.count), sizeof(op->data.mpi.count));
index += sizeof(op->data.mpi.count);

bcopy (&buf[index], &(op->data.mpi.addrcount), sizeof(op->data.mpi.addrcount));
index += sizeof(op->data.mpi.addrcount);

bcopy (&buf[index], &(op->data.mpi.dtypecount), sizeof(op->data.mpi.dtypecount));
index += sizeof(op->data.mpi.dtypecount);

bcopy (&buf[index], &(temp), sizeof(int));
index += sizeof(int);

if (temp) {
op->data.mpi.array_of_integers =
(int *) malloc (sizeof(op->data.mpi.array_of_integers[0])*temp);
assert (op->data.mpi.array_of_integers);
bcopy (&buf[index], op->data.mpi.array_of_integers, sizeof(op->data.mpi.array_of_integers[0])*temp);
index += (sizeof(op->data.mpi.array_of_integers[0])*temp);
} else {
op->data.mpi.array_of_integers = NULL;
}

bcopy (&buf[index], &(temp), sizeof(int));
index += sizeof(int);

if (temp) {
op->data.mpi.the_addresses =
(int *) malloc (sizeof(op->data.mpi.the_addresses[0])*temp);
assert (op->data.mpi.the_addresses);
bcopy (&buf[index], op->data.mpi.the_addresses, sizeof(op->data.mpi.the_addresses[0])*temp);
index += (sizeof(op->data.mpi.the_addresses[0])*temp);

} else {
op->data.mpi.the_addresses = NULL;
}

bcopy (&buf[index], &(temp), sizeof(int));
index += sizeof(int);

if (temp) {
op->data.mpi.the_datatypes =
(int *) malloc (sizeof(op->data.mpi.the_datatypes[0])*temp);
assert (op->data.mpi.the_datatypes);
bcopy (&buf[index], op->data.mpi.the_datatypes, sizeof(op->data.mpi.the_datatypes[0])*temp);
index += (sizeof(op->data.mpi.the_datatypes[0])*temp);

} else {
op->data.mpi.the_datatypes = NULL;
}

return index;
} /* umpi_unpack_op_MPI_Type_get_contents */


int umpi_unpack_op_MPI_Type_get_envelope(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.datatype), sizeof(op->data.mpi.datatype));
index += sizeof(op->data.mpi.datatype);

bcopy (&buf[index], &(op->data.mpi.num_integers), sizeof(op->data.mpi.num_integers));
index += sizeof(op->data.mpi.num_integers);

bcopy (&buf[index], &(op->data.mpi.num_addresses), sizeof(op->data.mpi.num_addresses));
index += sizeof(op->data.mpi.num_addresses);

bcopy (&buf[index], &(op->data.mpi.num_datatypes), sizeof(op->data.mpi.num_datatypes));
index += sizeof(op->data.mpi.num_datatypes);

bcopy (&buf[index], &(op->data.mpi.combiner), sizeof(op->data.mpi.combiner));
index += sizeof(op->data.mpi.combiner);

return index;
} /* umpi_unpack_op_MPI_Type_get_envelope */


int umpi_unpack_op_MPI_Type_hindexed(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.count), sizeof(op->data.mpi.count));
index += sizeof(op->data.mpi.count);

bcopy (&buf[index], &(temp), sizeof(int));
index += sizeof(int);

if (temp) {
op->data.mpi.array_of_blocklens =
(int *) malloc (sizeof(op->data.mpi.array_of_blocklens[0])*temp);
assert (op->data.mpi.array_of_blocklens);
bcopy (&buf[index], op->data.mpi.array_of_blocklens, sizeof(op->data.mpi.array_of_blocklens[0])*temp);
index += (sizeof(op->data.mpi.array_of_blocklens[0])*temp);
} else {
op->data.mpi.array_of_blocklens = NULL;
}

bcopy (&buf[index], &(temp), sizeof(int));
index += sizeof(int);

if (temp) {
op->data.mpi.array_of_displacements =
(int *) malloc (sizeof(op->data.mpi.array_of_displacements[0])*temp);
assert (op->data.mpi.array_of_displacements);
bcopy (&buf[index], op->data.mpi.array_of_displacements, sizeof(op->data.mpi.array_of_displacements[0])*temp);
index += (sizeof(op->data.mpi.array_of_displacements[0])*temp);
} else {
op->data.mpi.array_of_displacements = NULL;
}

bcopy (&buf[index], &(op->data.mpi.datatype), sizeof(op->data.mpi.datatype));
index += sizeof(op->data.mpi.datatype);

bcopy (&buf[index], &(op->data.mpi.newtype), sizeof(op->data.mpi.newtype));
index += sizeof(op->data.mpi.newtype);

return index;
} /* umpi_unpack_op_MPI_Type_hindexed */


int umpi_unpack_op_MPI_Type_hvector(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.count), sizeof(op->data.mpi.count));
index += sizeof(op->data.mpi.count);

bcopy (&buf[index], &(op->data.mpi.blocklen), sizeof(op->data.mpi.blocklen));
index += sizeof(op->data.mpi.blocklen);

bcopy (&buf[index], &(op->data.mpi.stride), sizeof(op->data.mpi.stride));
index += sizeof(op->data.mpi.stride);

bcopy (&buf[index], &(op->data.mpi.datatype), sizeof(op->data.mpi.datatype));
index += sizeof(op->data.mpi.datatype);

bcopy (&buf[index], &(op->data.mpi.newtype), sizeof(op->data.mpi.newtype));
index += sizeof(op->data.mpi.newtype);

return index;
} /* umpi_unpack_op_MPI_Type_hvector */


int umpi_unpack_op_MPI_Type_indexed(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.count), sizeof(op->data.mpi.count));
index += sizeof(op->data.mpi.count);

bcopy (&buf[index], &(temp), sizeof(int));
index += sizeof(int);

if (temp) {
op->data.mpi.array_of_blocklens =
(int *) malloc (sizeof(op->data.mpi.array_of_blocklens[0])*temp);
assert (op->data.mpi.array_of_blocklens);
bcopy (&buf[index], op->data.mpi.array_of_blocklens, sizeof(op->data.mpi.array_of_blocklens[0])*temp);
index += (sizeof(op->data.mpi.array_of_blocklens[0])*temp);
} else {
op->data.mpi.array_of_blocklens = NULL;
}

bcopy (&buf[index], &(temp), sizeof(int));
index += sizeof(int);

if (temp) {
op->data.mpi.array_of_displacements =
(int *) malloc (sizeof(op->data.mpi.array_of_displacements[0])*temp);
assert (op->data.mpi.array_of_displacements);
bcopy (&buf[index], op->data.mpi.array_of_displacements, sizeof(op->data.mpi.array_of_displacements[0])*temp);
index += (sizeof(op->data.mpi.array_of_displacements[0])*temp);
} else {
op->data.mpi.array_of_displacements = NULL;
}

bcopy (&buf[index], &(op->data.mpi.datatype), sizeof(op->data.mpi.datatype));
index += sizeof(op->data.mpi.datatype);

bcopy (&buf[index], &(op->data.mpi.newtype), sizeof(op->data.mpi.newtype));
index += sizeof(op->data.mpi.newtype);

return index;
} /* umpi_unpack_op_MPI_Type_indexed */


int umpi_unpack_op_MPI_Type_lb(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.datatype), sizeof(op->data.mpi.datatype));
index += sizeof(op->data.mpi.datatype);

bcopy (&buf[index], &(op->data.mpi.displacement), sizeof(op->data.mpi.displacement));
index += sizeof(op->data.mpi.displacement);

return index;
} /* umpi_unpack_op_MPI_Type_lb */


int umpi_unpack_op_MPI_Type_size(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.datatype), sizeof(op->data.mpi.datatype));
index += sizeof(op->data.mpi.datatype);

bcopy (&buf[index], &(op->data.mpi.size), sizeof(op->data.mpi.size));
index += sizeof(op->data.mpi.size);

return index;
} /* umpi_unpack_op_MPI_Type_size */


int umpi_unpack_op_MPI_Type_struct(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.count), sizeof(op->data.mpi.count));
index += sizeof(op->data.mpi.count);

bcopy (&buf[index], &(temp), sizeof(int));
index += sizeof(int);

if (temp) {
op->data.mpi.array_of_blocklens =
(int *) malloc (sizeof(op->data.mpi.array_of_blocklens[0])*temp);
assert (op->data.mpi.array_of_blocklens);
bcopy (&buf[index], op->data.mpi.array_of_blocklens, sizeof(op->data.mpi.array_of_blocklens[0])*temp);
index += (sizeof(op->data.mpi.array_of_blocklens[0])*temp);
} else {
op->data.mpi.array_of_blocklens = NULL;
}

bcopy (&buf[index], &(temp), sizeof(int));
index += sizeof(int);

if (temp) {
op->data.mpi.array_of_displacements =
(int *) malloc (sizeof(op->data.mpi.array_of_displacements[0])*temp);
assert (op->data.mpi.array_of_displacements);
bcopy (&buf[index], op->data.mpi.array_of_displacements, sizeof(op->data.mpi.array_of_displacements[0])*temp);
index += (sizeof(op->data.mpi.array_of_displacements[0])*temp);
} else {
op->data.mpi.array_of_displacements = NULL;
}

bcopy (&buf[index], &(temp), sizeof(int));
index += sizeof(int);

if (temp) {
op->data.mpi.array_of_types =
(int *) malloc (sizeof(op->data.mpi.array_of_types[0])*temp);
assert (op->data.mpi.array_of_types);
bcopy (&buf[index], op->data.mpi.array_of_types, sizeof(op->data.mpi.array_of_types[0])*temp);
index += (sizeof(op->data.mpi.array_of_types[0])*temp);
} else {
op->data.mpi.array_of_types = NULL;
}

bcopy (&buf[index], &(op->data.mpi.newtype), sizeof(op->data.mpi.newtype));
index += sizeof(op->data.mpi.newtype);

return index;
} /* umpi_unpack_op_MPI_Type_struct */


int umpi_unpack_op_MPI_Type_ub(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.datatype), sizeof(op->data.mpi.datatype));
index += sizeof(op->data.mpi.datatype);

bcopy (&buf[index], &(op->data.mpi.displacement), sizeof(op->data.mpi.displacement));
index += sizeof(op->data.mpi.displacement);

return index;
} /* umpi_unpack_op_MPI_Type_ub */


int umpi_unpack_op_MPI_Type_vector(umpi_op_t*op,char *buf)
{
int temp, index = 0;

assert(op);
assert(buf);
bcopy (&buf[index], &(op->data.mpi.count), sizeof(op->data.mpi.count));
index += sizeof(op->data.mpi.count);

bcopy (&buf[index], &(op->data.mpi.blocklen), sizeof(op->data.mpi.blocklen));
index += sizeof(op->data.mpi.blocklen);

bcopy (&buf[index], &(op->data.mpi.stride), sizeof(op->data.mpi.stride));
index += sizeof(op->data.mpi.stride);

bcopy (&buf[index], &(op->data.mpi.datatype), sizeof(op->data.mpi.datatype));
index += sizeof(op->data.mpi.datatype);

bcopy (&buf[index], &(op->data.mpi.newtype), sizeof(op->data.mpi.newtype));
index += sizeof(op->data.mpi.newtype);

return index;
} /* um