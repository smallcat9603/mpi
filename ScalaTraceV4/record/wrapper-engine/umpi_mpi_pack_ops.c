/* !!!!! This file is automatically generated by a wrapper-engine !!!!! */


#include "umpi_internal.h"

int umpi_pack_op_MPI_Abort(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Abort(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.comm), &buf[index], sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

bcopy (&(op->data.mpi.errorcode), &buf[index], sizeof(op->data.mpi.errorcode));
index += sizeof(op->data.mpi.errorcode);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Abort */


int umpi_pack_op_size_MPI_Abort(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.comm)+sizeof(op->data.mpi.errorcode);
} /* umpi_pack_op_size_MPI_Abort */


int umpi_pack_op_MPI_Address(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Address(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.location), &buf[index], sizeof(op->data.mpi.location));
index += sizeof(op->data.mpi.location);

bcopy (&(op->data.mpi.address), &buf[index], sizeof(op->data.mpi.address));
index += sizeof(op->data.mpi.address);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Address */


int umpi_pack_op_size_MPI_Address(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.location)+sizeof(op->data.mpi.address);
} /* umpi_pack_op_size_MPI_Address */


int umpi_pack_op_MPI_Allgather(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Allgather(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.buf), &buf[index], sizeof(op->data.mpi.buf));
index += sizeof(op->data.mpi.buf);

bcopy (&(op->data.mpi.count), &buf[index], sizeof(op->data.mpi.count));
index += sizeof(op->data.mpi.count);

bcopy (&(op->data.mpi.datatype), &buf[index], sizeof(op->data.mpi.datatype));
index += sizeof(op->data.mpi.datatype);

bcopy (&(op->data.mpi.recvbuf), &buf[index], sizeof(op->data.mpi.recvbuf));
index += sizeof(op->data.mpi.recvbuf);

bcopy (&(op->data.mpi.recvcount), &buf[index], sizeof(op->data.mpi.recvcount));
index += sizeof(op->data.mpi.recvcount);

bcopy (&(op->data.mpi.recvtype), &buf[index], sizeof(op->data.mpi.recvtype));
index += sizeof(op->data.mpi.recvtype);

bcopy (&(op->data.mpi.comm), &buf[index], sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Allgather */


int umpi_pack_op_size_MPI_Allgather(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.buf)+sizeof(op->data.mpi.count)+sizeof(op->data.mpi.datatype)+sizeof(op->data.mpi.recvbuf)+sizeof(op->data.mpi.recvcount)+sizeof(op->data.mpi.recvtype)+sizeof(op->data.mpi.comm);
} /* umpi_pack_op_size_MPI_Allgather */


int umpi_pack_op_MPI_Allgatherv(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Allgatherv(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.buf), &buf[index], sizeof(op->data.mpi.buf));
index += sizeof(op->data.mpi.buf);

bcopy (&(op->data.mpi.count), &buf[index], sizeof(op->data.mpi.count));
index += sizeof(op->data.mpi.count);

bcopy (&(op->data.mpi.datatype), &buf[index], sizeof(op->data.mpi.datatype));
index += sizeof(op->data.mpi.datatype);

bcopy (&(op->data.mpi.recvbuf), &buf[index], sizeof(op->data.mpi.recvbuf));
index += sizeof(op->data.mpi.recvbuf);

temp = op->data.mpi.size;
bcopy (&(temp), &buf[index], sizeof(int));
index += sizeof(int);

if (temp) {
bcopy (op->data.mpi.recvcounts, &buf[index], sizeof(op->data.mpi.recvcounts[0])*temp);
index += (sizeof(op->data.mpi.recvcounts[0])*temp);
}

temp = op->data.mpi.size;
bcopy (&(temp), &buf[index], sizeof(int));
index += sizeof(int);

if (temp) {
bcopy (op->data.mpi.displs, &buf[index], sizeof(op->data.mpi.displs[0])*temp);
index += (sizeof(op->data.mpi.displs[0])*temp);
}

bcopy (&(op->data.mpi.recvtype), &buf[index], sizeof(op->data.mpi.recvtype));
index += sizeof(op->data.mpi.recvtype);

bcopy (&(op->data.mpi.comm), &buf[index], sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

bcopy (&(op->data.mpi.size), &buf[index], sizeof(op->data.mpi.size));
index += sizeof(op->data.mpi.size);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Allgatherv */


int umpi_pack_op_size_MPI_Allgatherv(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.buf)+sizeof(op->data.mpi.count)+sizeof(op->data.mpi.datatype)+sizeof(op->data.mpi.recvbuf)+sizeof(op->data.mpi.size)+(op->data.mpi.size*sizeof(op->data.mpi.recvcounts[0]))+sizeof(op->data.mpi.size)+(op->data.mpi.size*sizeof(op->data.mpi.displs[0]))+sizeof(op->data.mpi.recvtype)+sizeof(op->data.mpi.comm)+sizeof(op->data.mpi.size);
} /* umpi_pack_op_size_MPI_Allgatherv */


int umpi_pack_op_MPI_Allreduce(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Allreduce(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.buf), &buf[index], sizeof(op->data.mpi.buf));
index += sizeof(op->data.mpi.buf);

bcopy (&(op->data.mpi.recvbuf), &buf[index], sizeof(op->data.mpi.recvbuf));
index += sizeof(op->data.mpi.recvbuf);

bcopy (&(op->data.mpi.count), &buf[index], sizeof(op->data.mpi.count));
index += sizeof(op->data.mpi.count);

bcopy (&(op->data.mpi.datatype), &buf[index], sizeof(op->data.mpi.datatype));
index += sizeof(op->data.mpi.datatype);

bcopy (&(op->data.mpi.op), &buf[index], sizeof(op->data.mpi.op));
index += sizeof(op->data.mpi.op);

bcopy (&(op->data.mpi.comm), &buf[index], sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Allreduce */


int umpi_pack_op_size_MPI_Allreduce(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.buf)+sizeof(op->data.mpi.recvbuf)+sizeof(op->data.mpi.count)+sizeof(op->data.mpi.datatype)+sizeof(op->data.mpi.op)+sizeof(op->data.mpi.comm);
} /* umpi_pack_op_size_MPI_Allreduce */


int umpi_pack_op_MPI_Alltoall(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Alltoall(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.buf), &buf[index], sizeof(op->data.mpi.buf));
index += sizeof(op->data.mpi.buf);

bcopy (&(op->data.mpi.count), &buf[index], sizeof(op->data.mpi.count));
index += sizeof(op->data.mpi.count);

bcopy (&(op->data.mpi.datatype), &buf[index], sizeof(op->data.mpi.datatype));
index += sizeof(op->data.mpi.datatype);

bcopy (&(op->data.mpi.recvbuf), &buf[index], sizeof(op->data.mpi.recvbuf));
index += sizeof(op->data.mpi.recvbuf);

bcopy (&(op->data.mpi.recvcount), &buf[index], sizeof(op->data.mpi.recvcount));
index += sizeof(op->data.mpi.recvcount);

bcopy (&(op->data.mpi.recvtype), &buf[index], sizeof(op->data.mpi.recvtype));
index += sizeof(op->data.mpi.recvtype);

bcopy (&(op->data.mpi.comm), &buf[index], sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Alltoall */


int umpi_pack_op_size_MPI_Alltoall(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.buf)+sizeof(op->data.mpi.count)+sizeof(op->data.mpi.datatype)+sizeof(op->data.mpi.recvbuf)+sizeof(op->data.mpi.recvcount)+sizeof(op->data.mpi.recvtype)+sizeof(op->data.mpi.comm);
} /* umpi_pack_op_size_MPI_Alltoall */


int umpi_pack_op_MPI_Alltoallv(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Alltoallv(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.buf), &buf[index], sizeof(op->data.mpi.buf));
index += sizeof(op->data.mpi.buf);

temp = op->data.mpi.size;
bcopy (&(temp), &buf[index], sizeof(int));
index += sizeof(int);

if (temp) {
bcopy (op->data.mpi.counts, &buf[index], sizeof(op->data.mpi.counts[0])*temp);
index += (sizeof(op->data.mpi.counts[0])*temp);
}

temp = op->data.mpi.size;
bcopy (&(temp), &buf[index], sizeof(int));
index += sizeof(int);

if (temp) {
bcopy (op->data.mpi.sdispls, &buf[index], sizeof(op->data.mpi.sdispls[0])*temp);
index += (sizeof(op->data.mpi.sdispls[0])*temp);
}

bcopy (&(op->data.mpi.datatype), &buf[index], sizeof(op->data.mpi.datatype));
index += sizeof(op->data.mpi.datatype);

bcopy (&(op->data.mpi.recvbuf), &buf[index], sizeof(op->data.mpi.recvbuf));
index += sizeof(op->data.mpi.recvbuf);

temp = op->data.mpi.size;
bcopy (&(temp), &buf[index], sizeof(int));
index += sizeof(int);

if (temp) {
bcopy (op->data.mpi.recvcounts, &buf[index], sizeof(op->data.mpi.recvcounts[0])*temp);
index += (sizeof(op->data.mpi.recvcounts[0])*temp);
}

temp = op->data.mpi.size;
bcopy (&(temp), &buf[index], sizeof(int));
index += sizeof(int);

if (temp) {
bcopy (op->data.mpi.rdispls, &buf[index], sizeof(op->data.mpi.rdispls[0])*temp);
index += (sizeof(op->data.mpi.rdispls[0])*temp);
}

bcopy (&(op->data.mpi.recvtype), &buf[index], sizeof(op->data.mpi.recvtype));
index += sizeof(op->data.mpi.recvtype);

bcopy (&(op->data.mpi.comm), &buf[index], sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

bcopy (&(op->data.mpi.size), &buf[index], sizeof(op->data.mpi.size));
index += sizeof(op->data.mpi.size);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Alltoallv */


int umpi_pack_op_size_MPI_Alltoallv(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.buf)+sizeof(op->data.mpi.size)+(op->data.mpi.size*sizeof(op->data.mpi.counts[0]))+sizeof(op->data.mpi.size)+(op->data.mpi.size*sizeof(op->data.mpi.sdispls[0]))+sizeof(op->data.mpi.datatype)+sizeof(op->data.mpi.recvbuf)+sizeof(op->data.mpi.size)+(op->data.mpi.size*sizeof(op->data.mpi.recvcounts[0]))+sizeof(op->data.mpi.size)+(op->data.mpi.size*sizeof(op->data.mpi.rdispls[0]))+sizeof(op->data.mpi.recvtype)+sizeof(op->data.mpi.comm)+sizeof(op->data.mpi.size);
} /* umpi_pack_op_size_MPI_Alltoallv */


int umpi_pack_op_MPI_Attr_delete(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Attr_delete(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.comm), &buf[index], sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

bcopy (&(op->data.mpi.keyval), &buf[index], sizeof(op->data.mpi.keyval));
index += sizeof(op->data.mpi.keyval);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Attr_delete */


int umpi_pack_op_size_MPI_Attr_delete(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.comm)+sizeof(op->data.mpi.keyval);
} /* umpi_pack_op_size_MPI_Attr_delete */


int umpi_pack_op_MPI_Attr_get(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Attr_get(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.comm), &buf[index], sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

bcopy (&(op->data.mpi.keyval), &buf[index], sizeof(op->data.mpi.keyval));
index += sizeof(op->data.mpi.keyval);

bcopy (&(op->data.mpi.attr_value), &buf[index], sizeof(op->data.mpi.attr_value));
index += sizeof(op->data.mpi.attr_value);

bcopy (&(op->data.mpi.flag), &buf[index], sizeof(op->data.mpi.flag));
index += sizeof(op->data.mpi.flag);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Attr_get */


int umpi_pack_op_size_MPI_Attr_get(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.comm)+sizeof(op->data.mpi.keyval)+sizeof(op->data.mpi.attr_value)+sizeof(op->data.mpi.flag);
} /* umpi_pack_op_size_MPI_Attr_get */


int umpi_pack_op_MPI_Attr_put(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Attr_put(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.comm), &buf[index], sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

bcopy (&(op->data.mpi.keyval), &buf[index], sizeof(op->data.mpi.keyval));
index += sizeof(op->data.mpi.keyval);

bcopy (&(op->data.mpi.attr_value), &buf[index], sizeof(op->data.mpi.attr_value));
index += sizeof(op->data.mpi.attr_value);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Attr_put */


int umpi_pack_op_size_MPI_Attr_put(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.comm)+sizeof(op->data.mpi.keyval)+sizeof(op->data.mpi.attr_value);
} /* umpi_pack_op_size_MPI_Attr_put */


int umpi_pack_op_MPI_Barrier(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Barrier(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.comm), &buf[index], sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Barrier */


int umpi_pack_op_size_MPI_Barrier(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.comm);
} /* umpi_pack_op_size_MPI_Barrier */


int umpi_pack_op_MPI_Bcast(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Bcast(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.buf), &buf[index], sizeof(op->data.mpi.buf));
index += sizeof(op->data.mpi.buf);

bcopy (&(op->data.mpi.count), &buf[index], sizeof(op->data.mpi.count));
index += sizeof(op->data.mpi.count);

bcopy (&(op->data.mpi.datatype), &buf[index], sizeof(op->data.mpi.datatype));
index += sizeof(op->data.mpi.datatype);

bcopy (&(op->data.mpi.root), &buf[index], sizeof(op->data.mpi.root));
index += sizeof(op->data.mpi.root);

bcopy (&(op->data.mpi.comm), &buf[index], sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Bcast */


int umpi_pack_op_size_MPI_Bcast(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.buf)+sizeof(op->data.mpi.count)+sizeof(op->data.mpi.datatype)+sizeof(op->data.mpi.root)+sizeof(op->data.mpi.comm);
} /* umpi_pack_op_size_MPI_Bcast */


int umpi_pack_op_MPI_Bsend(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Bsend(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.buf), &buf[index], sizeof(op->data.mpi.buf));
index += sizeof(op->data.mpi.buf);

bcopy (&(op->data.mpi.count), &buf[index], sizeof(op->data.mpi.count));
index += sizeof(op->data.mpi.count);

bcopy (&(op->data.mpi.datatype), &buf[index], sizeof(op->data.mpi.datatype));
index += sizeof(op->data.mpi.datatype);

bcopy (&(op->data.mpi.dest), &buf[index], sizeof(op->data.mpi.dest));
index += sizeof(op->data.mpi.dest);

bcopy (&(op->data.mpi.tag), &buf[index], sizeof(op->data.mpi.tag));
index += sizeof(op->data.mpi.tag);

bcopy (&(op->data.mpi.comm), &buf[index], sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Bsend */


int umpi_pack_op_size_MPI_Bsend(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.buf)+sizeof(op->data.mpi.count)+sizeof(op->data.mpi.datatype)+sizeof(op->data.mpi.dest)+sizeof(op->data.mpi.tag)+sizeof(op->data.mpi.comm);
} /* umpi_pack_op_size_MPI_Bsend */


int umpi_pack_op_MPI_Bsend_init(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Bsend_init(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.buf), &buf[index], sizeof(op->data.mpi.buf));
index += sizeof(op->data.mpi.buf);

bcopy (&(op->data.mpi.count), &buf[index], sizeof(op->data.mpi.count));
index += sizeof(op->data.mpi.count);

bcopy (&(op->data.mpi.datatype), &buf[index], sizeof(op->data.mpi.datatype));
index += sizeof(op->data.mpi.datatype);

bcopy (&(op->data.mpi.dest), &buf[index], sizeof(op->data.mpi.dest));
index += sizeof(op->data.mpi.dest);

bcopy (&(op->data.mpi.tag), &buf[index], sizeof(op->data.mpi.tag));
index += sizeof(op->data.mpi.tag);

bcopy (&(op->data.mpi.comm), &buf[index], sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

bcopy (&(op->data.mpi.request), &buf[index], sizeof(op->data.mpi.request));
index += sizeof(op->data.mpi.request);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Bsend_init */


int umpi_pack_op_size_MPI_Bsend_init(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.buf)+sizeof(op->data.mpi.count)+sizeof(op->data.mpi.datatype)+sizeof(op->data.mpi.dest)+sizeof(op->data.mpi.tag)+sizeof(op->data.mpi.comm)+sizeof(op->data.mpi.request);
} /* umpi_pack_op_size_MPI_Bsend_init */


int umpi_pack_op_MPI_Buffer_attach(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Buffer_attach(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.buf), &buf[index], sizeof(op->data.mpi.buf));
index += sizeof(op->data.mpi.buf);

bcopy (&(op->data.mpi.size), &buf[index], sizeof(op->data.mpi.size));
index += sizeof(op->data.mpi.size);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Buffer_attach */


int umpi_pack_op_size_MPI_Buffer_attach(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.buf)+sizeof(op->data.mpi.size);
} /* umpi_pack_op_size_MPI_Buffer_attach */


int umpi_pack_op_MPI_Buffer_detach(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Buffer_detach(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.bufptr), &buf[index], sizeof(op->data.mpi.bufptr));
index += sizeof(op->data.mpi.bufptr);

bcopy (&(op->data.mpi.size), &buf[index], sizeof(op->data.mpi.size));
index += sizeof(op->data.mpi.size);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Buffer_detach */


int umpi_pack_op_size_MPI_Buffer_detach(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.bufptr)+sizeof(op->data.mpi.size);
} /* umpi_pack_op_size_MPI_Buffer_detach */


int umpi_pack_op_MPI_Cancel(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Cancel(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.request), &buf[index], sizeof(op->data.mpi.request));
index += sizeof(op->data.mpi.request);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Cancel */


int umpi_pack_op_size_MPI_Cancel(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.request);
} /* umpi_pack_op_size_MPI_Cancel */


int umpi_pack_op_MPI_Cart_coords(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Cart_coords(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.comm), &buf[index], sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

bcopy (&(op->data.mpi.rank), &buf[index], sizeof(op->data.mpi.rank));
index += sizeof(op->data.mpi.rank);

bcopy (&(op->data.mpi.count), &buf[index], sizeof(op->data.mpi.count));
index += sizeof(op->data.mpi.count);

temp = op->data.mpi.count;
bcopy (&(temp), &buf[index], sizeof(int));
index += sizeof(int);

if (temp) {
bcopy (op->data.mpi.array_of_coords, &buf[index], sizeof(op->data.mpi.array_of_coords[0])*temp);
index += (sizeof(op->data.mpi.array_of_coords[0])*temp);
}

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Cart_coords */


int umpi_pack_op_size_MPI_Cart_coords(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.comm)+sizeof(op->data.mpi.rank)+sizeof(op->data.mpi.count)+sizeof(op->data.mpi.count)+(op->data.mpi.count*sizeof(op->data.mpi.array_of_coords[0]));
} /* umpi_pack_op_size_MPI_Cart_coords */


int umpi_pack_op_MPI_Cart_create(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Cart_create(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.comm), &buf[index], sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

bcopy (&(op->data.mpi.count), &buf[index], sizeof(op->data.mpi.count));
index += sizeof(op->data.mpi.count);

temp = op->data.mpi.count;
bcopy (&(temp), &buf[index], sizeof(int));
index += sizeof(int);

if (temp) {
bcopy (op->data.mpi.array_of_dims, &buf[index], sizeof(op->data.mpi.array_of_dims[0])*temp);
index += (sizeof(op->data.mpi.array_of_dims[0])*temp);
}

temp = op->data.mpi.count;
bcopy (&(temp), &buf[index], sizeof(int));
index += sizeof(int);

if (temp) {
bcopy (op->data.mpi.array_of_periods, &buf[index], sizeof(op->data.mpi.array_of_periods[0])*temp);
index += (sizeof(op->data.mpi.array_of_periods[0])*temp);
}

bcopy (&(op->data.mpi.reorder), &buf[index], sizeof(op->data.mpi.reorder));
index += sizeof(op->data.mpi.reorder);

bcopy (&(op->data.mpi.comm_out), &buf[index], sizeof(op->data.mpi.comm_out));
index += sizeof(op->data.mpi.comm_out);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Cart_create */


int umpi_pack_op_size_MPI_Cart_create(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.comm)+sizeof(op->data.mpi.count)+sizeof(op->data.mpi.count)+(op->data.mpi.count*sizeof(op->data.mpi.array_of_dims[0]))+sizeof(op->data.mpi.count)+(op->data.mpi.count*sizeof(op->data.mpi.array_of_periods[0]))+sizeof(op->data.mpi.reorder)+sizeof(op->data.mpi.comm_out);
} /* umpi_pack_op_size_MPI_Cart_create */


int umpi_pack_op_MPI_Cart_get(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Cart_get(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.comm), &buf[index], sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

bcopy (&(op->data.mpi.count), &buf[index], sizeof(op->data.mpi.count));
index += sizeof(op->data.mpi.count);

temp = op->data.mpi.count;
bcopy (&(temp), &buf[index], sizeof(int));
index += sizeof(int);

if (temp) {
bcopy (op->data.mpi.array_of_dims, &buf[index], sizeof(op->data.mpi.array_of_dims[0])*temp);
index += (sizeof(op->data.mpi.array_of_dims[0])*temp);
}

temp = op->data.mpi.count;
bcopy (&(temp), &buf[index], sizeof(int));
index += sizeof(int);

if (temp) {
bcopy (op->data.mpi.array_of_periods, &buf[index], sizeof(op->data.mpi.array_of_periods[0])*temp);
index += (sizeof(op->data.mpi.array_of_periods[0])*temp);
}

temp = op->data.mpi.count;
bcopy (&(temp), &buf[index], sizeof(int));
index += sizeof(int);

if (temp) {
bcopy (op->data.mpi.array_of_coords, &buf[index], sizeof(op->data.mpi.array_of_coords[0])*temp);
index += (sizeof(op->data.mpi.array_of_coords[0])*temp);
}

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Cart_get */


int umpi_pack_op_size_MPI_Cart_get(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.comm)+sizeof(op->data.mpi.count)+sizeof(op->data.mpi.count)+(op->data.mpi.count*sizeof(op->data.mpi.array_of_dims[0]))+sizeof(op->data.mpi.count)+(op->data.mpi.count*sizeof(op->data.mpi.array_of_periods[0]))+sizeof(op->data.mpi.count)+(op->data.mpi.count*sizeof(op->data.mpi.array_of_coords[0]));
} /* umpi_pack_op_size_MPI_Cart_get */


int umpi_pack_op_MPI_Cart_map(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Cart_map(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.comm), &buf[index], sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

bcopy (&(op->data.mpi.count), &buf[index], sizeof(op->data.mpi.count));
index += sizeof(op->data.mpi.count);

temp = op->data.mpi.count;
bcopy (&(temp), &buf[index], sizeof(int));
index += sizeof(int);

if (temp) {
bcopy (op->data.mpi.array_of_dims, &buf[index], sizeof(op->data.mpi.array_of_dims[0])*temp);
index += (sizeof(op->data.mpi.array_of_dims[0])*temp);
}

temp = op->data.mpi.count;
bcopy (&(temp), &buf[index], sizeof(int));
index += sizeof(int);

if (temp) {
bcopy (op->data.mpi.array_of_periods, &buf[index], sizeof(op->data.mpi.array_of_periods[0])*temp);
index += (sizeof(op->data.mpi.array_of_periods[0])*temp);
}

bcopy (&(op->data.mpi.newrank), &buf[index], sizeof(op->data.mpi.newrank));
index += sizeof(op->data.mpi.newrank);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Cart_map */


int umpi_pack_op_size_MPI_Cart_map(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.comm)+sizeof(op->data.mpi.count)+sizeof(op->data.mpi.count)+(op->data.mpi.count*sizeof(op->data.mpi.array_of_dims[0]))+sizeof(op->data.mpi.count)+(op->data.mpi.count*sizeof(op->data.mpi.array_of_periods[0]))+sizeof(op->data.mpi.newrank);
} /* umpi_pack_op_size_MPI_Cart_map */


int umpi_pack_op_MPI_Cart_rank(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Cart_rank(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.comm), &buf[index], sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

temp = op->data.mpi.size;
bcopy (&(temp), &buf[index], sizeof(int));
index += sizeof(int);

if (temp) {
bcopy (op->data.mpi.retcoords, &buf[index], sizeof(op->data.mpi.retcoords[0])*temp);
index += (sizeof(op->data.mpi.retcoords[0])*temp);
}

bcopy (&(op->data.mpi.rank), &buf[index], sizeof(op->data.mpi.rank));
index += sizeof(op->data.mpi.rank);

bcopy (&(op->data.mpi.size), &buf[index], sizeof(op->data.mpi.size));
index += sizeof(op->data.mpi.size);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Cart_rank */


int umpi_pack_op_size_MPI_Cart_rank(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.comm)+sizeof(op->data.mpi.size)+(op->data.mpi.size*sizeof(op->data.mpi.retcoords[0]))+sizeof(op->data.mpi.rank)+sizeof(op->data.mpi.size);
} /* umpi_pack_op_size_MPI_Cart_rank */


int umpi_pack_op_MPI_Cart_shift(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Cart_shift(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.comm), &buf[index], sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

bcopy (&(op->data.mpi.direction), &buf[index], sizeof(op->data.mpi.direction));
index += sizeof(op->data.mpi.direction);

bcopy (&(op->data.mpi.displ), &buf[index], sizeof(op->data.mpi.displ));
index += sizeof(op->data.mpi.displ);

bcopy (&(op->data.mpi.cart_src), &buf[index], sizeof(op->data.mpi.cart_src));
index += sizeof(op->data.mpi.cart_src);

bcopy (&(op->data.mpi.cart_dest), &buf[index], sizeof(op->data.mpi.cart_dest));
index += sizeof(op->data.mpi.cart_dest);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Cart_shift */


int umpi_pack_op_size_MPI_Cart_shift(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.comm)+sizeof(op->data.mpi.direction)+sizeof(op->data.mpi.displ)+sizeof(op->data.mpi.cart_src)+sizeof(op->data.mpi.cart_dest);
} /* umpi_pack_op_size_MPI_Cart_shift */


int umpi_pack_op_MPI_Cart_sub(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Cart_sub(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.comm), &buf[index], sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

temp = op->data.mpi.size;
bcopy (&(temp), &buf[index], sizeof(int));
index += sizeof(int);

if (temp) {
bcopy (op->data.mpi.dimsp, &buf[index], sizeof(op->data.mpi.dimsp[0])*temp);
index += (sizeof(op->data.mpi.dimsp[0])*temp);
}

bcopy (&(op->data.mpi.comm_out), &buf[index], sizeof(op->data.mpi.comm_out));
index += sizeof(op->data.mpi.comm_out);

bcopy (&(op->data.mpi.size), &buf[index], sizeof(op->data.mpi.size));
index += sizeof(op->data.mpi.size);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Cart_sub */


int umpi_pack_op_size_MPI_Cart_sub(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.comm)+sizeof(op->data.mpi.size)+(op->data.mpi.size*sizeof(op->data.mpi.dimsp[0]))+sizeof(op->data.mpi.comm_out)+sizeof(op->data.mpi.size);
} /* umpi_pack_op_size_MPI_Cart_sub */


int umpi_pack_op_MPI_Cartdim_get(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Cartdim_get(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.comm), &buf[index], sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

bcopy (&(op->data.mpi.ndims_p), &buf[index], sizeof(op->data.mpi.ndims_p));
index += sizeof(op->data.mpi.ndims_p);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Cartdim_get */


int umpi_pack_op_size_MPI_Cartdim_get(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.comm)+sizeof(op->data.mpi.ndims_p);
} /* umpi_pack_op_size_MPI_Cartdim_get */


int umpi_pack_op_MPI_Comm_compare(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Comm_compare(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.comm1), &buf[index], sizeof(op->data.mpi.comm1));
index += sizeof(op->data.mpi.comm1);

bcopy (&(op->data.mpi.comm2), &buf[index], sizeof(op->data.mpi.comm2));
index += sizeof(op->data.mpi.comm2);

bcopy (&(op->data.mpi.result), &buf[index], sizeof(op->data.mpi.result));
index += sizeof(op->data.mpi.result);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Comm_compare */


int umpi_pack_op_size_MPI_Comm_compare(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.comm1)+sizeof(op->data.mpi.comm2)+sizeof(op->data.mpi.result);
} /* umpi_pack_op_size_MPI_Comm_compare */


int umpi_pack_op_MPI_Comm_create(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Comm_create(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.comm), &buf[index], sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

bcopy (&(op->data.mpi.group), &buf[index], sizeof(op->data.mpi.group));
index += sizeof(op->data.mpi.group);

bcopy (&(op->data.mpi.comm_out), &buf[index], sizeof(op->data.mpi.comm_out));
index += sizeof(op->data.mpi.comm_out);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Comm_create */


int umpi_pack_op_size_MPI_Comm_create(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.comm)+sizeof(op->data.mpi.group)+sizeof(op->data.mpi.comm_out);
} /* umpi_pack_op_size_MPI_Comm_create */


int umpi_pack_op_MPI_Comm_dup(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Comm_dup(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.comm), &buf[index], sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

bcopy (&(op->data.mpi.comm_out), &buf[index], sizeof(op->data.mpi.comm_out));
index += sizeof(op->data.mpi.comm_out);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Comm_dup */


int umpi_pack_op_size_MPI_Comm_dup(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.comm)+sizeof(op->data.mpi.comm_out);
} /* umpi_pack_op_size_MPI_Comm_dup */


int umpi_pack_op_MPI_Comm_free(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Comm_free(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.commp), &buf[index], sizeof(op->data.mpi.commp));
index += sizeof(op->data.mpi.commp);

bcopy (&(op->data.mpi.comm), &buf[index], sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Comm_free */


int umpi_pack_op_size_MPI_Comm_free(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.commp)+sizeof(op->data.mpi.comm);
} /* umpi_pack_op_size_MPI_Comm_free */


int umpi_pack_op_MPI_Comm_get_name(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Comm_get_name(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.comm), &buf[index], sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

bcopy (&(op->data.mpi.namep), &buf[index], sizeof(op->data.mpi.namep));
index += sizeof(op->data.mpi.namep);

bcopy (&(op->data.mpi.reslen), &buf[index], sizeof(op->data.mpi.reslen));
index += sizeof(op->data.mpi.reslen);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Comm_get_name */


int umpi_pack_op_size_MPI_Comm_get_name(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.comm)+sizeof(op->data.mpi.namep)+sizeof(op->data.mpi.reslen);
} /* umpi_pack_op_size_MPI_Comm_get_name */


int umpi_pack_op_MPI_Comm_group(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Comm_group(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.comm), &buf[index], sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

bcopy (&(op->data.mpi.group_out), &buf[index], sizeof(op->data.mpi.group_out));
index += sizeof(op->data.mpi.group_out);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Comm_group */


int umpi_pack_op_size_MPI_Comm_group(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.comm)+sizeof(op->data.mpi.group_out);
} /* umpi_pack_op_size_MPI_Comm_group */


int umpi_pack_op_MPI_Comm_rank(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Comm_rank(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.comm), &buf[index], sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

bcopy (&(op->data.mpi.rank), &buf[index], sizeof(op->data.mpi.rank));
index += sizeof(op->data.mpi.rank);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Comm_rank */


int umpi_pack_op_size_MPI_Comm_rank(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.comm)+sizeof(op->data.mpi.rank);
} /* umpi_pack_op_size_MPI_Comm_rank */


int umpi_pack_op_MPI_Comm_remote_group(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Comm_remote_group(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.comm), &buf[index], sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

bcopy (&(op->data.mpi.group_out), &buf[index], sizeof(op->data.mpi.group_out));
index += sizeof(op->data.mpi.group_out);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Comm_remote_group */


int umpi_pack_op_size_MPI_Comm_remote_group(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.comm)+sizeof(op->data.mpi.group_out);
} /* umpi_pack_op_size_MPI_Comm_remote_group */


int umpi_pack_op_MPI_Comm_remote_size(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Comm_remote_size(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.comm), &buf[index], sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

bcopy (&(op->data.mpi.size), &buf[index], sizeof(op->data.mpi.size));
index += sizeof(op->data.mpi.size);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Comm_remote_size */


int umpi_pack_op_size_MPI_Comm_remote_size(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.comm)+sizeof(op->data.mpi.size);
} /* umpi_pack_op_size_MPI_Comm_remote_size */


int umpi_pack_op_MPI_Comm_set_name(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Comm_set_name(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.comm), &buf[index], sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

bcopy (&(op->data.mpi.name), &buf[index], sizeof(op->data.mpi.name));
index += sizeof(op->data.mpi.name);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Comm_set_name */


int umpi_pack_op_size_MPI_Comm_set_name(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.comm)+sizeof(op->data.mpi.name);
} /* umpi_pack_op_size_MPI_Comm_set_name */


int umpi_pack_op_MPI_Comm_size(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Comm_size(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.comm), &buf[index], sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

bcopy (&(op->data.mpi.size), &buf[index], sizeof(op->data.mpi.size));
index += sizeof(op->data.mpi.size);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Comm_size */


int umpi_pack_op_size_MPI_Comm_size(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.comm)+sizeof(op->data.mpi.size);
} /* umpi_pack_op_size_MPI_Comm_size */


int umpi_pack_op_MPI_Comm_split(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Comm_split(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.comm), &buf[index], sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

bcopy (&(op->data.mpi.color), &buf[index], sizeof(op->data.mpi.color));
index += sizeof(op->data.mpi.color);

bcopy (&(op->data.mpi.key), &buf[index], sizeof(op->data.mpi.key));
index += sizeof(op->data.mpi.key);

bcopy (&(op->data.mpi.comm_out), &buf[index], sizeof(op->data.mpi.comm_out));
index += sizeof(op->data.mpi.comm_out);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Comm_split */


int umpi_pack_op_size_MPI_Comm_split(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.comm)+sizeof(op->data.mpi.color)+sizeof(op->data.mpi.key)+sizeof(op->data.mpi.comm_out);
} /* umpi_pack_op_size_MPI_Comm_split */


int umpi_pack_op_MPI_Comm_test_inter(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Comm_test_inter(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.comm), &buf[index], sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

bcopy (&(op->data.mpi.flag), &buf[index], sizeof(op->data.mpi.flag));
index += sizeof(op->data.mpi.flag);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Comm_test_inter */


int umpi_pack_op_size_MPI_Comm_test_inter(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.comm)+sizeof(op->data.mpi.flag);
} /* umpi_pack_op_size_MPI_Comm_test_inter */


int umpi_pack_op_MPI_Dims_create(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Dims_create(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.nnodes), &buf[index], sizeof(op->data.mpi.nnodes));
index += sizeof(op->data.mpi.nnodes);

bcopy (&(op->data.mpi.count), &buf[index], sizeof(op->data.mpi.count));
index += sizeof(op->data.mpi.count);

temp = op->data.mpi.count;
bcopy (&(temp), &buf[index], sizeof(int));
index += sizeof(int);

if (temp) {
bcopy (op->data.mpi.array_of_dims, &buf[index], sizeof(op->data.mpi.array_of_dims[0])*temp);
index += (sizeof(op->data.mpi.array_of_dims[0])*temp);
}

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Dims_create */


int umpi_pack_op_size_MPI_Dims_create(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.nnodes)+sizeof(op->data.mpi.count)+sizeof(op->data.mpi.count)+(op->data.mpi.count*sizeof(op->data.mpi.array_of_dims[0]));
} /* umpi_pack_op_size_MPI_Dims_create */


int umpi_pack_op_MPI_Errhandler_create(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Errhandler_create(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.function), &buf[index], sizeof(op->data.mpi.function));
index += sizeof(op->data.mpi.function);

bcopy (&(op->data.mpi.errhandler), &buf[index], sizeof(op->data.mpi.errhandler));
index += sizeof(op->data.mpi.errhandler);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Errhandler_create */


int umpi_pack_op_size_MPI_Errhandler_create(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.function)+sizeof(op->data.mpi.errhandler);
} /* umpi_pack_op_size_MPI_Errhandler_create */


int umpi_pack_op_MPI_Errhandler_free(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Errhandler_free(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.errhandler), &buf[index], sizeof(op->data.mpi.errhandler));
index += sizeof(op->data.mpi.errhandler);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Errhandler_free */


int umpi_pack_op_size_MPI_Errhandler_free(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.errhandler);
} /* umpi_pack_op_size_MPI_Errhandler_free */


int umpi_pack_op_MPI_Errhandler_get(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Errhandler_get(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.comm), &buf[index], sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

bcopy (&(op->data.mpi.errhandler), &buf[index], sizeof(op->data.mpi.errhandler));
index += sizeof(op->data.mpi.errhandler);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Errhandler_get */


int umpi_pack_op_size_MPI_Errhandler_get(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.comm)+sizeof(op->data.mpi.errhandler);
} /* umpi_pack_op_size_MPI_Errhandler_get */


int umpi_pack_op_MPI_Errhandler_set(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Errhandler_set(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.comm), &buf[index], sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

bcopy (&(op->data.mpi.errhandler_notptr), &buf[index], sizeof(op->data.mpi.errhandler_notptr));
index += sizeof(op->data.mpi.errhandler_notptr);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Errhandler_set */


int umpi_pack_op_size_MPI_Errhandler_set(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.comm)+sizeof(op->data.mpi.errhandler_notptr);
} /* umpi_pack_op_size_MPI_Errhandler_set */


int umpi_pack_op_MPI_Error_class(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Error_class(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.errorcode), &buf[index], sizeof(op->data.mpi.errorcode));
index += sizeof(op->data.mpi.errorcode);

bcopy (&(op->data.mpi.errorclass), &buf[index], sizeof(op->data.mpi.errorclass));
index += sizeof(op->data.mpi.errorclass);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Error_class */


int umpi_pack_op_size_MPI_Error_class(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.errorcode)+sizeof(op->data.mpi.errorclass);
} /* umpi_pack_op_size_MPI_Error_class */


int umpi_pack_op_MPI_Error_string(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Error_string(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.errorcode), &buf[index], sizeof(op->data.mpi.errorcode));
index += sizeof(op->data.mpi.errorcode);

bcopy (&(op->data.mpi.string), &buf[index], sizeof(op->data.mpi.string));
index += sizeof(op->data.mpi.string);

bcopy (&(op->data.mpi.reslen), &buf[index], sizeof(op->data.mpi.reslen));
index += sizeof(op->data.mpi.reslen);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Error_string */


int umpi_pack_op_size_MPI_Error_string(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.errorcode)+sizeof(op->data.mpi.string)+sizeof(op->data.mpi.reslen);
} /* umpi_pack_op_size_MPI_Error_string */


int umpi_pack_op_MPI_Finalize(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Finalize(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Finalize */


int umpi_pack_op_size_MPI_Finalize(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num);
} /* umpi_pack_op_size_MPI_Finalize */


int umpi_pack_op_MPI_Finalized(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Finalized(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.flag), &buf[index], sizeof(op->data.mpi.flag));
index += sizeof(op->data.mpi.flag);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Finalized */


int umpi_pack_op_size_MPI_Finalized(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.flag);
} /* umpi_pack_op_size_MPI_Finalized */


int umpi_pack_op_MPI_Gather(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Gather(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.buf), &buf[index], sizeof(op->data.mpi.buf));
index += sizeof(op->data.mpi.buf);

bcopy (&(op->data.mpi.count), &buf[index], sizeof(op->data.mpi.count));
index += sizeof(op->data.mpi.count);

bcopy (&(op->data.mpi.datatype), &buf[index], sizeof(op->data.mpi.datatype));
index += sizeof(op->data.mpi.datatype);

bcopy (&(op->data.mpi.recvbuf), &buf[index], sizeof(op->data.mpi.recvbuf));
index += sizeof(op->data.mpi.recvbuf);

bcopy (&(op->data.mpi.recvcount), &buf[index], sizeof(op->data.mpi.recvcount));
index += sizeof(op->data.mpi.recvcount);

bcopy (&(op->data.mpi.recvtype), &buf[index], sizeof(op->data.mpi.recvtype));
index += sizeof(op->data.mpi.recvtype);

bcopy (&(op->data.mpi.root), &buf[index], sizeof(op->data.mpi.root));
index += sizeof(op->data.mpi.root);

bcopy (&(op->data.mpi.comm), &buf[index], sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Gather */


int umpi_pack_op_size_MPI_Gather(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.buf)+sizeof(op->data.mpi.count)+sizeof(op->data.mpi.datatype)+sizeof(op->data.mpi.recvbuf)+sizeof(op->data.mpi.recvcount)+sizeof(op->data.mpi.recvtype)+sizeof(op->data.mpi.root)+sizeof(op->data.mpi.comm);
} /* umpi_pack_op_size_MPI_Gather */


int umpi_pack_op_MPI_Gatherv(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Gatherv(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.buf), &buf[index], sizeof(op->data.mpi.buf));
index += sizeof(op->data.mpi.buf);

bcopy (&(op->data.mpi.count), &buf[index], sizeof(op->data.mpi.count));
index += sizeof(op->data.mpi.count);

bcopy (&(op->data.mpi.datatype), &buf[index], sizeof(op->data.mpi.datatype));
index += sizeof(op->data.mpi.datatype);

bcopy (&(op->data.mpi.recvbuf), &buf[index], sizeof(op->data.mpi.recvbuf));
index += sizeof(op->data.mpi.recvbuf);

temp = op->data.mpi.size;
bcopy (&(temp), &buf[index], sizeof(int));
index += sizeof(int);

if (temp) {
bcopy (op->data.mpi.recvcounts, &buf[index], sizeof(op->data.mpi.recvcounts[0])*temp);
index += (sizeof(op->data.mpi.recvcounts[0])*temp);
}

temp = op->data.mpi.size;
bcopy (&(temp), &buf[index], sizeof(int));
index += sizeof(int);

if (temp) {
bcopy (op->data.mpi.displs, &buf[index], sizeof(op->data.mpi.displs[0])*temp);
index += (sizeof(op->data.mpi.displs[0])*temp);
}

bcopy (&(op->data.mpi.recvtype), &buf[index], sizeof(op->data.mpi.recvtype));
index += sizeof(op->data.mpi.recvtype);

bcopy (&(op->data.mpi.root), &buf[index], sizeof(op->data.mpi.root));
index += sizeof(op->data.mpi.root);

bcopy (&(op->data.mpi.comm), &buf[index], sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

bcopy (&(op->data.mpi.size), &buf[index], sizeof(op->data.mpi.size));
index += sizeof(op->data.mpi.size);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Gatherv */


int umpi_pack_op_size_MPI_Gatherv(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.buf)+sizeof(op->data.mpi.count)+sizeof(op->data.mpi.datatype)+sizeof(op->data.mpi.recvbuf)+sizeof(op->data.mpi.size)+(op->data.mpi.size*sizeof(op->data.mpi.recvcounts[0]))+sizeof(op->data.mpi.size)+(op->data.mpi.size*sizeof(op->data.mpi.displs[0]))+sizeof(op->data.mpi.recvtype)+sizeof(op->data.mpi.root)+sizeof(op->data.mpi.comm)+sizeof(op->data.mpi.size);
} /* umpi_pack_op_size_MPI_Gatherv */


int umpi_pack_op_MPI_Get_count(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Get_count(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.status_src), &buf[index], sizeof(op->data.mpi.status_src));
index += sizeof(op->data.mpi.status_src);

bcopy (&(op->data.mpi.datatype), &buf[index], sizeof(op->data.mpi.datatype));
index += sizeof(op->data.mpi.datatype);

bcopy (&(op->data.mpi.countp), &buf[index], sizeof(op->data.mpi.countp));
index += sizeof(op->data.mpi.countp);

bcopy (&(op->data.mpi.status_src), &buf[index], sizeof(op->data.mpi.status_src));
index += sizeof(op->data.mpi.status_src);

bcopy (&(op->data.mpi.statuses_srcs), &buf[index], sizeof(op->data.mpi.statuses_srcs));
index += sizeof(op->data.mpi.statuses_srcs);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Get_count */


int umpi_pack_op_size_MPI_Get_count(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.status_src)+sizeof(op->data.mpi.datatype)+sizeof(op->data.mpi.countp)+sizeof(op->data.mpi.status_src)+sizeof(op->data.mpi.statuses_srcs);
} /* umpi_pack_op_size_MPI_Get_count */


int umpi_pack_op_MPI_Get_elements(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Get_elements(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.status_src), &buf[index], sizeof(op->data.mpi.status_src));
index += sizeof(op->data.mpi.status_src);

bcopy (&(op->data.mpi.datatype), &buf[index], sizeof(op->data.mpi.datatype));
index += sizeof(op->data.mpi.datatype);

bcopy (&(op->data.mpi.elements), &buf[index], sizeof(op->data.mpi.elements));
index += sizeof(op->data.mpi.elements);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Get_elements */


int umpi_pack_op_size_MPI_Get_elements(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.status_src)+sizeof(op->data.mpi.datatype)+sizeof(op->data.mpi.elements);
} /* umpi_pack_op_size_MPI_Get_elements */


int umpi_pack_op_MPI_Get_processor_name(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Get_processor_name(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.name), &buf[index], sizeof(op->data.mpi.name));
index += sizeof(op->data.mpi.name);

bcopy (&(op->data.mpi.reslen), &buf[index], sizeof(op->data.mpi.reslen));
index += sizeof(op->data.mpi.reslen);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Get_processor_name */


int umpi_pack_op_size_MPI_Get_processor_name(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.name)+sizeof(op->data.mpi.reslen);
} /* umpi_pack_op_size_MPI_Get_processor_name */


int umpi_pack_op_MPI_Get_version(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Get_version(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.version), &buf[index], sizeof(op->data.mpi.version));
index += sizeof(op->data.mpi.version);

bcopy (&(op->data.mpi.subversion), &buf[index], sizeof(op->data.mpi.subversion));
index += sizeof(op->data.mpi.subversion);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Get_version */


int umpi_pack_op_size_MPI_Get_version(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.version)+sizeof(op->data.mpi.subversion);
} /* umpi_pack_op_size_MPI_Get_version */


int umpi_pack_op_MPI_Graph_create(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Graph_create(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.comm), &buf[index], sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

bcopy (&(op->data.mpi.count), &buf[index], sizeof(op->data.mpi.count));
index += sizeof(op->data.mpi.count);

temp = op->data.mpi.count;
bcopy (&(temp), &buf[index], sizeof(int));
index += sizeof(int);

if (temp) {
bcopy (op->data.mpi.array_of_degrees, &buf[index], sizeof(op->data.mpi.array_of_degrees[0])*temp);
index += (sizeof(op->data.mpi.array_of_degrees[0])*temp);
}

temp = op->data.mpi.array_of_degrees[op->data.mpi.count-1];
bcopy (&(temp), &buf[index], sizeof(int));
index += sizeof(int);

if (temp) {
bcopy (op->data.mpi.edges, &buf[index], sizeof(op->data.mpi.edges[0])*temp);
index += (sizeof(op->data.mpi.edges[0])*temp);
}

bcopy (&(op->data.mpi.reorder), &buf[index], sizeof(op->data.mpi.reorder));
index += sizeof(op->data.mpi.reorder);

bcopy (&(op->data.mpi.comm_out), &buf[index], sizeof(op->data.mpi.comm_out));
index += sizeof(op->data.mpi.comm_out);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Graph_create */


int umpi_pack_op_size_MPI_Graph_create(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.comm)+sizeof(op->data.mpi.count)+sizeof(op->data.mpi.count)+(op->data.mpi.count*sizeof(op->data.mpi.array_of_degrees[0]))+sizeof(op->data.mpi.array_of_degrees[0])+(op->data.mpi.array_of_degrees[op->data.mpi.count-1]*sizeof(op->data.mpi.edges[0]))+sizeof(op->data.mpi.reorder)+sizeof(op->data.mpi.comm_out);
} /* umpi_pack_op_size_MPI_Graph_create */


int umpi_pack_op_MPI_Graph_get(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Graph_get(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.comm), &buf[index], sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

bcopy (&(op->data.mpi.count), &buf[index], sizeof(op->data.mpi.count));
index += sizeof(op->data.mpi.count);

bcopy (&(op->data.mpi.edgecount), &buf[index], sizeof(op->data.mpi.edgecount));
index += sizeof(op->data.mpi.edgecount);

temp = op->data.mpi.count;
bcopy (&(temp), &buf[index], sizeof(int));
index += sizeof(int);

if (temp) {
bcopy (op->data.mpi.array_of_degrees, &buf[index], sizeof(op->data.mpi.array_of_degrees[0])*temp);
index += (sizeof(op->data.mpi.array_of_degrees[0])*temp);
}

temp = op->data.mpi.edgecount;
bcopy (&(temp), &buf[index], sizeof(int));
index += sizeof(int);

if (temp) {
bcopy (op->data.mpi.retedges, &buf[index], sizeof(op->data.mpi.retedges[0])*temp);
index += (sizeof(op->data.mpi.retedges[0])*temp);
}

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Graph_get */


int umpi_pack_op_size_MPI_Graph_get(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.comm)+sizeof(op->data.mpi.count)+sizeof(op->data.mpi.edgecount)+sizeof(op->data.mpi.count)+(op->data.mpi.count*sizeof(op->data.mpi.array_of_degrees[0]))+sizeof(op->data.mpi.edgecount)+(op->data.mpi.edgecount*sizeof(op->data.mpi.retedges[0]));
} /* umpi_pack_op_size_MPI_Graph_get */


int umpi_pack_op_MPI_Graph_map(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Graph_map(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.comm), &buf[index], sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

bcopy (&(op->data.mpi.count), &buf[index], sizeof(op->data.mpi.count));
index += sizeof(op->data.mpi.count);

temp = op->data.mpi.count;
bcopy (&(temp), &buf[index], sizeof(int));
index += sizeof(int);

if (temp) {
bcopy (op->data.mpi.array_of_degrees, &buf[index], sizeof(op->data.mpi.array_of_degrees[0])*temp);
index += (sizeof(op->data.mpi.array_of_degrees[0])*temp);
}

temp = op->data.mpi.array_of_degrees[op->data.mpi.count-1];
bcopy (&(temp), &buf[index], sizeof(int));
index += sizeof(int);

if (temp) {
bcopy (op->data.mpi.edges, &buf[index], sizeof(op->data.mpi.edges[0])*temp);
index += (sizeof(op->data.mpi.edges[0])*temp);
}

bcopy (&(op->data.mpi.newrank), &buf[index], sizeof(op->data.mpi.newrank));
index += sizeof(op->data.mpi.newrank);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Graph_map */


int umpi_pack_op_size_MPI_Graph_map(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.comm)+sizeof(op->data.mpi.count)+sizeof(op->data.mpi.count)+(op->data.mpi.count*sizeof(op->data.mpi.array_of_degrees[0]))+sizeof(op->data.mpi.array_of_degrees[0])+(op->data.mpi.array_of_degrees[op->data.mpi.count-1]*sizeof(op->data.mpi.edges[0]))+sizeof(op->data.mpi.newrank);
} /* umpi_pack_op_size_MPI_Graph_map */


int umpi_pack_op_MPI_Graph_neighbors(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Graph_neighbors(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.comm), &buf[index], sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

bcopy (&(op->data.mpi.rank), &buf[index], sizeof(op->data.mpi.rank));
index += sizeof(op->data.mpi.rank);

bcopy (&(op->data.mpi.count), &buf[index], sizeof(op->data.mpi.count));
index += sizeof(op->data.mpi.count);

temp = op->data.mpi.count;
bcopy (&(temp), &buf[index], sizeof(int));
index += sizeof(int);

if (temp) {
bcopy (op->data.mpi.array_of_neighbors, &buf[index], sizeof(op->data.mpi.array_of_neighbors[0])*temp);
index += (sizeof(op->data.mpi.array_of_neighbors[0])*temp);
}

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Graph_neighbors */


int umpi_pack_op_size_MPI_Graph_neighbors(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.comm)+sizeof(op->data.mpi.rank)+sizeof(op->data.mpi.count)+sizeof(op->data.mpi.count)+(op->data.mpi.count*sizeof(op->data.mpi.array_of_neighbors[0]));
} /* umpi_pack_op_size_MPI_Graph_neighbors */


int umpi_pack_op_MPI_Graph_neighbors_count(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Graph_neighbors_count(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.comm), &buf[index], sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

bcopy (&(op->data.mpi.rank), &buf[index], sizeof(op->data.mpi.rank));
index += sizeof(op->data.mpi.rank);

bcopy (&(op->data.mpi.nneighbors), &buf[index], sizeof(op->data.mpi.nneighbors));
index += sizeof(op->data.mpi.nneighbors);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Graph_neighbors_count */


int umpi_pack_op_size_MPI_Graph_neighbors_count(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.comm)+sizeof(op->data.mpi.rank)+sizeof(op->data.mpi.nneighbors);
} /* umpi_pack_op_size_MPI_Graph_neighbors_count */


int umpi_pack_op_MPI_Graphdims_get(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Graphdims_get(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.comm), &buf[index], sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

bcopy (&(op->data.mpi.nnodes), &buf[index], sizeof(op->data.mpi.nnodes));
index += sizeof(op->data.mpi.nnodes);

bcopy (&(op->data.mpi.edgecountp), &buf[index], sizeof(op->data.mpi.edgecountp));
index += sizeof(op->data.mpi.edgecountp);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Graphdims_get */


int umpi_pack_op_size_MPI_Graphdims_get(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.comm)+sizeof(op->data.mpi.nnodes)+sizeof(op->data.mpi.edgecountp);
} /* umpi_pack_op_size_MPI_Graphdims_get */


int umpi_pack_op_MPI_Group_compare(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Group_compare(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.group1), &buf[index], sizeof(op->data.mpi.group1));
index += sizeof(op->data.mpi.group1);

bcopy (&(op->data.mpi.group2), &buf[index], sizeof(op->data.mpi.group2));
index += sizeof(op->data.mpi.group2);

bcopy (&(op->data.mpi.result), &buf[index], sizeof(op->data.mpi.result));
index += sizeof(op->data.mpi.result);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Group_compare */


int umpi_pack_op_size_MPI_Group_compare(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.group1)+sizeof(op->data.mpi.group2)+sizeof(op->data.mpi.result);
} /* umpi_pack_op_size_MPI_Group_compare */


int umpi_pack_op_MPI_Group_difference(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Group_difference(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.group1), &buf[index], sizeof(op->data.mpi.group1));
index += sizeof(op->data.mpi.group1);

bcopy (&(op->data.mpi.group2), &buf[index], sizeof(op->data.mpi.group2));
index += sizeof(op->data.mpi.group2);

bcopy (&(op->data.mpi.group_out), &buf[index], sizeof(op->data.mpi.group_out));
index += sizeof(op->data.mpi.group_out);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Group_difference */


int umpi_pack_op_size_MPI_Group_difference(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.group1)+sizeof(op->data.mpi.group2)+sizeof(op->data.mpi.group_out);
} /* umpi_pack_op_size_MPI_Group_difference */


int umpi_pack_op_MPI_Group_excl(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Group_excl(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.group), &buf[index], sizeof(op->data.mpi.group));
index += sizeof(op->data.mpi.group);

bcopy (&(op->data.mpi.count), &buf[index], sizeof(op->data.mpi.count));
index += sizeof(op->data.mpi.count);

temp = op->data.mpi.count;
bcopy (&(temp), &buf[index], sizeof(int));
index += sizeof(int);

if (temp) {
bcopy (op->data.mpi.array_of_ranks, &buf[index], sizeof(op->data.mpi.array_of_ranks[0])*temp);
index += (sizeof(op->data.mpi.array_of_ranks[0])*temp);
}

bcopy (&(op->data.mpi.group_out), &buf[index], sizeof(op->data.mpi.group_out));
index += sizeof(op->data.mpi.group_out);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Group_excl */


int umpi_pack_op_size_MPI_Group_excl(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.group)+sizeof(op->data.mpi.count)+sizeof(op->data.mpi.count)+(op->data.mpi.count*sizeof(op->data.mpi.array_of_ranks[0]))+sizeof(op->data.mpi.group_out);
} /* umpi_pack_op_size_MPI_Group_excl */


int umpi_pack_op_MPI_Group_free(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Group_free(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.group_out), &buf[index], sizeof(op->data.mpi.group_out));
index += sizeof(op->data.mpi.group_out);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Group_free */


int umpi_pack_op_size_MPI_Group_free(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.group_out);
} /* umpi_pack_op_size_MPI_Group_free */


int umpi_pack_op_MPI_Group_incl(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Group_incl(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.group), &buf[index], sizeof(op->data.mpi.group));
index += sizeof(op->data.mpi.group);

bcopy (&(op->data.mpi.count), &buf[index], sizeof(op->data.mpi.count));
index += sizeof(op->data.mpi.count);

temp = op->data.mpi.count;
bcopy (&(temp), &buf[index], sizeof(int));
index += sizeof(int);

if (temp) {
bcopy (op->data.mpi.array_of_ranks, &buf[index], sizeof(op->data.mpi.array_of_ranks[0])*temp);
index += (sizeof(op->data.mpi.array_of_ranks[0])*temp);
}

bcopy (&(op->data.mpi.group_out), &buf[index], sizeof(op->data.mpi.group_out));
index += sizeof(op->data.mpi.group_out);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Group_incl */


int umpi_pack_op_size_MPI_Group_incl(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.group)+sizeof(op->data.mpi.count)+sizeof(op->data.mpi.count)+(op->data.mpi.count*sizeof(op->data.mpi.array_of_ranks[0]))+sizeof(op->data.mpi.group_out);
} /* umpi_pack_op_size_MPI_Group_incl */


int umpi_pack_op_MPI_Group_intersection(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Group_intersection(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.group1), &buf[index], sizeof(op->data.mpi.group1));
index += sizeof(op->data.mpi.group1);

bcopy (&(op->data.mpi.group2), &buf[index], sizeof(op->data.mpi.group2));
index += sizeof(op->data.mpi.group2);

bcopy (&(op->data.mpi.group_out), &buf[index], sizeof(op->data.mpi.group_out));
index += sizeof(op->data.mpi.group_out);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Group_intersection */


int umpi_pack_op_size_MPI_Group_intersection(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.group1)+sizeof(op->data.mpi.group2)+sizeof(op->data.mpi.group_out);
} /* umpi_pack_op_size_MPI_Group_intersection */


int umpi_pack_op_MPI_Group_range_excl(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Group_range_excl(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.group), &buf[index], sizeof(op->data.mpi.group));
index += sizeof(op->data.mpi.group);

bcopy (&(op->data.mpi.count), &buf[index], sizeof(op->data.mpi.count));
index += sizeof(op->data.mpi.count);

temp = 3 * op->data.mpi.count;
bcopy (&(temp), &buf[index], sizeof(int));
index += sizeof(int);

if (temp) {
bcopy (op->data.mpi.ranges, &buf[index], sizeof(op->data.mpi.ranges[0])*temp);
index += (sizeof(op->data.mpi.ranges[0])*temp);
}

bcopy (&(op->data.mpi.group_out), &buf[index], sizeof(op->data.mpi.group_out));
index += sizeof(op->data.mpi.group_out);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Group_range_excl */


int umpi_pack_op_size_MPI_Group_range_excl(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.group)+sizeof(op->data.mpi.count)+sizeof(op->data.mpi.count)+(3*op->data.mpi.count*sizeof(op->data.mpi.ranges[0]))+sizeof(op->data.mpi.group_out);
} /* umpi_pack_op_size_MPI_Group_range_excl */


int umpi_pack_op_MPI_Group_range_incl(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Group_range_incl(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.group), &buf[index], sizeof(op->data.mpi.group));
index += sizeof(op->data.mpi.group);

bcopy (&(op->data.mpi.count), &buf[index], sizeof(op->data.mpi.count));
index += sizeof(op->data.mpi.count);

temp = 3 * op->data.mpi.count;
bcopy (&(temp), &buf[index], sizeof(int));
index += sizeof(int);

if (temp) {
bcopy (op->data.mpi.ranges, &buf[index], sizeof(op->data.mpi.ranges[0])*temp);
index += (sizeof(op->data.mpi.ranges[0])*temp);
}

bcopy (&(op->data.mpi.group_out), &buf[index], sizeof(op->data.mpi.group_out));
index += sizeof(op->data.mpi.group_out);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Group_range_incl */


int umpi_pack_op_size_MPI_Group_range_incl(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.group)+sizeof(op->data.mpi.count)+sizeof(op->data.mpi.count)+(3*op->data.mpi.count*sizeof(op->data.mpi.ranges[0]))+sizeof(op->data.mpi.group_out);
} /* umpi_pack_op_size_MPI_Group_range_incl */


int umpi_pack_op_MPI_Group_rank(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Group_rank(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.group), &buf[index], sizeof(op->data.mpi.group));
index += sizeof(op->data.mpi.group);

bcopy (&(op->data.mpi.rank), &buf[index], sizeof(op->data.mpi.rank));
index += sizeof(op->data.mpi.rank);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Group_rank */


int umpi_pack_op_size_MPI_Group_rank(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.group)+sizeof(op->data.mpi.rank);
} /* umpi_pack_op_size_MPI_Group_rank */


int umpi_pack_op_MPI_Group_size(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Group_size(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.group), &buf[index], sizeof(op->data.mpi.group));
index += sizeof(op->data.mpi.group);

bcopy (&(op->data.mpi.size), &buf[index], sizeof(op->data.mpi.size));
index += sizeof(op->data.mpi.size);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Group_size */


int umpi_pack_op_size_MPI_Group_size(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.group)+sizeof(op->data.mpi.size);
} /* umpi_pack_op_size_MPI_Group_size */


int umpi_pack_op_MPI_Group_translate_ranks(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Group_translate_ranks(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.group1), &buf[index], sizeof(op->data.mpi.group1));
index += sizeof(op->data.mpi.group1);

bcopy (&(op->data.mpi.count), &buf[index], sizeof(op->data.mpi.count));
index += sizeof(op->data.mpi.count);

temp = op->data.mpi.count;
bcopy (&(temp), &buf[index], sizeof(int));
index += sizeof(int);

if (temp) {
bcopy (op->data.mpi.array_of_ranks, &buf[index], sizeof(op->data.mpi.array_of_ranks[0])*temp);
index += (sizeof(op->data.mpi.array_of_ranks[0])*temp);
}

bcopy (&(op->data.mpi.group2), &buf[index], sizeof(op->data.mpi.group2));
index += sizeof(op->data.mpi.group2);

temp = op->data.mpi.count;
bcopy (&(temp), &buf[index], sizeof(int));
index += sizeof(int);

if (temp) {
bcopy (op->data.mpi.array_of_ranks2, &buf[index], sizeof(op->data.mpi.array_of_ranks2[0])*temp);
index += (sizeof(op->data.mpi.array_of_ranks2[0])*temp);
}

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Group_translate_ranks */


int umpi_pack_op_size_MPI_Group_translate_ranks(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.group1)+sizeof(op->data.mpi.count)+sizeof(op->data.mpi.count)+(op->data.mpi.count*sizeof(op->data.mpi.array_of_ranks[0]))+sizeof(op->data.mpi.group2)+sizeof(op->data.mpi.count)+(op->data.mpi.count*sizeof(op->data.mpi.array_of_ranks2[0]));
} /* umpi_pack_op_size_MPI_Group_translate_ranks */


int umpi_pack_op_MPI_Group_union(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Group_union(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.group1), &buf[index], sizeof(op->data.mpi.group1));
index += sizeof(op->data.mpi.group1);

bcopy (&(op->data.mpi.group2), &buf[index], sizeof(op->data.mpi.group2));
index += sizeof(op->data.mpi.group2);

bcopy (&(op->data.mpi.group_out), &buf[index], sizeof(op->data.mpi.group_out));
index += sizeof(op->data.mpi.group_out);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Group_union */


int umpi_pack_op_size_MPI_Group_union(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.group1)+sizeof(op->data.mpi.group2)+sizeof(op->data.mpi.group_out);
} /* umpi_pack_op_size_MPI_Group_union */


int umpi_pack_op_MPI_Handle2int(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Handle2int(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.c_handle), &buf[index], sizeof(op->data.mpi.c_handle));
index += sizeof(op->data.mpi.c_handle);

bcopy (&(op->data.mpi.handle_kind), &buf[index], sizeof(op->data.mpi.handle_kind));
index += sizeof(op->data.mpi.handle_kind);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Handle2int */


int umpi_pack_op_size_MPI_Handle2int(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.c_handle)+sizeof(op->data.mpi.handle_kind);
} /* umpi_pack_op_size_MPI_Handle2int */


int umpi_pack_op_MPI_Ibsend(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Ibsend(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.buf), &buf[index], sizeof(op->data.mpi.buf));
index += sizeof(op->data.mpi.buf);

bcopy (&(op->data.mpi.count), &buf[index], sizeof(op->data.mpi.count));
index += sizeof(op->data.mpi.count);

bcopy (&(op->data.mpi.datatype), &buf[index], sizeof(op->data.mpi.datatype));
index += sizeof(op->data.mpi.datatype);

bcopy (&(op->data.mpi.dest), &buf[index], sizeof(op->data.mpi.dest));
index += sizeof(op->data.mpi.dest);

bcopy (&(op->data.mpi.tag), &buf[index], sizeof(op->data.mpi.tag));
index += sizeof(op->data.mpi.tag);

bcopy (&(op->data.mpi.comm), &buf[index], sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

bcopy (&(op->data.mpi.request), &buf[index], sizeof(op->data.mpi.request));
index += sizeof(op->data.mpi.request);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Ibsend */


int umpi_pack_op_size_MPI_Ibsend(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.buf)+sizeof(op->data.mpi.count)+sizeof(op->data.mpi.datatype)+sizeof(op->data.mpi.dest)+sizeof(op->data.mpi.tag)+sizeof(op->data.mpi.comm)+sizeof(op->data.mpi.request);
} /* umpi_pack_op_size_MPI_Ibsend */


int umpi_pack_op_MPI_Info_c2f(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Info_c2f(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.info), &buf[index], sizeof(op->data.mpi.info));
index += sizeof(op->data.mpi.info);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Info_c2f */


int umpi_pack_op_size_MPI_Info_c2f(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.info);
} /* umpi_pack_op_size_MPI_Info_c2f */


int umpi_pack_op_MPI_Info_create(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Info_create(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.info), &buf[index], sizeof(op->data.mpi.info));
index += sizeof(op->data.mpi.info);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Info_create */


int umpi_pack_op_size_MPI_Info_create(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.info);
} /* umpi_pack_op_size_MPI_Info_create */


int umpi_pack_op_MPI_Info_delete(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Info_delete(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.info), &buf[index], sizeof(op->data.mpi.info));
index += sizeof(op->data.mpi.info);

bcopy (&(op->data.mpi.key), &buf[index], sizeof(op->data.mpi.key));
index += sizeof(op->data.mpi.key);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Info_delete */


int umpi_pack_op_size_MPI_Info_delete(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.info)+sizeof(op->data.mpi.key);
} /* umpi_pack_op_size_MPI_Info_delete */


int umpi_pack_op_MPI_Info_dup(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Info_dup(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.info), &buf[index], sizeof(op->data.mpi.info));
index += sizeof(op->data.mpi.info);

bcopy (&(op->data.mpi.newinfo), &buf[index], sizeof(op->data.mpi.newinfo));
index += sizeof(op->data.mpi.newinfo);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Info_dup */


int umpi_pack_op_size_MPI_Info_dup(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.info)+sizeof(op->data.mpi.newinfo);
} /* umpi_pack_op_size_MPI_Info_dup */


int umpi_pack_op_MPI_Info_f2c(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Info_f2c(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.info), &buf[index], sizeof(op->data.mpi.info));
index += sizeof(op->data.mpi.info);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Info_f2c */


int umpi_pack_op_size_MPI_Info_f2c(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.info);
} /* umpi_pack_op_size_MPI_Info_f2c */


int umpi_pack_op_MPI_Info_free(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Info_free(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.info), &buf[index], sizeof(op->data.mpi.info));
index += sizeof(op->data.mpi.info);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Info_free */


int umpi_pack_op_size_MPI_Info_free(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.info);
} /* umpi_pack_op_size_MPI_Info_free */


int umpi_pack_op_MPI_Info_get(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Info_get(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.info), &buf[index], sizeof(op->data.mpi.info));
index += sizeof(op->data.mpi.info);

bcopy (&(op->data.mpi.key), &buf[index], sizeof(op->data.mpi.key));
index += sizeof(op->data.mpi.key);

bcopy (&(op->data.mpi.valuelen), &buf[index], sizeof(op->data.mpi.valuelen));
index += sizeof(op->data.mpi.valuelen);

bcopy (&(op->data.mpi.value), &buf[index], sizeof(op->data.mpi.value));
index += sizeof(op->data.mpi.value);

bcopy (&(op->data.mpi.flag), &buf[index], sizeof(op->data.mpi.flag));
index += sizeof(op->data.mpi.flag);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Info_get */


int umpi_pack_op_size_MPI_Info_get(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.info)+sizeof(op->data.mpi.key)+sizeof(op->data.mpi.valuelen)+sizeof(op->data.mpi.value)+sizeof(op->data.mpi.flag);
} /* umpi_pack_op_size_MPI_Info_get */


int umpi_pack_op_MPI_Info_get_nkeys(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Info_get_nkeys(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.info), &buf[index], sizeof(op->data.mpi.info));
index += sizeof(op->data.mpi.info);

bcopy (&(op->data.mpi.nkeys), &buf[index], sizeof(op->data.mpi.nkeys));
index += sizeof(op->data.mpi.nkeys);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Info_get_nkeys */


int umpi_pack_op_size_MPI_Info_get_nkeys(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.info)+sizeof(op->data.mpi.nkeys);
} /* umpi_pack_op_size_MPI_Info_get_nkeys */


int umpi_pack_op_MPI_Info_get_nthkey(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Info_get_nthkey(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.info), &buf[index], sizeof(op->data.mpi.info));
index += sizeof(op->data.mpi.info);

bcopy (&(op->data.mpi.count), &buf[index], sizeof(op->data.mpi.count));
index += sizeof(op->data.mpi.count);

bcopy (&(op->data.mpi.key), &buf[index], sizeof(op->data.mpi.key));
index += sizeof(op->data.mpi.key);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Info_get_nthkey */


int umpi_pack_op_size_MPI_Info_get_nthkey(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.info)+sizeof(op->data.mpi.count)+sizeof(op->data.mpi.key);
} /* umpi_pack_op_size_MPI_Info_get_nthkey */


int umpi_pack_op_MPI_Info_get_valuelen(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Info_get_valuelen(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.info), &buf[index], sizeof(op->data.mpi.info));
index += sizeof(op->data.mpi.info);

bcopy (&(op->data.mpi.key), &buf[index], sizeof(op->data.mpi.key));
index += sizeof(op->data.mpi.key);

bcopy (&(op->data.mpi.valuelen), &buf[index], sizeof(op->data.mpi.valuelen));
index += sizeof(op->data.mpi.valuelen);

bcopy (&(op->data.mpi.flag), &buf[index], sizeof(op->data.mpi.flag));
index += sizeof(op->data.mpi.flag);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Info_get_valuelen */


int umpi_pack_op_size_MPI_Info_get_valuelen(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.info)+sizeof(op->data.mpi.key)+sizeof(op->data.mpi.valuelen)+sizeof(op->data.mpi.flag);
} /* umpi_pack_op_size_MPI_Info_get_valuelen */


int umpi_pack_op_MPI_Info_set(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Info_set(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.info), &buf[index], sizeof(op->data.mpi.info));
index += sizeof(op->data.mpi.info);

bcopy (&(op->data.mpi.key), &buf[index], sizeof(op->data.mpi.key));
index += sizeof(op->data.mpi.key);

bcopy (&(op->data.mpi.value), &buf[index], sizeof(op->data.mpi.value));
index += sizeof(op->data.mpi.value);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Info_set */


int umpi_pack_op_size_MPI_Info_set(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.info)+sizeof(op->data.mpi.key)+sizeof(op->data.mpi.value);
} /* umpi_pack_op_size_MPI_Info_set */


int umpi_pack_op_MPI_Init(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Init(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.argc), &buf[index], sizeof(op->data.mpi.argc));
index += sizeof(op->data.mpi.argc);

bcopy (&(op->data.mpi.argv), &buf[index], sizeof(op->data.mpi.argv));
index += sizeof(op->data.mpi.argv);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Init */


int umpi_pack_op_size_MPI_Init(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.argc)+sizeof(op->data.mpi.argv);
} /* umpi_pack_op_size_MPI_Init */


int umpi_pack_op_MPI_Initialized(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Initialized(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.flag), &buf[index], sizeof(op->data.mpi.flag));
index += sizeof(op->data.mpi.flag);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Initialized */


int umpi_pack_op_size_MPI_Initialized(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.flag);
} /* umpi_pack_op_size_MPI_Initialized */


int umpi_pack_op_MPI_Int2handle(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Int2handle(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.f_handle), &buf[index], sizeof(op->data.mpi.f_handle));
index += sizeof(op->data.mpi.f_handle);

bcopy (&(op->data.mpi.handle_kind), &buf[index], sizeof(op->data.mpi.handle_kind));
index += sizeof(op->data.mpi.handle_kind);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Int2handle */


int umpi_pack_op_size_MPI_Int2handle(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.f_handle)+sizeof(op->data.mpi.handle_kind);
} /* umpi_pack_op_size_MPI_Int2handle */


int umpi_pack_op_MPI_Intercomm_create(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Intercomm_create(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.comm), &buf[index], sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

bcopy (&(op->data.mpi.local_leader), &buf[index], sizeof(op->data.mpi.local_leader));
index += sizeof(op->data.mpi.local_leader);

bcopy (&(op->data.mpi.peer_comm), &buf[index], sizeof(op->data.mpi.peer_comm));
index += sizeof(op->data.mpi.peer_comm);

bcopy (&(op->data.mpi.remote_leader), &buf[index], sizeof(op->data.mpi.remote_leader));
index += sizeof(op->data.mpi.remote_leader);

bcopy (&(op->data.mpi.tag), &buf[index], sizeof(op->data.mpi.tag));
index += sizeof(op->data.mpi.tag);

bcopy (&(op->data.mpi.comm_out), &buf[index], sizeof(op->data.mpi.comm_out));
index += sizeof(op->data.mpi.comm_out);

bcopy (&(op->data.mpi.comm1), &buf[index], sizeof(op->data.mpi.comm1));
index += sizeof(op->data.mpi.comm1);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Intercomm_create */


int umpi_pack_op_size_MPI_Intercomm_create(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.comm)+sizeof(op->data.mpi.local_leader)+sizeof(op->data.mpi.peer_comm)+sizeof(op->data.mpi.remote_leader)+sizeof(op->data.mpi.tag)+sizeof(op->data.mpi.comm_out)+sizeof(op->data.mpi.comm1);
} /* umpi_pack_op_size_MPI_Intercomm_create */


int umpi_pack_op_MPI_Intercomm_merge(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Intercomm_merge(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.comm), &buf[index], sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

bcopy (&(op->data.mpi.high), &buf[index], sizeof(op->data.mpi.high));
index += sizeof(op->data.mpi.high);

bcopy (&(op->data.mpi.comm_out), &buf[index], sizeof(op->data.mpi.comm_out));
index += sizeof(op->data.mpi.comm_out);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Intercomm_merge */


int umpi_pack_op_size_MPI_Intercomm_merge(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.comm)+sizeof(op->data.mpi.high)+sizeof(op->data.mpi.comm_out);
} /* umpi_pack_op_size_MPI_Intercomm_merge */


int umpi_pack_op_MPI_Iprobe(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Iprobe(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.source), &buf[index], sizeof(op->data.mpi.source));
index += sizeof(op->data.mpi.source);

bcopy (&(op->data.mpi.tag), &buf[index], sizeof(op->data.mpi.tag));
index += sizeof(op->data.mpi.tag);

bcopy (&(op->data.mpi.comm), &buf[index], sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

bcopy (&(op->data.mpi.flag), &buf[index], sizeof(op->data.mpi.flag));
index += sizeof(op->data.mpi.flag);

bcopy (&(op->data.mpi.status_src), &buf[index], sizeof(op->data.mpi.status_src));
index += sizeof(op->data.mpi.status_src);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Iprobe */


int umpi_pack_op_size_MPI_Iprobe(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.source)+sizeof(op->data.mpi.tag)+sizeof(op->data.mpi.comm)+sizeof(op->data.mpi.flag)+sizeof(op->data.mpi.status_src);
} /* umpi_pack_op_size_MPI_Iprobe */


int umpi_pack_op_MPI_Irecv(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Irecv(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.buf), &buf[index], sizeof(op->data.mpi.buf));
index += sizeof(op->data.mpi.buf);

bcopy (&(op->data.mpi.count), &buf[index], sizeof(op->data.mpi.count));
index += sizeof(op->data.mpi.count);

bcopy (&(op->data.mpi.datatype), &buf[index], sizeof(op->data.mpi.datatype));
index += sizeof(op->data.mpi.datatype);

bcopy (&(op->data.mpi.source), &buf[index], sizeof(op->data.mpi.source));
index += sizeof(op->data.mpi.source);

bcopy (&(op->data.mpi.tag), &buf[index], sizeof(op->data.mpi.tag));
index += sizeof(op->data.mpi.tag);

bcopy (&(op->data.mpi.comm), &buf[index], sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

bcopy (&(op->data.mpi.request), &buf[index], sizeof(op->data.mpi.request));
index += sizeof(op->data.mpi.request);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Irecv */


int umpi_pack_op_size_MPI_Irecv(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.buf)+sizeof(op->data.mpi.count)+sizeof(op->data.mpi.datatype)+sizeof(op->data.mpi.source)+sizeof(op->data.mpi.tag)+sizeof(op->data.mpi.comm)+sizeof(op->data.mpi.request);
} /* umpi_pack_op_size_MPI_Irecv */


int umpi_pack_op_MPI_Irsend(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Irsend(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.buf), &buf[index], sizeof(op->data.mpi.buf));
index += sizeof(op->data.mpi.buf);

bcopy (&(op->data.mpi.count), &buf[index], sizeof(op->data.mpi.count));
index += sizeof(op->data.mpi.count);

bcopy (&(op->data.mpi.datatype), &buf[index], sizeof(op->data.mpi.datatype));
index += sizeof(op->data.mpi.datatype);

bcopy (&(op->data.mpi.dest), &buf[index], sizeof(op->data.mpi.dest));
index += sizeof(op->data.mpi.dest);

bcopy (&(op->data.mpi.tag), &buf[index], sizeof(op->data.mpi.tag));
index += sizeof(op->data.mpi.tag);

bcopy (&(op->data.mpi.comm), &buf[index], sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

bcopy (&(op->data.mpi.request), &buf[index], sizeof(op->data.mpi.request));
index += sizeof(op->data.mpi.request);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Irsend */


int umpi_pack_op_size_MPI_Irsend(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.buf)+sizeof(op->data.mpi.count)+sizeof(op->data.mpi.datatype)+sizeof(op->data.mpi.dest)+sizeof(op->data.mpi.tag)+sizeof(op->data.mpi.comm)+sizeof(op->data.mpi.request);
} /* umpi_pack_op_size_MPI_Irsend */


int umpi_pack_op_MPI_Isend(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Isend(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.buf), &buf[index], sizeof(op->data.mpi.buf));
index += sizeof(op->data.mpi.buf);

bcopy (&(op->data.mpi.count), &buf[index], sizeof(op->data.mpi.count));
index += sizeof(op->data.mpi.count);

bcopy (&(op->data.mpi.datatype), &buf[index], sizeof(op->data.mpi.datatype));
index += sizeof(op->data.mpi.datatype);

bcopy (&(op->data.mpi.dest), &buf[index], sizeof(op->data.mpi.dest));
index += sizeof(op->data.mpi.dest);

bcopy (&(op->data.mpi.tag), &buf[index], sizeof(op->data.mpi.tag));
index += sizeof(op->data.mpi.tag);

bcopy (&(op->data.mpi.comm), &buf[index], sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

bcopy (&(op->data.mpi.request), &buf[index], sizeof(op->data.mpi.request));
index += sizeof(op->data.mpi.request);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Isend */


int umpi_pack_op_size_MPI_Isend(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.buf)+sizeof(op->data.mpi.count)+sizeof(op->data.mpi.datatype)+sizeof(op->data.mpi.dest)+sizeof(op->data.mpi.tag)+sizeof(op->data.mpi.comm)+sizeof(op->data.mpi.request);
} /* umpi_pack_op_size_MPI_Isend */


int umpi_pack_op_MPI_Issend(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Issend(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.buf), &buf[index], sizeof(op->data.mpi.buf));
index += sizeof(op->data.mpi.buf);

bcopy (&(op->data.mpi.count), &buf[index], sizeof(op->data.mpi.count));
index += sizeof(op->data.mpi.count);

bcopy (&(op->data.mpi.datatype), &buf[index], sizeof(op->data.mpi.datatype));
index += sizeof(op->data.mpi.datatype);

bcopy (&(op->data.mpi.dest), &buf[index], sizeof(op->data.mpi.dest));
index += sizeof(op->data.mpi.dest);

bcopy (&(op->data.mpi.tag), &buf[index], sizeof(op->data.mpi.tag));
index += sizeof(op->data.mpi.tag);

bcopy (&(op->data.mpi.comm), &buf[index], sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

bcopy (&(op->data.mpi.request), &buf[index], sizeof(op->data.mpi.request));
index += sizeof(op->data.mpi.request);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Issend */


int umpi_pack_op_size_MPI_Issend(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.buf)+sizeof(op->data.mpi.count)+sizeof(op->data.mpi.datatype)+sizeof(op->data.mpi.dest)+sizeof(op->data.mpi.tag)+sizeof(op->data.mpi.comm)+sizeof(op->data.mpi.request);
} /* umpi_pack_op_size_MPI_Issend */


int umpi_pack_op_MPI_Keyval_create(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Keyval_create(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.copy_function), &buf[index], sizeof(op->data.mpi.copy_function));
index += sizeof(op->data.mpi.copy_function);

bcopy (&(op->data.mpi.delete_function), &buf[index], sizeof(op->data.mpi.delete_function));
index += sizeof(op->data.mpi.delete_function);

bcopy (&(op->data.mpi.keyval), &buf[index], sizeof(op->data.mpi.keyval));
index += sizeof(op->data.mpi.keyval);

bcopy (&(op->data.mpi.extra_state), &buf[index], sizeof(op->data.mpi.extra_state));
index += sizeof(op->data.mpi.extra_state);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Keyval_create */


int umpi_pack_op_size_MPI_Keyval_create(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.copy_function)+sizeof(op->data.mpi.delete_function)+sizeof(op->data.mpi.keyval)+sizeof(op->data.mpi.extra_state);
} /* umpi_pack_op_size_MPI_Keyval_create */


int umpi_pack_op_MPI_Keyval_free(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Keyval_free(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.keyval), &buf[index], sizeof(op->data.mpi.keyval));
index += sizeof(op->data.mpi.keyval);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Keyval_free */


int umpi_pack_op_size_MPI_Keyval_free(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.keyval);
} /* umpi_pack_op_size_MPI_Keyval_free */


int umpi_pack_op_MPI_Op_create(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Op_create(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.function), &buf[index], sizeof(op->data.mpi.function));
index += sizeof(op->data.mpi.function);

bcopy (&(op->data.mpi.commute), &buf[index], sizeof(op->data.mpi.commute));
index += sizeof(op->data.mpi.commute);

bcopy (&(op->data.mpi.op), &buf[index], sizeof(op->data.mpi.op));
index += sizeof(op->data.mpi.op);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Op_create */


int umpi_pack_op_size_MPI_Op_create(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.function)+sizeof(op->data.mpi.commute)+sizeof(op->data.mpi.op);
} /* umpi_pack_op_size_MPI_Op_create */


int umpi_pack_op_MPI_Op_free(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Op_free(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.op), &buf[index], sizeof(op->data.mpi.op));
index += sizeof(op->data.mpi.op);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Op_free */


int umpi_pack_op_size_MPI_Op_free(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.op);
} /* umpi_pack_op_size_MPI_Op_free */


int umpi_pack_op_MPI_Pack(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Pack(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.inbuf), &buf[index], sizeof(op->data.mpi.inbuf));
index += sizeof(op->data.mpi.inbuf);

bcopy (&(op->data.mpi.incount), &buf[index], sizeof(op->data.mpi.incount));
index += sizeof(op->data.mpi.incount);

bcopy (&(op->data.mpi.datatype), &buf[index], sizeof(op->data.mpi.datatype));
index += sizeof(op->data.mpi.datatype);

bcopy (&(op->data.mpi.outbuf), &buf[index], sizeof(op->data.mpi.outbuf));
index += sizeof(op->data.mpi.outbuf);

bcopy (&(op->data.mpi.outcount), &buf[index], sizeof(op->data.mpi.outcount));
index += sizeof(op->data.mpi.outcount);

bcopy (&(op->data.mpi.position), &buf[index], sizeof(op->data.mpi.position));
index += sizeof(op->data.mpi.position);

bcopy (&(op->data.mpi.comm), &buf[index], sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Pack */


int umpi_pack_op_size_MPI_Pack(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.inbuf)+sizeof(op->data.mpi.incount)+sizeof(op->data.mpi.datatype)+sizeof(op->data.mpi.outbuf)+sizeof(op->data.mpi.outcount)+sizeof(op->data.mpi.position)+sizeof(op->data.mpi.comm);
} /* umpi_pack_op_size_MPI_Pack */


int umpi_pack_op_MPI_Pack_size(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Pack_size(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.incount), &buf[index], sizeof(op->data.mpi.incount));
index += sizeof(op->data.mpi.incount);

bcopy (&(op->data.mpi.datatype), &buf[index], sizeof(op->data.mpi.datatype));
index += sizeof(op->data.mpi.datatype);

bcopy (&(op->data.mpi.comm), &buf[index], sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

bcopy (&(op->data.mpi.size), &buf[index], sizeof(op->data.mpi.size));
index += sizeof(op->data.mpi.size);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Pack_size */


int umpi_pack_op_size_MPI_Pack_size(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.incount)+sizeof(op->data.mpi.datatype)+sizeof(op->data.mpi.comm)+sizeof(op->data.mpi.size);
} /* umpi_pack_op_size_MPI_Pack_size */


int umpi_pack_op_MPI_Pcontrol(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Pcontrol(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.level), &buf[index], sizeof(op->data.mpi.level));
index += sizeof(op->data.mpi.level);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Pcontrol */


int umpi_pack_op_size_MPI_Pcontrol(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.level);
} /* umpi_pack_op_size_MPI_Pcontrol */


int umpi_pack_op_MPI_Probe(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Probe(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.source), &buf[index], sizeof(op->data.mpi.source));
index += sizeof(op->data.mpi.source);

bcopy (&(op->data.mpi.tag), &buf[index], sizeof(op->data.mpi.tag));
index += sizeof(op->data.mpi.tag);

bcopy (&(op->data.mpi.comm), &buf[index], sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

bcopy (&(op->data.mpi.status_src), &buf[index], sizeof(op->data.mpi.status_src));
index += sizeof(op->data.mpi.status_src);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Probe */


int umpi_pack_op_size_MPI_Probe(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.source)+sizeof(op->data.mpi.tag)+sizeof(op->data.mpi.comm)+sizeof(op->data.mpi.status_src);
} /* umpi_pack_op_size_MPI_Probe */


int umpi_pack_op_MPI_Recv(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Recv(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.buf), &buf[index], sizeof(op->data.mpi.buf));
index += sizeof(op->data.mpi.buf);

bcopy (&(op->data.mpi.count), &buf[index], sizeof(op->data.mpi.count));
index += sizeof(op->data.mpi.count);

bcopy (&(op->data.mpi.datatype), &buf[index], sizeof(op->data.mpi.datatype));
index += sizeof(op->data.mpi.datatype);

bcopy (&(op->data.mpi.source), &buf[index], sizeof(op->data.mpi.source));
index += sizeof(op->data.mpi.source);

bcopy (&(op->data.mpi.tag), &buf[index], sizeof(op->data.mpi.tag));
index += sizeof(op->data.mpi.tag);

bcopy (&(op->data.mpi.comm), &buf[index], sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

bcopy (&(op->data.mpi.status_src), &buf[index], sizeof(op->data.mpi.status_src));
index += sizeof(op->data.mpi.status_src);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Recv */


int umpi_pack_op_size_MPI_Recv(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.buf)+sizeof(op->data.mpi.count)+sizeof(op->data.mpi.datatype)+sizeof(op->data.mpi.source)+sizeof(op->data.mpi.tag)+sizeof(op->data.mpi.comm)+sizeof(op->data.mpi.status_src);
} /* umpi_pack_op_size_MPI_Recv */


int umpi_pack_op_MPI_Recv_init(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Recv_init(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.buf), &buf[index], sizeof(op->data.mpi.buf));
index += sizeof(op->data.mpi.buf);

bcopy (&(op->data.mpi.count), &buf[index], sizeof(op->data.mpi.count));
index += sizeof(op->data.mpi.count);

bcopy (&(op->data.mpi.datatype), &buf[index], sizeof(op->data.mpi.datatype));
index += sizeof(op->data.mpi.datatype);

bcopy (&(op->data.mpi.source), &buf[index], sizeof(op->data.mpi.source));
index += sizeof(op->data.mpi.source);

bcopy (&(op->data.mpi.tag), &buf[index], sizeof(op->data.mpi.tag));
index += sizeof(op->data.mpi.tag);

bcopy (&(op->data.mpi.comm), &buf[index], sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

bcopy (&(op->data.mpi.request), &buf[index], sizeof(op->data.mpi.request));
index += sizeof(op->data.mpi.request);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Recv_init */


int umpi_pack_op_size_MPI_Recv_init(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.buf)+sizeof(op->data.mpi.count)+sizeof(op->data.mpi.datatype)+sizeof(op->data.mpi.source)+sizeof(op->data.mpi.tag)+sizeof(op->data.mpi.comm)+sizeof(op->data.mpi.request);
} /* umpi_pack_op_size_MPI_Recv_init */


int umpi_pack_op_MPI_Reduce(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Reduce(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.buf), &buf[index], sizeof(op->data.mpi.buf));
index += sizeof(op->data.mpi.buf);

bcopy (&(op->data.mpi.recvbuf), &buf[index], sizeof(op->data.mpi.recvbuf));
index += sizeof(op->data.mpi.recvbuf);

bcopy (&(op->data.mpi.count), &buf[index], sizeof(op->data.mpi.count));
index += sizeof(op->data.mpi.count);

bcopy (&(op->data.mpi.datatype), &buf[index], sizeof(op->data.mpi.datatype));
index += sizeof(op->data.mpi.datatype);

bcopy (&(op->data.mpi.op), &buf[index], sizeof(op->data.mpi.op));
index += sizeof(op->data.mpi.op);

bcopy (&(op->data.mpi.root), &buf[index], sizeof(op->data.mpi.root));
index += sizeof(op->data.mpi.root);

bcopy (&(op->data.mpi.comm), &buf[index], sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Reduce */


int umpi_pack_op_size_MPI_Reduce(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.buf)+sizeof(op->data.mpi.recvbuf)+sizeof(op->data.mpi.count)+sizeof(op->data.mpi.datatype)+sizeof(op->data.mpi.op)+sizeof(op->data.mpi.root)+sizeof(op->data.mpi.comm);
} /* umpi_pack_op_size_MPI_Reduce */


int umpi_pack_op_MPI_Reduce_scatter(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Reduce_scatter(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.buf), &buf[index], sizeof(op->data.mpi.buf));
index += sizeof(op->data.mpi.buf);

bcopy (&(op->data.mpi.recvbuf), &buf[index], sizeof(op->data.mpi.recvbuf));
index += sizeof(op->data.mpi.recvbuf);

temp = op->data.mpi.size;
bcopy (&(temp), &buf[index], sizeof(int));
index += sizeof(int);

if (temp) {
bcopy (op->data.mpi.recvcounts, &buf[index], sizeof(op->data.mpi.recvcounts[0])*temp);
index += (sizeof(op->data.mpi.recvcounts[0])*temp);
}

bcopy (&(op->data.mpi.datatype), &buf[index], sizeof(op->data.mpi.datatype));
index += sizeof(op->data.mpi.datatype);

bcopy (&(op->data.mpi.op), &buf[index], sizeof(op->data.mpi.op));
index += sizeof(op->data.mpi.op);

bcopy (&(op->data.mpi.comm), &buf[index], sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

bcopy (&(op->data.mpi.size), &buf[index], sizeof(op->data.mpi.size));
index += sizeof(op->data.mpi.size);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Reduce_scatter */


int umpi_pack_op_size_MPI_Reduce_scatter(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.buf)+sizeof(op->data.mpi.recvbuf)+sizeof(op->data.mpi.size)+(op->data.mpi.size*sizeof(op->data.mpi.recvcounts[0]))+sizeof(op->data.mpi.datatype)+sizeof(op->data.mpi.op)+sizeof(op->data.mpi.comm)+sizeof(op->data.mpi.size);
} /* umpi_pack_op_size_MPI_Reduce_scatter */


int umpi_pack_op_MPI_Request_c2f(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Request_c2f(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.c_request), &buf[index], sizeof(op->data.mpi.c_request));
index += sizeof(op->data.mpi.c_request);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Request_c2f */


int umpi_pack_op_size_MPI_Request_c2f(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.c_request);
} /* umpi_pack_op_size_MPI_Request_c2f */


int umpi_pack_op_MPI_Request_free(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Request_free(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.request), &buf[index], sizeof(op->data.mpi.request));
index += sizeof(op->data.mpi.request);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Request_free */


int umpi_pack_op_size_MPI_Request_free(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.request);
} /* umpi_pack_op_size_MPI_Request_free */


int umpi_pack_op_MPI_Rsend(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Rsend(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.buf), &buf[index], sizeof(op->data.mpi.buf));
index += sizeof(op->data.mpi.buf);

bcopy (&(op->data.mpi.count), &buf[index], sizeof(op->data.mpi.count));
index += sizeof(op->data.mpi.count);

bcopy (&(op->data.mpi.datatype), &buf[index], sizeof(op->data.mpi.datatype));
index += sizeof(op->data.mpi.datatype);

bcopy (&(op->data.mpi.dest), &buf[index], sizeof(op->data.mpi.dest));
index += sizeof(op->data.mpi.dest);

bcopy (&(op->data.mpi.tag), &buf[index], sizeof(op->data.mpi.tag));
index += sizeof(op->data.mpi.tag);

bcopy (&(op->data.mpi.comm), &buf[index], sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Rsend */


int umpi_pack_op_size_MPI_Rsend(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.buf)+sizeof(op->data.mpi.count)+sizeof(op->data.mpi.datatype)+sizeof(op->data.mpi.dest)+sizeof(op->data.mpi.tag)+sizeof(op->data.mpi.comm);
} /* umpi_pack_op_size_MPI_Rsend */


int umpi_pack_op_MPI_Rsend_init(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Rsend_init(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.buf), &buf[index], sizeof(op->data.mpi.buf));
index += sizeof(op->data.mpi.buf);

bcopy (&(op->data.mpi.count), &buf[index], sizeof(op->data.mpi.count));
index += sizeof(op->data.mpi.count);

bcopy (&(op->data.mpi.datatype), &buf[index], sizeof(op->data.mpi.datatype));
index += sizeof(op->data.mpi.datatype);

bcopy (&(op->data.mpi.dest), &buf[index], sizeof(op->data.mpi.dest));
index += sizeof(op->data.mpi.dest);

bcopy (&(op->data.mpi.tag), &buf[index], sizeof(op->data.mpi.tag));
index += sizeof(op->data.mpi.tag);

bcopy (&(op->data.mpi.comm), &buf[index], sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

bcopy (&(op->data.mpi.request), &buf[index], sizeof(op->data.mpi.request));
index += sizeof(op->data.mpi.request);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Rsend_init */


int umpi_pack_op_size_MPI_Rsend_init(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.buf)+sizeof(op->data.mpi.count)+sizeof(op->data.mpi.datatype)+sizeof(op->data.mpi.dest)+sizeof(op->data.mpi.tag)+sizeof(op->data.mpi.comm)+sizeof(op->data.mpi.request);
} /* umpi_pack_op_size_MPI_Rsend_init */


int umpi_pack_op_MPI_Scan(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Scan(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.buf), &buf[index], sizeof(op->data.mpi.buf));
index += sizeof(op->data.mpi.buf);

bcopy (&(op->data.mpi.recvbuf), &buf[index], sizeof(op->data.mpi.recvbuf));
index += sizeof(op->data.mpi.recvbuf);

bcopy (&(op->data.mpi.count), &buf[index], sizeof(op->data.mpi.count));
index += sizeof(op->data.mpi.count);

bcopy (&(op->data.mpi.datatype), &buf[index], sizeof(op->data.mpi.datatype));
index += sizeof(op->data.mpi.datatype);

bcopy (&(op->data.mpi.op), &buf[index], sizeof(op->data.mpi.op));
index += sizeof(op->data.mpi.op);

bcopy (&(op->data.mpi.comm), &buf[index], sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Scan */


int umpi_pack_op_size_MPI_Scan(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.buf)+sizeof(op->data.mpi.recvbuf)+sizeof(op->data.mpi.count)+sizeof(op->data.mpi.datatype)+sizeof(op->data.mpi.op)+sizeof(op->data.mpi.comm);
} /* umpi_pack_op_size_MPI_Scan */


int umpi_pack_op_MPI_Scatter(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Scatter(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.buf), &buf[index], sizeof(op->data.mpi.buf));
index += sizeof(op->data.mpi.buf);

bcopy (&(op->data.mpi.count), &buf[index], sizeof(op->data.mpi.count));
index += sizeof(op->data.mpi.count);

bcopy (&(op->data.mpi.datatype), &buf[index], sizeof(op->data.mpi.datatype));
index += sizeof(op->data.mpi.datatype);

bcopy (&(op->data.mpi.recvbuf), &buf[index], sizeof(op->data.mpi.recvbuf));
index += sizeof(op->data.mpi.recvbuf);

bcopy (&(op->data.mpi.recvcount), &buf[index], sizeof(op->data.mpi.recvcount));
index += sizeof(op->data.mpi.recvcount);

bcopy (&(op->data.mpi.recvtype), &buf[index], sizeof(op->data.mpi.recvtype));
index += sizeof(op->data.mpi.recvtype);

bcopy (&(op->data.mpi.root), &buf[index], sizeof(op->data.mpi.root));
index += sizeof(op->data.mpi.root);

bcopy (&(op->data.mpi.comm), &buf[index], sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Scatter */


int umpi_pack_op_size_MPI_Scatter(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.buf)+sizeof(op->data.mpi.count)+sizeof(op->data.mpi.datatype)+sizeof(op->data.mpi.recvbuf)+sizeof(op->data.mpi.recvcount)+sizeof(op->data.mpi.recvtype)+sizeof(op->data.mpi.root)+sizeof(op->data.mpi.comm);
} /* umpi_pack_op_size_MPI_Scatter */


int umpi_pack_op_MPI_Scatterv(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Scatterv(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.buf), &buf[index], sizeof(op->data.mpi.buf));
index += sizeof(op->data.mpi.buf);

temp = op->data.mpi.size;
bcopy (&(temp), &buf[index], sizeof(int));
index += sizeof(int);

if (temp) {
bcopy (op->data.mpi.counts, &buf[index], sizeof(op->data.mpi.counts[0])*temp);
index += (sizeof(op->data.mpi.counts[0])*temp);
}

temp = op->data.mpi.size;
bcopy (&(temp), &buf[index], sizeof(int));
index += sizeof(int);

if (temp) {
bcopy (op->data.mpi.displs, &buf[index], sizeof(op->data.mpi.displs[0])*temp);
index += (sizeof(op->data.mpi.displs[0])*temp);
}

bcopy (&(op->data.mpi.datatype), &buf[index], sizeof(op->data.mpi.datatype));
index += sizeof(op->data.mpi.datatype);

bcopy (&(op->data.mpi.recvbuf), &buf[index], sizeof(op->data.mpi.recvbuf));
index += sizeof(op->data.mpi.recvbuf);

bcopy (&(op->data.mpi.recvcount), &buf[index], sizeof(op->data.mpi.recvcount));
index += sizeof(op->data.mpi.recvcount);

bcopy (&(op->data.mpi.recvtype), &buf[index], sizeof(op->data.mpi.recvtype));
index += sizeof(op->data.mpi.recvtype);

bcopy (&(op->data.mpi.root), &buf[index], sizeof(op->data.mpi.root));
index += sizeof(op->data.mpi.root);

bcopy (&(op->data.mpi.comm), &buf[index], sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

bcopy (&(op->data.mpi.size), &buf[index], sizeof(op->data.mpi.size));
index += sizeof(op->data.mpi.size);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Scatterv */


int umpi_pack_op_size_MPI_Scatterv(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.buf)+sizeof(op->data.mpi.size)+(op->data.mpi.size*sizeof(op->data.mpi.counts[0]))+sizeof(op->data.mpi.size)+(op->data.mpi.size*sizeof(op->data.mpi.displs[0]))+sizeof(op->data.mpi.datatype)+sizeof(op->data.mpi.recvbuf)+sizeof(op->data.mpi.recvcount)+sizeof(op->data.mpi.recvtype)+sizeof(op->data.mpi.root)+sizeof(op->data.mpi.comm)+sizeof(op->data.mpi.size);
} /* umpi_pack_op_size_MPI_Scatterv */


int umpi_pack_op_MPI_Send(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Send(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.buf), &buf[index], sizeof(op->data.mpi.buf));
index += sizeof(op->data.mpi.buf);

bcopy (&(op->data.mpi.count), &buf[index], sizeof(op->data.mpi.count));
index += sizeof(op->data.mpi.count);

bcopy (&(op->data.mpi.datatype), &buf[index], sizeof(op->data.mpi.datatype));
index += sizeof(op->data.mpi.datatype);

bcopy (&(op->data.mpi.dest), &buf[index], sizeof(op->data.mpi.dest));
index += sizeof(op->data.mpi.dest);

bcopy (&(op->data.mpi.tag), &buf[index], sizeof(op->data.mpi.tag));
index += sizeof(op->data.mpi.tag);

bcopy (&(op->data.mpi.comm), &buf[index], sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Send */


int umpi_pack_op_size_MPI_Send(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.buf)+sizeof(op->data.mpi.count)+sizeof(op->data.mpi.datatype)+sizeof(op->data.mpi.dest)+sizeof(op->data.mpi.tag)+sizeof(op->data.mpi.comm);
} /* umpi_pack_op_size_MPI_Send */


int umpi_pack_op_MPI_Send_init(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Send_init(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.buf), &buf[index], sizeof(op->data.mpi.buf));
index += sizeof(op->data.mpi.buf);

bcopy (&(op->data.mpi.count), &buf[index], sizeof(op->data.mpi.count));
index += sizeof(op->data.mpi.count);

bcopy (&(op->data.mpi.datatype), &buf[index], sizeof(op->data.mpi.datatype));
index += sizeof(op->data.mpi.datatype);

bcopy (&(op->data.mpi.dest), &buf[index], sizeof(op->data.mpi.dest));
index += sizeof(op->data.mpi.dest);

bcopy (&(op->data.mpi.tag), &buf[index], sizeof(op->data.mpi.tag));
index += sizeof(op->data.mpi.tag);

bcopy (&(op->data.mpi.comm), &buf[index], sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

bcopy (&(op->data.mpi.request), &buf[index], sizeof(op->data.mpi.request));
index += sizeof(op->data.mpi.request);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Send_init */


int umpi_pack_op_size_MPI_Send_init(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.buf)+sizeof(op->data.mpi.count)+sizeof(op->data.mpi.datatype)+sizeof(op->data.mpi.dest)+sizeof(op->data.mpi.tag)+sizeof(op->data.mpi.comm)+sizeof(op->data.mpi.request);
} /* umpi_pack_op_size_MPI_Send_init */


int umpi_pack_op_MPI_Sendrecv(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Sendrecv(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.buf), &buf[index], sizeof(op->data.mpi.buf));
index += sizeof(op->data.mpi.buf);

bcopy (&(op->data.mpi.count), &buf[index], sizeof(op->data.mpi.count));
index += sizeof(op->data.mpi.count);

bcopy (&(op->data.mpi.datatype), &buf[index], sizeof(op->data.mpi.datatype));
index += sizeof(op->data.mpi.datatype);

bcopy (&(op->data.mpi.dest), &buf[index], sizeof(op->data.mpi.dest));
index += sizeof(op->data.mpi.dest);

bcopy (&(op->data.mpi.sendtag), &buf[index], sizeof(op->data.mpi.sendtag));
index += sizeof(op->data.mpi.sendtag);

bcopy (&(op->data.mpi.recvbuf), &buf[index], sizeof(op->data.mpi.recvbuf));
index += sizeof(op->data.mpi.recvbuf);

bcopy (&(op->data.mpi.recvcount), &buf[index], sizeof(op->data.mpi.recvcount));
index += sizeof(op->data.mpi.recvcount);

bcopy (&(op->data.mpi.recvtype), &buf[index], sizeof(op->data.mpi.recvtype));
index += sizeof(op->data.mpi.recvtype);

bcopy (&(op->data.mpi.source), &buf[index], sizeof(op->data.mpi.source));
index += sizeof(op->data.mpi.source);

bcopy (&(op->data.mpi.recvtag), &buf[index], sizeof(op->data.mpi.recvtag));
index += sizeof(op->data.mpi.recvtag);

bcopy (&(op->data.mpi.comm), &buf[index], sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

bcopy (&(op->data.mpi.status_src), &buf[index], sizeof(op->data.mpi.status_src));
index += sizeof(op->data.mpi.status_src);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Sendrecv */


int umpi_pack_op_size_MPI_Sendrecv(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.buf)+sizeof(op->data.mpi.count)+sizeof(op->data.mpi.datatype)+sizeof(op->data.mpi.dest)+sizeof(op->data.mpi.sendtag)+sizeof(op->data.mpi.recvbuf)+sizeof(op->data.mpi.recvcount)+sizeof(op->data.mpi.recvtype)+sizeof(op->data.mpi.source)+sizeof(op->data.mpi.recvtag)+sizeof(op->data.mpi.comm)+sizeof(op->data.mpi.status_src);
} /* umpi_pack_op_size_MPI_Sendrecv */


int umpi_pack_op_MPI_Sendrecv_replace(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Sendrecv_replace(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.buf), &buf[index], sizeof(op->data.mpi.buf));
index += sizeof(op->data.mpi.buf);

bcopy (&(op->data.mpi.count), &buf[index], sizeof(op->data.mpi.count));
index += sizeof(op->data.mpi.count);

bcopy (&(op->data.mpi.datatype), &buf[index], sizeof(op->data.mpi.datatype));
index += sizeof(op->data.mpi.datatype);

bcopy (&(op->data.mpi.dest), &buf[index], sizeof(op->data.mpi.dest));
index += sizeof(op->data.mpi.dest);

bcopy (&(op->data.mpi.sendtag), &buf[index], sizeof(op->data.mpi.sendtag));
index += sizeof(op->data.mpi.sendtag);

bcopy (&(op->data.mpi.source), &buf[index], sizeof(op->data.mpi.source));
index += sizeof(op->data.mpi.source);

bcopy (&(op->data.mpi.recvtag), &buf[index], sizeof(op->data.mpi.recvtag));
index += sizeof(op->data.mpi.recvtag);

bcopy (&(op->data.mpi.comm), &buf[index], sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

bcopy (&(op->data.mpi.status_src), &buf[index], sizeof(op->data.mpi.status_src));
index += sizeof(op->data.mpi.status_src);

bcopy (&(op->data.mpi.recvbuf), &buf[index], sizeof(op->data.mpi.recvbuf));
index += sizeof(op->data.mpi.recvbuf);

bcopy (&(op->data.mpi.recvcount), &buf[index], sizeof(op->data.mpi.recvcount));
index += sizeof(op->data.mpi.recvcount);

bcopy (&(op->data.mpi.recvtype), &buf[index], sizeof(op->data.mpi.recvtype));
index += sizeof(op->data.mpi.recvtype);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Sendrecv_replace */


int umpi_pack_op_size_MPI_Sendrecv_replace(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.buf)+sizeof(op->data.mpi.count)+sizeof(op->data.mpi.datatype)+sizeof(op->data.mpi.dest)+sizeof(op->data.mpi.sendtag)+sizeof(op->data.mpi.source)+sizeof(op->data.mpi.recvtag)+sizeof(op->data.mpi.comm)+sizeof(op->data.mpi.status_src)+sizeof(op->data.mpi.recvbuf)+sizeof(op->data.mpi.recvcount)+sizeof(op->data.mpi.recvtype);
} /* umpi_pack_op_size_MPI_Sendrecv_replace */


int umpi_pack_op_MPI_Ssend(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Ssend(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.buf), &buf[index], sizeof(op->data.mpi.buf));
index += sizeof(op->data.mpi.buf);

bcopy (&(op->data.mpi.count), &buf[index], sizeof(op->data.mpi.count));
index += sizeof(op->data.mpi.count);

bcopy (&(op->data.mpi.datatype), &buf[index], sizeof(op->data.mpi.datatype));
index += sizeof(op->data.mpi.datatype);

bcopy (&(op->data.mpi.dest), &buf[index], sizeof(op->data.mpi.dest));
index += sizeof(op->data.mpi.dest);

bcopy (&(op->data.mpi.tag), &buf[index], sizeof(op->data.mpi.tag));
index += sizeof(op->data.mpi.tag);

bcopy (&(op->data.mpi.comm), &buf[index], sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Ssend */


int umpi_pack_op_size_MPI_Ssend(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.buf)+sizeof(op->data.mpi.count)+sizeof(op->data.mpi.datatype)+sizeof(op->data.mpi.dest)+sizeof(op->data.mpi.tag)+sizeof(op->data.mpi.comm);
} /* umpi_pack_op_size_MPI_Ssend */


int umpi_pack_op_MPI_Ssend_init(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Ssend_init(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.buf), &buf[index], sizeof(op->data.mpi.buf));
index += sizeof(op->data.mpi.buf);

bcopy (&(op->data.mpi.count), &buf[index], sizeof(op->data.mpi.count));
index += sizeof(op->data.mpi.count);

bcopy (&(op->data.mpi.datatype), &buf[index], sizeof(op->data.mpi.datatype));
index += sizeof(op->data.mpi.datatype);

bcopy (&(op->data.mpi.dest), &buf[index], sizeof(op->data.mpi.dest));
index += sizeof(op->data.mpi.dest);

bcopy (&(op->data.mpi.tag), &buf[index], sizeof(op->data.mpi.tag));
index += sizeof(op->data.mpi.tag);

bcopy (&(op->data.mpi.comm), &buf[index], sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

bcopy (&(op->data.mpi.request), &buf[index], sizeof(op->data.mpi.request));
index += sizeof(op->data.mpi.request);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Ssend_init */


int umpi_pack_op_size_MPI_Ssend_init(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.buf)+sizeof(op->data.mpi.count)+sizeof(op->data.mpi.datatype)+sizeof(op->data.mpi.dest)+sizeof(op->data.mpi.tag)+sizeof(op->data.mpi.comm)+sizeof(op->data.mpi.request);
} /* umpi_pack_op_size_MPI_Ssend_init */


int umpi_pack_op_MPI_Start(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Start(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.request), &buf[index], sizeof(op->data.mpi.request));
index += sizeof(op->data.mpi.request);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Start */


int umpi_pack_op_size_MPI_Start(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.request);
} /* umpi_pack_op_size_MPI_Start */


int umpi_pack_op_MPI_Startall(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Startall(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.count), &buf[index], sizeof(op->data.mpi.count));
index += sizeof(op->data.mpi.count);

temp = op->data.mpi.count;
bcopy (&(temp), &buf[index], sizeof(int));
index += sizeof(int);

if (temp) {
bcopy (op->data.mpi.array_of_requests, &buf[index], sizeof(op->data.mpi.array_of_requests[0])*temp);
index += (sizeof(op->data.mpi.array_of_requests[0])*temp);
}

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Startall */


int umpi_pack_op_size_MPI_Startall(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.count)+sizeof(op->data.mpi.count)+(op->data.mpi.count*sizeof(op->data.mpi.array_of_requests[0]));
} /* umpi_pack_op_size_MPI_Startall */


int umpi_pack_op_MPI_Status_c2f(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Status_c2f(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.c_status), &buf[index], sizeof(op->data.mpi.c_status));
index += sizeof(op->data.mpi.c_status);

bcopy (&(op->data.mpi.f_status), &buf[index], sizeof(op->data.mpi.f_status));
index += sizeof(op->data.mpi.f_status);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Status_c2f */


int umpi_pack_op_size_MPI_Status_c2f(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.c_status)+sizeof(op->data.mpi.f_status);
} /* umpi_pack_op_size_MPI_Status_c2f */


int umpi_pack_op_MPI_Status_f2c(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Status_f2c(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.f_status), &buf[index], sizeof(op->data.mpi.f_status));
index += sizeof(op->data.mpi.f_status);

bcopy (&(op->data.mpi.c_status), &buf[index], sizeof(op->data.mpi.c_status));
index += sizeof(op->data.mpi.c_status);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Status_f2c */


int umpi_pack_op_size_MPI_Status_f2c(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.f_status)+sizeof(op->data.mpi.c_status);
} /* umpi_pack_op_size_MPI_Status_f2c */


int umpi_pack_op_MPI_Test(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Test(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.request), &buf[index], sizeof(op->data.mpi.request));
index += sizeof(op->data.mpi.request);

bcopy (&(op->data.mpi.flag), &buf[index], sizeof(op->data.mpi.flag));
index += sizeof(op->data.mpi.flag);

bcopy (&(op->data.mpi.status_src), &buf[index], sizeof(op->data.mpi.status_src));
index += sizeof(op->data.mpi.status_src);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Test */


int umpi_pack_op_size_MPI_Test(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.request)+sizeof(op->data.mpi.flag)+sizeof(op->data.mpi.status_src);
} /* umpi_pack_op_size_MPI_Test */


int umpi_pack_op_MPI_Test_cancelled(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Test_cancelled(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.status_src), &buf[index], sizeof(op->data.mpi.status_src));
index += sizeof(op->data.mpi.status_src);

bcopy (&(op->data.mpi.flag), &buf[index], sizeof(op->data.mpi.flag));
index += sizeof(op->data.mpi.flag);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Test_cancelled */


int umpi_pack_op_size_MPI_Test_cancelled(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.status_src)+sizeof(op->data.mpi.flag);
} /* umpi_pack_op_size_MPI_Test_cancelled */


int umpi_pack_op_MPI_Testall(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Testall(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.count), &buf[index], sizeof(op->data.mpi.count));
index += sizeof(op->data.mpi.count);

temp = op->data.mpi.count;
bcopy (&(temp), &buf[index], sizeof(int));
index += sizeof(int);

if (temp) {
bcopy (op->data.mpi.array_of_requests, &buf[index], sizeof(op->data.mpi.array_of_requests[0])*temp);
index += (sizeof(op->data.mpi.array_of_requests[0])*temp);
}

bcopy (&(op->data.mpi.flag), &buf[index], sizeof(op->data.mpi.flag));
index += sizeof(op->data.mpi.flag);

temp = op->data.mpi.count;
bcopy (&(temp), &buf[index], sizeof(int));
index += sizeof(int);

if (temp) {
bcopy (op->data.mpi.statuses_srcs, &buf[index], sizeof(op->data.mpi.statuses_srcs[0])*temp);
index += (sizeof(op->data.mpi.statuses_srcs[0])*temp);
}

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Testall */


int umpi_pack_op_size_MPI_Testall(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.count)+sizeof(op->data.mpi.count)+(op->data.mpi.count*sizeof(op->data.mpi.array_of_requests[0]))+sizeof(op->data.mpi.flag)+sizeof(op->data.mpi.count)+(op->data.mpi.count*sizeof(op->data.mpi.statuses_srcs[0]));
} /* umpi_pack_op_size_MPI_Testall */


int umpi_pack_op_MPI_Testany(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Testany(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.count), &buf[index], sizeof(op->data.mpi.count));
index += sizeof(op->data.mpi.count);

temp = op->data.mpi.count;
bcopy (&(temp), &buf[index], sizeof(int));
index += sizeof(int);

if (temp) {
bcopy (op->data.mpi.array_of_requests, &buf[index], sizeof(op->data.mpi.array_of_requests[0])*temp);
index += (sizeof(op->data.mpi.array_of_requests[0])*temp);
}

bcopy (&(op->data.mpi.index), &buf[index], sizeof(op->data.mpi.index));
index += sizeof(op->data.mpi.index);

bcopy (&(op->data.mpi.flag), &buf[index], sizeof(op->data.mpi.flag));
index += sizeof(op->data.mpi.flag);

bcopy (&(op->data.mpi.status_src), &buf[index], sizeof(op->data.mpi.status_src));
index += sizeof(op->data.mpi.status_src);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Testany */


int umpi_pack_op_size_MPI_Testany(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.count)+sizeof(op->data.mpi.count)+(op->data.mpi.count*sizeof(op->data.mpi.array_of_requests[0]))+sizeof(op->data.mpi.index)+sizeof(op->data.mpi.flag)+sizeof(op->data.mpi.status_src);
} /* umpi_pack_op_size_MPI_Testany */


int umpi_pack_op_MPI_Testsome(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Testsome(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.count), &buf[index], sizeof(op->data.mpi.count));
index += sizeof(op->data.mpi.count);

temp = op->data.mpi.count;
bcopy (&(temp), &buf[index], sizeof(int));
index += sizeof(int);

if (temp) {
bcopy (op->data.mpi.array_of_requests, &buf[index], sizeof(op->data.mpi.array_of_requests[0])*temp);
index += (sizeof(op->data.mpi.array_of_requests[0])*temp);
}

bcopy (&(op->data.mpi.outcount), &buf[index], sizeof(op->data.mpi.outcount));
index += sizeof(op->data.mpi.outcount);

temp = op->data.mpi.count;
bcopy (&(temp), &buf[index], sizeof(int));
index += sizeof(int);

if (temp) {
bcopy (op->data.mpi.array_of_indices, &buf[index], sizeof(op->data.mpi.array_of_indices[0])*temp);
index += (sizeof(op->data.mpi.array_of_indices[0])*temp);
}

temp = op->data.mpi.count;
bcopy (&(temp), &buf[index], sizeof(int));
index += sizeof(int);

if (temp) {
bcopy (op->data.mpi.statuses_srcs, &buf[index], sizeof(op->data.mpi.statuses_srcs[0])*temp);
index += (sizeof(op->data.mpi.statuses_srcs[0])*temp);
}

bcopy (&(op->data.mpi.flag), &buf[index], sizeof(op->data.mpi.flag));
index += sizeof(op->data.mpi.flag);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Testsome */


int umpi_pack_op_size_MPI_Testsome(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.count)+sizeof(op->data.mpi.count)+(op->data.mpi.count*sizeof(op->data.mpi.array_of_requests[0]))+sizeof(op->data.mpi.outcount)+sizeof(op->data.mpi.count)+(op->data.mpi.count*sizeof(op->data.mpi.array_of_indices[0]))+sizeof(op->data.mpi.count)+(op->data.mpi.count*sizeof(op->data.mpi.statuses_srcs[0]))+sizeof(op->data.mpi.flag);
} /* umpi_pack_op_size_MPI_Testsome */


int umpi_pack_op_MPI_Topo_test(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Topo_test(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.comm), &buf[index], sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

bcopy (&(op->data.mpi.top_type), &buf[index], sizeof(op->data.mpi.top_type));
index += sizeof(op->data.mpi.top_type);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Topo_test */


int umpi_pack_op_size_MPI_Topo_test(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.comm)+sizeof(op->data.mpi.top_type);
} /* umpi_pack_op_size_MPI_Topo_test */


int umpi_pack_op_MPI_Type_commit(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Type_commit(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.newtype), &buf[index], sizeof(op->data.mpi.newtype));
index += sizeof(op->data.mpi.newtype);

//umpi_pack_typemap (buf, op->themap, &index);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Type_commit */


int umpi_pack_op_size_MPI_Type_commit(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.newtype)+0;
} /* umpi_pack_op_size_MPI_Type_commit */


int umpi_pack_op_MPI_Type_contiguous(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Type_contiguous(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.count), &buf[index], sizeof(op->data.mpi.count));
index += sizeof(op->data.mpi.count);

bcopy (&(op->data.mpi.old_type), &buf[index], sizeof(op->data.mpi.old_type));
index += sizeof(op->data.mpi.old_type);

bcopy (&(op->data.mpi.newtype), &buf[index], sizeof(op->data.mpi.newtype));
index += sizeof(op->data.mpi.newtype);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Type_contiguous */


int umpi_pack_op_size_MPI_Type_contiguous(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.count)+sizeof(op->data.mpi.old_type)+sizeof(op->data.mpi.newtype);
} /* umpi_pack_op_size_MPI_Type_contiguous */


int umpi_pack_op_MPI_Type_count(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Type_count(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.datatype), &buf[index], sizeof(op->data.mpi.datatype));
index += sizeof(op->data.mpi.datatype);

bcopy (&(op->data.mpi.count), &buf[index], sizeof(op->data.mpi.count));
index += sizeof(op->data.mpi.count);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Type_count */


int umpi_pack_op_size_MPI_Type_count(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.datatype)+sizeof(op->data.mpi.count);
} /* umpi_pack_op_size_MPI_Type_count */


int umpi_pack_op_MPI_Type_create_darray(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Type_create_darray(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.size), &buf[index], sizeof(op->data.mpi.size));
index += sizeof(op->data.mpi.size);

bcopy (&(op->data.mpi.rank), &buf[index], sizeof(op->data.mpi.rank));
index += sizeof(op->data.mpi.rank);

bcopy (&(op->data.mpi.count), &buf[index], sizeof(op->data.mpi.count));
index += sizeof(op->data.mpi.count);

temp = op->data.mpi.count;
bcopy (&(temp), &buf[index], sizeof(int));
index += sizeof(int);

if (temp) {
bcopy (op->data.mpi.array_of_gsizes, &buf[index], sizeof(op->data.mpi.array_of_gsizes[0])*temp);
index += (sizeof(op->data.mpi.array_of_gsizes[0])*temp);
}

temp = op->data.mpi.count;
bcopy (&(temp), &buf[index], sizeof(int));
index += sizeof(int);

if (temp) {
bcopy (op->data.mpi.array_of_distribs, &buf[index], sizeof(op->data.mpi.array_of_distribs[0])*temp);
index += (sizeof(op->data.mpi.array_of_distribs[0])*temp);
}

temp = op->data.mpi.count;
bcopy (&(temp), &buf[index], sizeof(int));
index += sizeof(int);

if (temp) {
bcopy (op->data.mpi.array_of_dargs, &buf[index], sizeof(op->data.mpi.array_of_dargs[0])*temp);
index += (sizeof(op->data.mpi.array_of_dargs[0])*temp);
}

temp = op->data.mpi.count;
bcopy (&(temp), &buf[index], sizeof(int));
index += sizeof(int);

if (temp) {
bcopy (op->data.mpi.array_of_psizes, &buf[index], sizeof(op->data.mpi.array_of_psizes[0])*temp);
index += (sizeof(op->data.mpi.array_of_psizes[0])*temp);
}

bcopy (&(op->data.mpi.order), &buf[index], sizeof(op->data.mpi.order));
index += sizeof(op->data.mpi.order);

bcopy (&(op->data.mpi.datatype), &buf[index], sizeof(op->data.mpi.datatype));
index += sizeof(op->data.mpi.datatype);

bcopy (&(op->data.mpi.newtype), &buf[index], sizeof(op->data.mpi.newtype));
index += sizeof(op->data.mpi.newtype);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Type_create_darray */


int umpi_pack_op_size_MPI_Type_create_darray(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.size)+sizeof(op->data.mpi.rank)+sizeof(op->data.mpi.count)+sizeof(op->data.mpi.count)+(op->data.mpi.count*sizeof(op->data.mpi.array_of_gsizes[0]))+sizeof(op->data.mpi.count)+(op->data.mpi.count*sizeof(op->data.mpi.array_of_distribs[0]))+sizeof(op->data.mpi.count)+(op->data.mpi.count*sizeof(op->data.mpi.array_of_dargs[0]))+sizeof(op->data.mpi.count)+(op->data.mpi.count*sizeof(op->data.mpi.array_of_psizes[0]))+sizeof(op->data.mpi.order)+sizeof(op->data.mpi.datatype)+sizeof(op->data.mpi.newtype);
} /* umpi_pack_op_size_MPI_Type_create_darray */


int umpi_pack_op_MPI_Type_create_indexed_block(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Type_create_indexed_block(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.count), &buf[index], sizeof(op->data.mpi.count));
index += sizeof(op->data.mpi.count);

bcopy (&(op->data.mpi.blocklength), &buf[index], sizeof(op->data.mpi.blocklength));
index += sizeof(op->data.mpi.blocklength);

temp = op->data.mpi.count;
bcopy (&(temp), &buf[index], sizeof(int));
index += sizeof(int);

if (temp) {
bcopy (op->data.mpi.array_of_displacements, &buf[index], sizeof(op->data.mpi.array_of_displacements[0])*temp);
index += (sizeof(op->data.mpi.array_of_displacements[0])*temp);
}

bcopy (&(op->data.mpi.datatype), &buf[index], sizeof(op->data.mpi.datatype));
index += sizeof(op->data.mpi.datatype);

bcopy (&(op->data.mpi.newtype), &buf[index], sizeof(op->data.mpi.newtype));
index += sizeof(op->data.mpi.newtype);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Type_create_indexed_block */


int umpi_pack_op_size_MPI_Type_create_indexed_block(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.count)+sizeof(op->data.mpi.blocklength)+sizeof(op->data.mpi.count)+(op->data.mpi.count*sizeof(op->data.mpi.array_of_displacements[0]))+sizeof(op->data.mpi.datatype)+sizeof(op->data.mpi.newtype);
} /* umpi_pack_op_size_MPI_Type_create_indexed_block */


int umpi_pack_op_MPI_Type_create_subarray(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Type_create_subarray(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.count), &buf[index], sizeof(op->data.mpi.count));
index += sizeof(op->data.mpi.count);

temp = op->data.mpi.count;
bcopy (&(temp), &buf[index], sizeof(int));
index += sizeof(int);

if (temp) {
bcopy (op->data.mpi.array_of_sizes, &buf[index], sizeof(op->data.mpi.array_of_sizes[0])*temp);
index += (sizeof(op->data.mpi.array_of_sizes[0])*temp);
}

temp = op->data.mpi.count;
bcopy (&(temp), &buf[index], sizeof(int));
index += sizeof(int);

if (temp) {
bcopy (op->data.mpi.array_of_subsizes, &buf[index], sizeof(op->data.mpi.array_of_subsizes[0])*temp);
index += (sizeof(op->data.mpi.array_of_subsizes[0])*temp);
}

temp = op->data.mpi.count;
bcopy (&(temp), &buf[index], sizeof(int));
index += sizeof(int);

if (temp) {
bcopy (op->data.mpi.array_of_starts, &buf[index], sizeof(op->data.mpi.array_of_starts[0])*temp);
index += (sizeof(op->data.mpi.array_of_starts[0])*temp);
}

bcopy (&(op->data.mpi.order), &buf[index], sizeof(op->data.mpi.order));
index += sizeof(op->data.mpi.order);

bcopy (&(op->data.mpi.datatype), &buf[index], sizeof(op->data.mpi.datatype));
index += sizeof(op->data.mpi.datatype);

bcopy (&(op->data.mpi.newtype), &buf[index], sizeof(op->data.mpi.newtype));
index += sizeof(op->data.mpi.newtype);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Type_create_subarray */


int umpi_pack_op_size_MPI_Type_create_subarray(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.count)+sizeof(op->data.mpi.count)+(op->data.mpi.count*sizeof(op->data.mpi.array_of_sizes[0]))+sizeof(op->data.mpi.count)+(op->data.mpi.count*sizeof(op->data.mpi.array_of_subsizes[0]))+sizeof(op->data.mpi.count)+(op->data.mpi.count*sizeof(op->data.mpi.array_of_starts[0]))+sizeof(op->data.mpi.order)+sizeof(op->data.mpi.datatype)+sizeof(op->data.mpi.newtype);
} /* umpi_pack_op_size_MPI_Type_create_subarray */


int umpi_pack_op_MPI_Type_extent(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Type_extent(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.datatype), &buf[index], sizeof(op->data.mpi.datatype));
index += sizeof(op->data.mpi.datatype);

bcopy (&(op->data.mpi.extent), &buf[index], sizeof(op->data.mpi.extent));
index += sizeof(op->data.mpi.extent);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Type_extent */


int umpi_pack_op_size_MPI_Type_extent(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.datatype)+sizeof(op->data.mpi.extent);
} /* umpi_pack_op_size_MPI_Type_extent */


int umpi_pack_op_MPI_Type_free(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Type_free(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.newtype), &buf[index], sizeof(op->data.mpi.newtype));
index += sizeof(op->data.mpi.newtype);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Type_free */


int umpi_pack_op_size_MPI_Type_free(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.newtype);
} /* umpi_pack_op_size_MPI_Type_free */


int umpi_pack_op_MPI_Type_get_contents(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Type_get_contents(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.datatype), &buf[index], sizeof(op->data.mpi.datatype));
index += sizeof(op->data.mpi.datatype);

bcopy (&(op->data.mpi.count), &buf[index], sizeof(op->data.mpi.count));
index += sizeof(op->data.mpi.count);

bcopy (&(op->data.mpi.addrcount), &buf[index], sizeof(op->data.mpi.addrcount));
index += sizeof(op->data.mpi.addrcount);

bcopy (&(op->data.mpi.dtypecount), &buf[index], sizeof(op->data.mpi.dtypecount));
index += sizeof(op->data.mpi.dtypecount);

temp = op->data.mpi.count;
bcopy (&(temp), &buf[index], sizeof(int));
index += sizeof(int);

if (temp) {
bcopy (op->data.mpi.array_of_integers, &buf[index], sizeof(op->data.mpi.array_of_integers[0])*temp);
index += (sizeof(op->data.mpi.array_of_integers[0])*temp);
}

temp = op->data.mpi.addrcount;
bcopy (&(temp), &buf[index], sizeof(int));
index += sizeof(int);

if (temp) {
bcopy (op->data.mpi.the_addresses, &buf[index], sizeof(op->data.mpi.the_addresses[0])*temp);
index += (sizeof(op->data.mpi.the_addresses[0])*temp);
}

temp = op->data.mpi.dtypecount;
bcopy (&(temp), &buf[index], sizeof(int));
index += sizeof(int);

if (temp) {
bcopy (op->data.mpi.the_datatypes, &buf[index], sizeof(op->data.mpi.the_datatypes[0])*temp);
index += (sizeof(op->data.mpi.the_datatypes[0])*temp);
}

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Type_get_contents */


int umpi_pack_op_size_MPI_Type_get_contents(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.datatype)+sizeof(op->data.mpi.count)+sizeof(op->data.mpi.addrcount)+sizeof(op->data.mpi.dtypecount)+sizeof(op->data.mpi.count)+(op->data.mpi.count*sizeof(op->data.mpi.array_of_integers[0]))+sizeof(op->data.mpi.addrcount)+(op->data.mpi.addrcount*sizeof(op->data.mpi.the_addresses[0]))+sizeof(op->data.mpi.dtypecount)+(op->data.mpi.dtypecount*sizeof(op->data.mpi.the_datatypes[0]));
} /* umpi_pack_op_size_MPI_Type_get_contents */


int umpi_pack_op_MPI_Type_get_envelope(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Type_get_envelope(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.datatype), &buf[index], sizeof(op->data.mpi.datatype));
index += sizeof(op->data.mpi.datatype);

bcopy (&(op->data.mpi.num_integers), &buf[index], sizeof(op->data.mpi.num_integers));
index += sizeof(op->data.mpi.num_integers);

bcopy (&(op->data.mpi.num_addresses), &buf[index], sizeof(op->data.mpi.num_addresses));
index += sizeof(op->data.mpi.num_addresses);

bcopy (&(op->data.mpi.num_datatypes), &buf[index], sizeof(op->data.mpi.num_datatypes));
index += sizeof(op->data.mpi.num_datatypes);

bcopy (&(op->data.mpi.combiner), &buf[index], sizeof(op->data.mpi.combiner));
index += sizeof(op->data.mpi.combiner);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Type_get_envelope */


int umpi_pack_op_size_MPI_Type_get_envelope(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.datatype)+sizeof(op->data.mpi.num_integers)+sizeof(op->data.mpi.num_addresses)+sizeof(op->data.mpi.num_datatypes)+sizeof(op->data.mpi.combiner);
} /* umpi_pack_op_size_MPI_Type_get_envelope */


int umpi_pack_op_MPI_Type_hindexed(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Type_hindexed(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.count), &buf[index], sizeof(op->data.mpi.count));
index += sizeof(op->data.mpi.count);

temp = op->data.mpi.count;
bcopy (&(temp), &buf[index], sizeof(int));
index += sizeof(int);

if (temp) {
bcopy (op->data.mpi.array_of_blocklens, &buf[index], sizeof(op->data.mpi.array_of_blocklens[0])*temp);
index += (sizeof(op->data.mpi.array_of_blocklens[0])*temp);
}

temp = op->data.mpi.count;
bcopy (&(temp), &buf[index], sizeof(int));
index += sizeof(int);

if (temp) {
bcopy (op->data.mpi.array_of_displacements, &buf[index], sizeof(op->data.mpi.array_of_displacements[0])*temp);
index += (sizeof(op->data.mpi.array_of_displacements[0])*temp);
}

bcopy (&(op->data.mpi.datatype), &buf[index], sizeof(op->data.mpi.datatype));
index += sizeof(op->data.mpi.datatype);

bcopy (&(op->data.mpi.newtype), &buf[index], sizeof(op->data.mpi.newtype));
index += sizeof(op->data.mpi.newtype);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Type_hindexed */


int umpi_pack_op_size_MPI_Type_hindexed(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.count)+sizeof(op->data.mpi.count)+(op->data.mpi.count*sizeof(op->data.mpi.array_of_blocklens[0]))+sizeof(op->data.mpi.count)+(op->data.mpi.count*sizeof(op->data.mpi.array_of_displacements[0]))+sizeof(op->data.mpi.datatype)+sizeof(op->data.mpi.newtype);
} /* umpi_pack_op_size_MPI_Type_hindexed */


int umpi_pack_op_MPI_Type_hvector(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Type_hvector(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.count), &buf[index], sizeof(op->data.mpi.count));
index += sizeof(op->data.mpi.count);

bcopy (&(op->data.mpi.blocklen), &buf[index], sizeof(op->data.mpi.blocklen));
index += sizeof(op->data.mpi.blocklen);

bcopy (&(op->data.mpi.stride), &buf[index], sizeof(op->data.mpi.stride));
index += sizeof(op->data.mpi.stride);

bcopy (&(op->data.mpi.datatype), &buf[index], sizeof(op->data.mpi.datatype));
index += sizeof(op->data.mpi.datatype);

bcopy (&(op->data.mpi.newtype), &buf[index], sizeof(op->data.mpi.newtype));
index += sizeof(op->data.mpi.newtype);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Type_hvector */


int umpi_pack_op_size_MPI_Type_hvector(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.count)+sizeof(op->data.mpi.blocklen)+sizeof(op->data.mpi.stride)+sizeof(op->data.mpi.datatype)+sizeof(op->data.mpi.newtype);
} /* umpi_pack_op_size_MPI_Type_hvector */


int umpi_pack_op_MPI_Type_indexed(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Type_indexed(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.count), &buf[index], sizeof(op->data.mpi.count));
index += sizeof(op->data.mpi.count);

temp = op->data.mpi.count;
bcopy (&(temp), &buf[index], sizeof(int));
index += sizeof(int);

if (temp) {
bcopy (op->data.mpi.array_of_blocklens, &buf[index], sizeof(op->data.mpi.array_of_blocklens[0])*temp);
index += (sizeof(op->data.mpi.array_of_blocklens[0])*temp);
}

temp = op->data.mpi.count;
bcopy (&(temp), &buf[index], sizeof(int));
index += sizeof(int);

if (temp) {
bcopy (op->data.mpi.array_of_displacements, &buf[index], sizeof(op->data.mpi.array_of_displacements[0])*temp);
index += (sizeof(op->data.mpi.array_of_displacements[0])*temp);
}

bcopy (&(op->data.mpi.datatype), &buf[index], sizeof(op->data.mpi.datatype));
index += sizeof(op->data.mpi.datatype);

bcopy (&(op->data.mpi.newtype), &buf[index], sizeof(op->data.mpi.newtype));
index += sizeof(op->data.mpi.newtype);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Type_indexed */


int umpi_pack_op_size_MPI_Type_indexed(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.count)+sizeof(op->data.mpi.count)+(op->data.mpi.count*sizeof(op->data.mpi.array_of_blocklens[0]))+sizeof(op->data.mpi.count)+(op->data.mpi.count*sizeof(op->data.mpi.array_of_displacements[0]))+sizeof(op->data.mpi.datatype)+sizeof(op->data.mpi.newtype);
} /* umpi_pack_op_size_MPI_Type_indexed */


int umpi_pack_op_MPI_Type_lb(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Type_lb(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.datatype), &buf[index], sizeof(op->data.mpi.datatype));
index += sizeof(op->data.mpi.datatype);

bcopy (&(op->data.mpi.displacement), &buf[index], sizeof(op->data.mpi.displacement));
index += sizeof(op->data.mpi.displacement);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Type_lb */


int umpi_pack_op_size_MPI_Type_lb(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.datatype)+sizeof(op->data.mpi.displacement);
} /* umpi_pack_op_size_MPI_Type_lb */


int umpi_pack_op_MPI_Type_size(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Type_size(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.datatype), &buf[index], sizeof(op->data.mpi.datatype));
index += sizeof(op->data.mpi.datatype);

bcopy (&(op->data.mpi.size), &buf[index], sizeof(op->data.mpi.size));
index += sizeof(op->data.mpi.size);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Type_size */


int umpi_pack_op_size_MPI_Type_size(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.datatype)+sizeof(op->data.mpi.size);
} /* umpi_pack_op_size_MPI_Type_size */


int umpi_pack_op_MPI_Type_struct(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Type_struct(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.count), &buf[index], sizeof(op->data.mpi.count));
index += sizeof(op->data.mpi.count);

temp = op->data.mpi.count;
bcopy (&(temp), &buf[index], sizeof(int));
index += sizeof(int);

if (temp) {
bcopy (op->data.mpi.array_of_blocklens, &buf[index], sizeof(op->data.mpi.array_of_blocklens[0])*temp);
index += (sizeof(op->data.mpi.array_of_blocklens[0])*temp);
}

temp = op->data.mpi.count;
bcopy (&(temp), &buf[index], sizeof(int));
index += sizeof(int);

if (temp) {
bcopy (op->data.mpi.array_of_displacements, &buf[index], sizeof(op->data.mpi.array_of_displacements[0])*temp);
index += (sizeof(op->data.mpi.array_of_displacements[0])*temp);
}

temp = op->data.mpi.count;
bcopy (&(temp), &buf[index], sizeof(int));
index += sizeof(int);

if (temp) {
bcopy (op->data.mpi.array_of_types, &buf[index], sizeof(op->data.mpi.array_of_types[0])*temp);
index += (sizeof(op->data.mpi.array_of_types[0])*temp);
}

bcopy (&(op->data.mpi.newtype), &buf[index], sizeof(op->data.mpi.newtype));
index += sizeof(op->data.mpi.newtype);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Type_struct */


int umpi_pack_op_size_MPI_Type_struct(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.count)+sizeof(op->data.mpi.count)+(op->data.mpi.count*sizeof(op->data.mpi.array_of_blocklens[0]))+sizeof(op->data.mpi.count)+(op->data.mpi.count*sizeof(op->data.mpi.array_of_displacements[0]))+sizeof(op->data.mpi.count)+(op->data.mpi.count*sizeof(op->data.mpi.array_of_types[0]))+sizeof(op->data.mpi.newtype);
} /* umpi_pack_op_size_MPI_Type_struct */


int umpi_pack_op_MPI_Type_ub(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Type_ub(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.datatype), &buf[index], sizeof(op->data.mpi.datatype));
index += sizeof(op->data.mpi.datatype);

bcopy (&(op->data.mpi.displacement), &buf[index], sizeof(op->data.mpi.displacement));
index += sizeof(op->data.mpi.displacement);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Type_ub */


int umpi_pack_op_size_MPI_Type_ub(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.datatype)+sizeof(op->data.mpi.displacement);
} /* umpi_pack_op_size_MPI_Type_ub */


int umpi_pack_op_MPI_Type_vector(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Type_vector(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.count), &buf[index], sizeof(op->data.mpi.count));
index += sizeof(op->data.mpi.count);

bcopy (&(op->data.mpi.blocklen), &buf[index], sizeof(op->data.mpi.blocklen));
index += sizeof(op->data.mpi.blocklen);

bcopy (&(op->data.mpi.stride), &buf[index], sizeof(op->data.mpi.stride));
index += sizeof(op->data.mpi.stride);

bcopy (&(op->data.mpi.datatype), &buf[index], sizeof(op->data.mpi.datatype));
index += sizeof(op->data.mpi.datatype);

bcopy (&(op->data.mpi.newtype), &buf[index], sizeof(op->data.mpi.newtype));
index += sizeof(op->data.mpi.newtype);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Type_vector */


int umpi_pack_op_size_MPI_Type_vector(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.count)+sizeof(op->data.mpi.blocklen)+sizeof(op->data.mpi.stride)+sizeof(op->data.mpi.datatype)+sizeof(op->data.mpi.newtype);
} /* umpi_pack_op_size_MPI_Type_vector */


int umpi_pack_op_MPI_Unpack(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Unpack(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.inbuf), &buf[index], sizeof(op->data.mpi.inbuf));
index += sizeof(op->data.mpi.inbuf);

bcopy (&(op->data.mpi.insize), &buf[index], sizeof(op->data.mpi.insize));
index += sizeof(op->data.mpi.insize);

bcopy (&(op->data.mpi.position), &buf[index], sizeof(op->data.mpi.position));
index += sizeof(op->data.mpi.position);

bcopy (&(op->data.mpi.outbuf), &buf[index], sizeof(op->data.mpi.outbuf));
index += sizeof(op->data.mpi.outbuf);

bcopy (&(op->data.mpi.outcount), &buf[index], sizeof(op->data.mpi.outcount));
index += sizeof(op->data.mpi.outcount);

bcopy (&(op->data.mpi.datatype), &buf[index], sizeof(op->data.mpi.datatype));
index += sizeof(op->data.mpi.datatype);

bcopy (&(op->data.mpi.comm), &buf[index], sizeof(op->data.mpi.comm));
index += sizeof(op->data.mpi.comm);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Unpack */


int umpi_pack_op_size_MPI_Unpack(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.inbuf)+sizeof(op->data.mpi.insize)+sizeof(op->data.mpi.position)+sizeof(op->data.mpi.outbuf)+sizeof(op->data.mpi.outcount)+sizeof(op->data.mpi.datatype)+sizeof(op->data.mpi.comm);
} /* umpi_pack_op_size_MPI_Unpack */


int umpi_pack_op_MPI_Wait(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Wait(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.request), &buf[index], sizeof(op->data.mpi.request));
index += sizeof(op->data.mpi.request);

bcopy (&(op->data.mpi.status_src), &buf[index], sizeof(op->data.mpi.status_src));
index += sizeof(op->data.mpi.status_src);

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Wait */


int umpi_pack_op_size_MPI_Wait(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.request)+sizeof(op->data.mpi.status_src);
} /* umpi_pack_op_size_MPI_Wait */


int umpi_pack_op_MPI_Waitall(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Waitall(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.count), &buf[index], sizeof(op->data.mpi.count));
index += sizeof(op->data.mpi.count);

temp = op->data.mpi.count;
bcopy (&(temp), &buf[index], sizeof(int));
index += sizeof(int);

if (temp) {
bcopy (op->data.mpi.array_of_requests, &buf[index], sizeof(op->data.mpi.array_of_requests[0])*temp);
index += (sizeof(op->data.mpi.array_of_requests[0])*temp);
}

temp = op->data.mpi.count;
bcopy (&(temp), &buf[index], sizeof(int));
index += sizeof(int);

if (temp) {
bcopy (op->data.mpi.statuses_srcs, &buf[index], sizeof(op->data.mpi.statuses_srcs[0])*temp);
index += (sizeof(op->data.mpi.statuses_srcs[0])*temp);
}

assert (index == (packed_size - sizeof(int)));
temp = UMPI_END_PACKED_OP;
bcopy (&temp, &buf[index], sizeof(int));

return UMPIERR_OK;
} /* umpi_pack_op_MPI_Waitall */


int umpi_pack_op_size_MPI_Waitall(umpi_op_t*op)
{
return 3*sizeof(int)+sizeof(op->op)+sizeof(op->order)+sizeof(op->rank)+sizeof(op->pc)+sizeof(op->seq_num)+sizeof(op->data.mpi.count)+sizeof(op->data.mpi.count)+(op->data.mpi.count*sizeof(op->data.mpi.array_of_requests[0]))+sizeof(op->data.mpi.count)+(op->data.mpi.count*sizeof(op->data.mpi.statuses_srcs[0]));
} /* umpi_pack_op_size_MPI_Waitall */


int umpi_pack_op_MPI_Waitany(umpi_op_t*op,char *buf,int maxlen)
{
int index, temp = UMPI_START_PACKED_OP;
int packed_size = umpi_pack_op_size_MPI_Waitany(op);

assert(op);
assert(buf);
if (maxlen < packed_size)
return UMPIERR_INSUFFICIENT_BUF;

bcopy (&temp, buf, sizeof(int));
index = sizeof(int);

bcopy (&packed_size, &buf[index], sizeof(int));
index += sizeof(int);

bcopy (&(op->op), &buf[index], sizeof(op->op));
index += sizeof(op->op);

bcopy (&(op->order), &buf[index], sizeof(op->order));
index += sizeof(op->order);

bcopy (&(op->rank), &buf[index], sizeof(op->rank));
index += sizeof(op->rank);

bcopy (&(op->pc), &buf[index], sizeof(op->pc));
index += sizeof(op->pc);

bcopy (&(op->seq_num), &buf[index], sizeof(op->seq_num));
index += sizeof(op->seq_num);

bcopy (&(op->data.mpi.count), &buf[index], sizeof(op->data.mpi.count));
index += sizeof(op->data.mpi.count);

temp = op->data.mpi.count;
bcopy (&(temp), &buf[index], sizeof(int));
index += sizeof(int);

if (temp) {
bcopy (op->data.mpi.array_of_requests, &buf[index], sizeof(op->data.mpi.array_of_requests[0])*temp);
index += (sizeof(op->data.mpi.array_of_requests[0])*temp);
}

bcopy (&(op->data.mpi