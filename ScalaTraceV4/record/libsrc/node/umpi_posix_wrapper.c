/* Umpire wrappers for all traceable POSIX functions */

/* !!!!! This file is automatically generated by a wrapper-engine !!!!! */

#include <setjmp.h>
#include <errno.h>
#include <sys/types.h>
#include <stdio.h>
#include "umpi_internal.h"

#include "umpi_pc.h"


#include "Event.h"
#include "Trace.h"
#include "PtrHandler.h"
#include "ReqHandler.h"
#include "radix_tree.h"

#include "mpi_util.h"

#include <sys/time.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <fcntl.h>
#include <mpi.h>
int is_mpi_inited = 1;
extern int start_flag;
struct timeval IObegin, IOend;


/*--------------------------------------------- write */

extern ssize_t  __real_write(  int fd ,
		const void *buf ,
		size_t count );

static int
posix_write_immediate_local_pre(umpi_op_t *op)
{

{
{
	if(start_flag > 0){
		createEvent(&event, op->op, my_rank);
		recordStats(event, tailEvent(&trace), PHASE_COMP);
  #ifdef IO_COMM
		resetStats(event, PHASE_COMM);
  #endif
	}
}
}
return 0;
}


static int
posix_write_pre( 
void * pc , int fd ,
const void *buf ,
size_t count )

{
int rc = 0;
umpi_op_t *uop = (umpi_op_t *)calloc(sizeof(umpi_op_t), 1);

assert(uop);
uop->op = umpi_write;
uop->rank = umpi_rank;
uop->seq_num = umpi_task_seq_num++;
uop->pc = pc;
		uop->data.mpi.fd = fd;
uop->data.mpi.buf = (void*)buf;
		uop->data.mpi.count = count;
umpi_inc_ref_count (uop);
#ifdef UMPI_DEBUG_LEVEL_2
q_append (umpi_task_op_q, uop);
#endif

uop->order = umpi_preop;

rc = posix_write_immediate_local_pre(uop);
umpi_dec_ref_count (uop, UMPI_TASK_SYNCHRONOUS);
return 0;
}

static int
posix_write_immediate_local_post(umpi_op_t *op)
{

{
{
	#ifndef FEATURE_SKIP_IO
	if(start_flag > 0){
	  #ifdef IO_COMM
		recordStats(event, tailEvent(&trace), PHASE_COMM);
	  #endif
		addScalarValue(event, POSIX_FD, fds_handle_to_index(record_ptr, op->data.mpi.fd), my_rank);
		addScalarValue(event, COUNT, op->data.mpi.count, my_rank);
		if(!Issystem_io(op->data.mpi.fd) && fds_handle_to_index(record_ptr,op->data.mpi.fd)>=0)
			appendEvent(&trace, event);
		resetStats(headEvent(&trace), PHASE_COMP);
	}
	#endif
}
}
return 0;
}


static int
posix_write_post( 
int MPI_rc, 
void * pc , int fd ,
const void *buf ,
size_t count )

{
int rc = 0;
umpi_op_t *uop = (umpi_op_t *)calloc(sizeof(umpi_op_t), 1);

assert(uop);
uop->op = umpi_write;
uop->rank = umpi_rank;
uop->seq_num = umpi_task_seq_num++;
uop->pc = pc;
		uop->data.mpi.fd = fd;
uop->data.mpi.buf = (void*)buf;
		uop->data.mpi.count = count;
umpi_inc_ref_count (uop);
#ifdef UMPI_DEBUG_LEVEL_2
q_append (umpi_task_op_q, uop);
#endif

uop->order = umpi_postop;
uop->res = MPI_rc;

rc = posix_write_immediate_local_post(uop);
umpi_dec_ref_count (uop, UMPI_TASK_SYNCHRONOUS);
return rc;
}

static int
gwrap_write( 
void * pc , int fd ,
const void *buf ,
size_t count )
{
int rc;

if (is_mpi_inited)
posix_write_pre(pc,
			fd,
			buf,
			count);
	rc = __real_write(  (fd),
(buf),
(count));

if (is_mpi_inited)
posix_write_post(rc, pc,
			fd,
			buf,
			count);
	return rc;
}

extern ssize_t  __wrap_write(  int fd ,
		const void *buf ,
		size_t count )
{
	int rc = 0;
	void *pc = 0x0;
	GET_FP;
	//DEFINE_PC;
	//GATHER_PC;
	rc = gwrap_write(pc,
			fd,
			buf,
			count );
	return rc;
}

/*--------------------------------------------- read */

extern ssize_t  __real_read(  int fd ,
		void *buf ,
		size_t count );

static int
posix_read_immediate_local_pre(umpi_op_t *op)
{

{
{
	if(start_flag > 0){
		createEvent(&event, op->op, my_rank);
		recordStats(event, tailEvent(&trace), PHASE_COMP);
  #ifdef IO_COMM
		resetStats(event, PHASE_COMM);
  #endif
	}
}
}
return 0;
}


static int
posix_read_pre( 
void * pc , int fd ,
void *buf ,
size_t count )

{
int rc = 0;
umpi_op_t *uop = (umpi_op_t *)calloc(sizeof(umpi_op_t), 1);

assert(uop);
uop->op = umpi_read;
uop->rank = umpi_rank;
uop->seq_num = umpi_task_seq_num++;
uop->pc = pc;
		uop->data.mpi.fd = fd;
uop->data.mpi.buf = (void*)buf;
		uop->data.mpi.count = count;
umpi_inc_ref_count (uop);
#ifdef UMPI_DEBUG_LEVEL_2
q_append (umpi_task_op_q, uop);
#endif

uop->order = umpi_preop;

rc = posix_read_immediate_local_pre(uop);
umpi_dec_ref_count (uop, UMPI_TASK_SYNCHRONOUS);
return 0;
}

static int
posix_read_immediate_local_post(umpi_op_t *op)
{

{
{
	#ifndef FEATURE_SKIP_IO
	if(start_flag > 0){
	  #ifdef IO_COMM
		recordStats(event, tailEvent(&trace), PHASE_COMM);
	  #endif
		addScalarValue(event, POSIX_FD, fds_handle_to_index(record_ptr, op->data.mpi.fd), my_rank);
		addScalarValue(event, COUNT, op->data.mpi.count, my_rank);
		if(!Issystem_io(op->data.mpi.fd) && fds_handle_to_index(record_ptr, op->data.mpi.fd)>=0)
			appendEvent(&trace, event);
		resetStats(headEvent(&trace), PHASE_COMP);
	}
	#endif
}
}
return 0;
}


static int
posix_read_post( 
int MPI_rc, 
void * pc , int fd ,
void *buf ,
size_t count )

{
int rc = 0;
umpi_op_t *uop = (umpi_op_t *)calloc(sizeof(umpi_op_t), 1);

assert(uop);
uop->op = umpi_read;
uop->rank = umpi_rank;
uop->seq_num = umpi_task_seq_num++;
uop->pc = pc;
		uop->data.mpi.fd = fd;
uop->data.mpi.buf = (void*)buf;
		uop->data.mpi.count = count;
umpi_inc_ref_count (uop);
#ifdef UMPI_DEBUG_LEVEL_2
q_append (umpi_task_op_q, uop);
#endif

uop->order = umpi_postop;
uop->res = MPI_rc;

rc = posix_read_immediate_local_post(uop);
umpi_dec_ref_count (uop, UMPI_TASK_SYNCHRONOUS);
return rc;
}

static int
gwrap_read( 
void * pc , int fd ,
void *buf ,
size_t count )
{
int rc;

if (is_mpi_inited)
posix_read_pre(pc,
			fd,
			buf,
			count);
	rc = __real_read(  (fd),
(buf),
(count));

if (is_mpi_inited)
posix_read_post(rc, pc,
			fd,
			buf,
			count);
	return rc;
}

extern ssize_t  __wrap_read(  int fd ,
		void *buf ,
		size_t count )
{
	int rc = 0;
	void *pc = 0x0;
	GET_FP;
	//DEFINE_PC;
	//GATHER_PC;
	rc = gwrap_read(pc,
			fd,
			buf,
			count );
	return rc;
}

/*--------------------------------------------- open */

extern int  __real_open(  const char *filename ,
		int flags ,
		mode_t mode );

static int
posix_open_immediate_local_pre(umpi_op_t *op)
{

{
{
	if(start_flag > 0){
		createEvent(&event, op->op, my_rank);
		recordStats(event, tailEvent(&trace), PHASE_COMP);
  #ifdef IO_COMM
		resetStats(event, PHASE_COMM);
  #endif
	}
}
}
return 0;
}


static int
posix_open_pre( 
void * pc , const char *filename ,
int flags ,
mode_t mode )

{
int rc = 0;
umpi_op_t *uop = (umpi_op_t *)calloc(sizeof(umpi_op_t), 1);

assert(uop);
uop->op = umpi_open;
uop->rank = umpi_rank;
uop->seq_num = umpi_task_seq_num++;
uop->pc = pc;
uop->data.mpi.filename = (char *) malloc((strlen(filename)+1) * sizeof(char));
assert (uop->data.mpi.filename);
bcopy (filename, uop->data.mpi.filename, (strlen(filename)+1) * sizeof(char));
		uop->data.mpi.flags = flags;
		uop->data.mpi.mode = mode;
umpi_inc_ref_count (uop);
#ifdef UMPI_DEBUG_LEVEL_2
q_append (umpi_task_op_q, uop);
#endif

uop->order = umpi_preop;

rc = posix_open_immediate_local_pre(uop);
umpi_dec_ref_count (uop, UMPI_TASK_SYNCHRONOUS);
return 0;
}

static int
posix_open_immediate_local_post(umpi_op_t *op)
{

{
{
	#ifndef FEATURE_SKIP_IO
	if(start_flag > 0){
	  #ifdef IO_COMM
		recordStats(event, tailEvent(&trace), PHASE_COMM);
	  #endif
		if(!Issystem_open(op->data.mpi.filename)){
			add_fds_handle_entry(record_ptr, op->res);
			addScalarValue(event, POSIX_FLAGS, op->data.mpi.flags, my_rank);
			addScalarValue(event, POSIX_FD, fds_handle_to_index(record_ptr,op->res), my_rank);
			addCharValue(event, FILENAME,op->data.mpi.filename,my_rank);
			struct stat info;
			int offset = 0;
			stat(op->data.mpi.filename, &info);
			if(op->data.mpi.flags & O_APPEND == 1)
				offset = info.st_size;
			addScalarValue(event, OFFSET, offset, my_rank);
			addScalarValue(event, COUNTS, info.st_size, my_rank);
			gettimeofday(&IOend, NULL);
			long long iotime = (IOend.tv_sec-IObegin.tv_sec)*1000000+(IOend.tv_usec-IObegin.tv_usec);
			addScalarValue(event, TIME, iotime, my_rank);
			gettimeofday(&IObegin, NULL);
			appendEvent(&trace, event);
		} else {
			add_fdexclusions(op->res);	
		}			
		resetStats(headEvent(&trace), PHASE_COMP);
	}
	#endif
}
}
return 0;
}


static int
posix_open_post( 
int MPI_rc, 
void * pc , const char *filename ,
int flags ,
mode_t mode )

{
int rc = 0;
umpi_op_t *uop = (umpi_op_t *)calloc(sizeof(umpi_op_t), 1);

assert(uop);
uop->op = umpi_open;
uop->rank = umpi_rank;
uop->seq_num = umpi_task_seq_num++;
uop->pc = pc;
uop->data.mpi.filename = (char *) malloc((strlen(filename)+1) * sizeof(char));
assert (uop->data.mpi.filename);
bcopy (filename, uop->data.mpi.filename, (strlen(filename)+1) * sizeof(char));
		uop->data.mpi.flags = flags;
		uop->data.mpi.mode = mode;
umpi_inc_ref_count (uop);
#ifdef UMPI_DEBUG_LEVEL_2
q_append (umpi_task_op_q, uop);
#endif

uop->order = umpi_postop;
uop->res = MPI_rc;

rc = posix_open_immediate_local_post(uop);
umpi_dec_ref_count (uop, UMPI_TASK_SYNCHRONOUS);
return rc;
}

static int
gwrap_open( 
void * pc , const char *filename ,
int flags ,
mode_t mode )
{
int rc;

if (is_mpi_inited)
posix_open_pre(pc,
			filename,
			flags,
			mode);
	rc = __real_open(  (filename),
(flags),
(mode));

if (is_mpi_inited)
posix_open_post(rc, pc,
			filename,
			flags,
			mode);
	return rc;
}

extern int  __wrap_open(  const char *filename ,
		int flags ,
		mode_t mode )
{
	int rc = 0;
	void *pc = 0x0;
	GET_FP;
	//DEFINE_PC;
	//GATHER_PC;
	rc = gwrap_open(pc,
			filename,
			flags,
			mode );
	return rc;
}

/*--------------------------------------------- open64 */

extern int  __real_open64(  const char *filename ,
		int flags ,
		mode_t mode );

static int
posix_open64_immediate_local_pre(umpi_op_t *op)
{

{
{
	if(start_flag > 0){
		createEvent(&event, op->op, my_rank);
		recordStats(event, tailEvent(&trace), PHASE_COMP);
  #ifdef IO_COMM
		resetStats(event, PHASE_COMM);
  #endif
	}
}
}
return 0;
}


static int
posix_open64_pre( 
void * pc , const char *filename ,
int flags ,
mode_t mode )

{
int rc = 0;
umpi_op_t *uop = (umpi_op_t *)calloc(sizeof(umpi_op_t), 1);

assert(uop);
uop->op = umpi_open64;
uop->rank = umpi_rank;
uop->seq_num = umpi_task_seq_num++;
uop->pc = pc;
uop->data.mpi.filename = (char *) malloc((strlen(filename)+1) * sizeof(char));
assert (uop->data.mpi.filename);
bcopy (filename, uop->data.mpi.filename, (strlen(filename)+1) * sizeof(char));
		uop->data.mpi.flags = flags;
		uop->data.mpi.mode = mode;
umpi_inc_ref_count (uop);
#ifdef UMPI_DEBUG_LEVEL_2
q_append (umpi_task_op_q, uop);
#endif

uop->order = umpi_preop;

rc = posix_open64_immediate_local_pre(uop);
umpi_dec_ref_count (uop, UMPI_TASK_SYNCHRONOUS);
return 0;
}

static int
posix_open64_immediate_local_post(umpi_op_t *op)
{

{
{
	#ifndef FEATURE_SKIP_IO
	if(start_flag > 0){
	  #ifdef IO_COMM
		recordStats(event, tailEvent(&trace), PHASE_COMM);
	  #endif
		if(!Issystem_open(op->data.mpi.filename)){
			add_fds_handle_entry(record_ptr, op->res);
			addCharValue(event, FILENAME, op->data.mpi.filename, my_rank);
			addScalarValue(event, POSIX_FLAGS, op->data.mpi.flags, my_rank);
			addScalarValue(event, POSIX_FD, fds_handle_to_index(record_ptr, op->res), my_rank);
			struct stat info;
			int offset = 0;
			stat(op->data.mpi.filename, &info);
			if(op->data.mpi.flags & O_APPEND == 1)
				offset = info.st_size;
			addScalarValue(event, OFFSET, offset, my_rank);
			addScalarValue(event, COUNTS, info.st_size, my_rank);
			gettimeofday(&IOend, NULL);
			long long iotime = (IOend.tv_sec-IObegin.tv_sec)*1000000+(IOend.tv_usec-IObegin.tv_usec);
			addScalarValue(event, TIME, iotime, my_rank);
			gettimeofday(&IObegin, NULL);
			appendEvent(&trace, event);
		} else {
			add_fdexclusions(op->res);
		}
		resetStats(headEvent(&trace), PHASE_COMP);
	}
	#endif
}
}
return 0;
}


static int
posix_open64_post( 
int MPI_rc, 
void * pc , const char *filename ,
int flags ,
mode_t mode )

{
int rc = 0;
umpi_op_t *uop = (umpi_op_t *)calloc(sizeof(umpi_op_t), 1);

assert(uop);
uop->op = umpi_open64;
uop->rank = umpi_rank;
uop->seq_num = umpi_task_seq_num++;
uop->pc = pc;
uop->data.mpi.filename = (char *) malloc((strlen(filename)+1) * sizeof(char));
assert (uop->data.mpi.filename);
bcopy (filename, uop->data.mpi.filename, (strlen(filename)+1) * sizeof(char));
		uop->data.mpi.flags = flags;
		uop->data.mpi.mode = mode;
umpi_inc_ref_count (uop);
#ifdef UMPI_DEBUG_LEVEL_2
q_append (umpi_task_op_q, uop);
#endif

uop->order = umpi_postop;
uop->res = MPI_rc;

rc = posix_open64_immediate_local_post(uop);
umpi_dec_ref_count (uop, UMPI_TASK_SYNCHRONOUS);
return rc;
}

static int
gwrap_open64( 
void * pc , const char *filename ,
int flags ,
mode_t mode )
{
int rc;

if (is_mpi_inited)
posix_open64_pre(pc,
			filename,
			flags,
			mode);
	rc = __real_open64(  (filename),
(flags),
(mode));

if (is_mpi_inited)
posix_open64_post(rc, pc,
			filename,
			flags,
			mode);
	return rc;
}

extern int  __wrap_open64(  const char *filename ,
		int flags ,
		mode_t mode )
{
	int rc = 0;
	void *pc = 0x0;
	GET_FP;
	//DEFINE_PC;
	//GATHER_PC;
	rc = gwrap_open64(pc,
			filename,
			flags,
			mode );
	return rc;
}

/*--------------------------------------------- creat */

extern int  __real_creat(  const char *pathname ,
		mode_t mode );

static int
posix_creat_immediate_local_pre(umpi_op_t *op)
{

{
{
	if(start_flag > 0){
		createEvent(&event, op->op, my_rank);
		recordStats(event, tailEvent(&trace), PHASE_COMP);
	  #ifdef COM_COMM
		resetStats(event, PHASE_COMM);
	  #endif
	}
}
}
return 0;
}


static int
posix_creat_pre( 
void * pc , const char *pathname ,
mode_t mode )

{
int rc = 0;
umpi_op_t *uop = (umpi_op_t *)calloc(sizeof(umpi_op_t), 1);

assert(uop);
uop->op = umpi_creat;
uop->rank = umpi_rank;
uop->seq_num = umpi_task_seq_num++;
uop->pc = pc;
uop->data.mpi.pathname = *(pathname);
		uop->data.mpi.mode = mode;
umpi_inc_ref_count (uop);
#ifdef UMPI_DEBUG_LEVEL_2
q_append (umpi_task_op_q, uop);
#endif

uop->order = umpi_preop;

rc = posix_creat_immediate_local_pre(uop);
umpi_dec_ref_count (uop, UMPI_TASK_SYNCHRONOUS);
return 0;
}

static int
posix_creat_immediate_local_post(umpi_op_t *op)
{

{
{
	#ifndef FEATURE_SKIP_IO
	if(start_flag > 0){
	  #ifdef COM_COMM
		recordStats(event, tailEvent(&trace), PHASE_COMM);
	  #endif
		addCharValue(event,FILENAME, op->data.mpi.pathname, my_rank);
		addScalarValue(event, POSIX_MODE, op->data.mpi.mode, my_rank);
		appendEvent(&trace, event);
		resetStats(headEvent(&trace), PHASE_COMP);
	}
	#endif
}
}
return 0;
}


static int
posix_creat_post( 
int MPI_rc, 
void * pc , const char *pathname ,
mode_t mode )

{
int rc = 0;
umpi_op_t *uop = (umpi_op_t *)calloc(sizeof(umpi_op_t), 1);

assert(uop);
uop->op = umpi_creat;
uop->rank = umpi_rank;
uop->seq_num = umpi_task_seq_num++;
uop->pc = pc;
uop->data.mpi.pathname = *(pathname);
		uop->data.mpi.mode = mode;
umpi_inc_ref_count (uop);
#ifdef UMPI_DEBUG_LEVEL_2
q_append (umpi_task_op_q, uop);
#endif

uop->order = umpi_postop;
uop->res = MPI_rc;

rc = posix_creat_immediate_local_post(uop);
umpi_dec_ref_count (uop, UMPI_TASK_SYNCHRONOUS);
return rc;
}

static int
gwrap_creat( 
void * pc , const char *pathname ,
mode_t mode )
{
int rc;

if (is_mpi_inited)
posix_creat_pre(pc,
			pathname,
			mode);
	rc = __real_creat(  (pathname),
(mode));

if (is_mpi_inited)
posix_creat_post(rc, pc,
			pathname,
			mode);
	return rc;
}

extern int  __wrap_creat(  const char *pathname ,
		mode_t mode )
{
	int rc = 0;
	void *pc = 0x0;
	GET_FP;
	//DEFINE_PC;
	//GATHER_PC;
	rc = gwrap_creat(pc,
			pathname,
			mode );
	return rc;
}

/*--------------------------------------------- close */

extern int  __real_close(  int fd );

static int
posix_close_immediate_local_pre(umpi_op_t *op)
{

{
{
	#ifndef FEATURE_SKIP_IO
	if(start_flag > 0){
		createEvent(&event, op->op, my_rank);
		addScalarValue(event, POSIX_FD, fds_handle_to_index(record_ptr, op->data.mpi.fd), my_rank);
		recordStats(event, tailEvent(&trace), PHASE_COMP);
	  #ifdef IO_COMM
		resetStats(event, PHASE_COMM);
	  #endif
	}
	#endif
}
}
return 0;
}


static int
posix_close_pre( 
void * pc , int fd )

{
int rc = 0;
umpi_op_t *uop = (umpi_op_t *)calloc(sizeof(umpi_op_t), 1);

assert(uop);
uop->op = umpi_close;
uop->rank = umpi_rank;
uop->seq_num = umpi_task_seq_num++;
uop->pc = pc;
		uop->data.mpi.fd = fd;
umpi_inc_ref_count (uop);
#ifdef UMPI_DEBUG_LEVEL_2
q_append (umpi_task_op_q, uop);
#endif

uop->order = umpi_preop;

rc = posix_close_immediate_local_pre(uop);
umpi_dec_ref_count (uop, UMPI_TASK_SYNCHRONOUS);
return 0;
}

static int
posix_close_immediate_local_post(umpi_op_t *op)
{

{
{
	#ifndef FEATURE_SKIP_IO
	if(start_flag > 0){
	  #ifdef IO_COMM
		recordStats(event, tailEvent(&trace), PHASE_COMM);
	  #endif
		if(!Issystem_io(op->data.mpi.fd) && fds_handle_to_index(record_ptr, op->data.mpi.fd)>=0){
			remove_fds_handle_entry(record_ptr, op->data.mpi.fd);
			gettimeofday(&IOend, NULL);
			long long iotime = (IOend.tv_sec-IObegin.tv_sec)*1000000+(IOend.tv_usec-IObegin.tv_usec);
			addScalarValue(event, TIME, iotime, my_rank);
			gettimeofday(&IObegin, NULL);
			appendEvent(&trace, event);
		} else if(Issystem_io(op->data.mpi.fd)){
			remove_fdexclusions(op->data.mpi.fd);
		}
		resetStats(headEvent(&trace), PHASE_COMP);
	}
	#endif
}
}
return 0;
}


static int
posix_close_post( 
int MPI_rc, 
void * pc , int fd )

{
int rc = 0;
umpi_op_t *uop = (umpi_op_t *)calloc(sizeof(umpi_op_t), 1);

assert(uop);
uop->op = umpi_close;
uop->rank = umpi_rank;
uop->seq_num = umpi_task_seq_num++;
uop->pc = pc;
		uop->data.mpi.fd = fd;
umpi_inc_ref_count (uop);
#ifdef UMPI_DEBUG_LEVEL_2
q_append (umpi_task_op_q, uop);
#endif

uop->order = umpi_postop;
uop->res = MPI_rc;

rc = posix_close_immediate_local_post(uop);
umpi_dec_ref_count (uop, UMPI_TASK_SYNCHRONOUS);
return rc;
}

static int
gwrap_close( 
void * pc , int fd )
{
int rc;

if (is_mpi_inited)
posix_close_pre(pc,
			fd);
	rc = __real_close(  (fd));

if (is_mpi_inited)
posix_close_post(rc, pc,
			fd);
	return rc;
}

extern int  __wrap_close(  int fd )
{
	int rc = 0;
	void *pc = 0x0;
	GET_FP;
	//DEFINE_PC;
	//GATHER_PC;
	rc = gwrap_close(pc,
			fd );
	return rc;
}

/*--------------------------------------------- lseek */

extern off_t  __real_lseek(  int fd ,
		off_t offset ,
		int whence );

static int
posix_lseek_immediate_local_pre(umpi_op_t *op)
{

{
{
	//printf("lseek\n");
	if(start_flag > 0){
		createEvent(&event, op->op, my_rank);
		recordStats(event, tailEvent(&trace), PHASE_COMP);
	  #ifdef COM_COMM
		resetStats(event, PHASE_COMM);
	  #endif
	}
}
}
return 0;
}


static int
posix_lseek_pre( 
void * pc , int fd ,
off_t offset ,
int whence )

{
int rc = 0;
umpi_op_t *uop = (umpi_op_t *)calloc(sizeof(umpi_op_t), 1);

assert(uop);
uop->op = umpi_lseek;
uop->rank = umpi_rank;
uop->seq_num = umpi_task_seq_num++;
uop->pc = pc;
		uop->data.mpi.fd = fd;
		uop->data.mpi.offset = offset;
		uop->data.mpi.whence = whence;
umpi_inc_ref_count (uop);
#ifdef UMPI_DEBUG_LEVEL_2
q_append (umpi_task_op_q, uop);
#endif

uop->order = umpi_preop;

rc = posix_lseek_immediate_local_pre(uop);
umpi_dec_ref_count (uop, UMPI_TASK_SYNCHRONOUS);
return 0;
}

static int
posix_lseek_immediate_local_post(umpi_op_t *op)
{

{
{
	#ifndef FEATURE_SKIP_IO
	if(start_flag > 0){
	  #ifdef COM_COMM
		recordStats(event, tailEvent(&trace), PHASE_COMM);
	  #endif
		addScalarValue(event, POSIX_FD, fds_handle_to_index(record_ptr, op->data.mpi.fd), my_rank);
		addScalarValue(event, OFFSET, op->data.mpi.offset, my_rank);
		addScalarValue(event, WHENCE, op->data.mpi.whence, my_rank);
		appendEvent(&trace, event);
		resetStats(headEvent(&trace), PHASE_COMP);
	}
	#endif
}
}
return 0;
}


static int
posix_lseek_post( 
int MPI_rc, 
void * pc , int fd ,
off_t offset ,
int whence )

{
int rc = 0;
umpi_op_t *uop = (umpi_op_t *)calloc(sizeof(umpi_op_t), 1);

assert(uop);
uop->op = umpi_lseek;
uop->rank = umpi_rank;
uop->seq_num = umpi_task_seq_num++;
uop->pc = pc;
		uop->data.mpi.fd = fd;
		uop->data.mpi.offset = offset;
		uop->data.mpi.whence = whence;
umpi_inc_ref_count (uop);
#ifdef UMPI_DEBUG_LEVEL_2
q_append (umpi_task_op_q, uop);
#endif

uop->order = umpi_postop;
uop->res = MPI_rc;

rc = posix_lseek_immediate_local_post(uop);
umpi_dec_ref_count (uop, UMPI_TASK_SYNCHRONOUS);
return rc;
}

static int
gwrap_lseek( 
void * pc , int fd ,
off_t offset ,
int whence )
{
int rc;

if (is_mpi_inited)
posix_lseek_pre(pc,
			fd,
			offset,
			whence);
	rc = __real_lseek(  (fd),
(offset),
(whence));

if (is_mpi_inited)
posix_lseek_post(rc, pc,
			fd,
			offset,
			whence);
	return rc;
}

extern off_t  __wrap_lseek(  int fd ,
		off_t offset ,
		int whence )
{
	int rc = 0;
	void *pc = 0x0;
	GET_FP;
	//DEFINE_PC;
	//GATHER_PC;
	rc = gwrap_lseek(pc,
			fd,
			offset,
			whence );
	return rc;
}

/*--------------------------------------------- lseek64 */

extern off_t  __real_lseek64(  int fd ,
		off_t offset ,
		int whence );

static int
posix_lseek64_immediate_local_pre(umpi_op_t *op)
{

{
{
	//printf("lseek64\n");
	if(start_flag > 0){
		createEvent(&event, op->op, my_rank);
		recordStats(event, tailEvent(&trace), PHASE_COMP);
	  #ifdef COM_COMM
		resetStats(event, PHASE_COMM);
	  #endif
	}
}
}
return 0;
}


static int
posix_lseek64_pre( 
void * pc , int fd ,
off_t offset ,
int whence )

{
int rc = 0;
umpi_op_t *uop = (umpi_op_t *)calloc(sizeof(umpi_op_t), 1);

assert(uop);
uop->op = umpi_lseek64;
uop->rank = umpi_rank;
uop->seq_num = umpi_task_seq_num++;
uop->pc = pc;
		uop->data.mpi.fd = fd;
		uop->data.mpi.offset = offset;
		uop->data.mpi.whence = whence;
umpi_inc_ref_count (uop);
#ifdef UMPI_DEBUG_LEVEL_2
q_append (umpi_task_op_q, uop);
#endif

uop->order = umpi_preop;

rc = posix_lseek64_immediate_local_pre(uop);
umpi_dec_ref_count (uop, UMPI_TASK_SYNCHRONOUS);
return 0;
}

static int
posix_lseek64_immediate_local_post(umpi_op_t *op)
{

{
{
	#ifndef FEATURE_SKIP_IO
	if(start_flag > 0){
	  #ifdef COM_COMM
		recordStats(event, tailEvent(&trace), PHASE_COMM);
	  #endif
		addScalarValue(event, POSIX_FD, fds_handle_to_index(record_ptr, op->data.mpi.fd), my_rank);
		addScalarValue(event, OFFSET, op->data.mpi.offset, my_rank);
		addScalarValue(event, WHENCE, op->data.mpi.whence, my_rank);
		appendEvent(&trace, event);
		resetStats(headEvent(&trace), PHASE_COMP);
	}
	#endif
}
}
return 0;
}


static int
posix_lseek64_post( 
int MPI_rc, 
void * pc , int fd ,
off_t offset ,
int whence )

{
int rc = 0;
umpi_op_t *uop = (umpi_op_t *)calloc(sizeof(umpi_op_t), 1);

assert(uop);
uop->op = umpi_lseek64;
uop->rank = umpi_rank;
uop->seq_num = umpi_task_seq_num++;
uop->pc = pc;
		uop->data.mpi.fd = fd;
		uop->data.mpi.offset = offset;
		uop->data.mpi.whence = whence;
umpi_inc_ref_count (uop);
#ifdef UMPI_DEBUG_LEVEL_2
q_append (umpi_task_op_q, uop);
#endif

uop->order = umpi_postop;
uop->res = MPI_rc;

rc = posix_lseek64_immediate_local_post(uop);
umpi_dec_ref_count (uop, UMPI_TASK_SYNCHRONOUS);
return rc;
}

static int
gwrap_lseek64( 
void * pc , int fd ,
off_t offset ,
int whence )
{
int rc;

if (is_mpi_inited)
posix_lseek64_pre(pc,
			fd,
			offset,
			whence);
	rc = __real_lseek64(  (fd),
(offset),
(whence));

if (is_mpi_inited)
posix_lseek64_post(rc, pc,
			fd,
			offset,
			whence);
	return rc;
}

extern off_t  __wrap_lseek64(  int fd ,
		off_t offset ,
		int whence )
{
	int rc = 0;
	void *pc = 0x0;
	GET_FP;
	//DEFINE_PC;
	//GATHER_PC;
	rc = gwrap_lseek64(pc,
			fd,
			offset,
			whence );
	return rc;
}

/*--------------------------------------------- remove */

extern int  __real_remove(  const char *filename );

static int
posix_remove_immediate_local_pre(umpi_op_t *op)
{

{
{
	//printf("remove\n");
	if(start_flag > 0){
		createEvent(&event, op->op, my_rank);
		recordStats(event, tailEvent(&trace), PHASE_COMP);
	  #ifdef COM_COMM
		resetStats(event, PHASE_COMM);
	  #endif
	}
}
}
return 0;
}


static int
posix_remove_pre( 
void * pc , const char *filename )

{
int rc = 0;
umpi_op_t *uop = (umpi_op_t *)calloc(sizeof(umpi_op_t), 1);

assert(uop);
uop->op = umpi_remove;
uop->rank = umpi_rank;
uop->seq_num = umpi_task_seq_num++;
uop->pc = pc;
uop->data.mpi.filename = (char *) malloc((strlen(filename)+1) * sizeof(char));
assert (uop->data.mpi.filename);
bcopy (filename, uop->data.mpi.filename, (strlen(filename)+1) * sizeof(char));
umpi_inc_ref_count (uop);
#ifdef UMPI_DEBUG_LEVEL_2
q_append (umpi_task_op_q, uop);
#endif

uop->order = umpi_preop;

rc = posix_remove_immediate_local_pre(uop);
umpi_dec_ref_count (uop, UMPI_TASK_SYNCHRONOUS);
return 0;
}

static int
posix_remove_immediate_local_post(umpi_op_t *op)
{

{
{
	#ifndef FEATURE_SKIP_IO
	if(start_flag > 0){
	  #ifdef COM_COMM
		recordStats(event, tailEvent(&trace), PHASE_COMM);
	  #endif
		addCharValue(event, FILENAME, op->data.mpi.filename, my_rank);
		appendEvent(&trace, event);
		resetStats(headEvent(&trace), PHASE_COMP);
	}
	#endif
}
}
return 0;
}


static int
posix_remove_post( 
int MPI_rc, 
void * pc , const char *filename )

{
int rc = 0;
umpi_op_t *uop = (umpi_op_t *)calloc(sizeof(umpi_op_t), 1);

assert(uop);
uop->op = umpi_remove;
uop->rank = umpi_rank;
uop->seq_num = umpi_task_seq_num++;
uop->pc = pc;
uop->data.mpi.filename = (char *) malloc((strlen(filename)+1) * sizeof(char));
assert (uop->data.mpi.filename);
bcopy (filename, uop->data.mpi.filename, (strlen(filename)+1) * sizeof(char));
umpi_inc_ref_count (uop);
#ifdef UMPI_DEBUG_LEVEL_2
q_append (umpi_task_op_q, uop);
#endif

uop->order = umpi_postop;
uop->res = MPI_rc;

rc = posix_remove_immediate_local_post(uop);
umpi_dec_ref_count (uop, UMPI_TASK_SYNCHRONOUS);
return rc;
}

static int
gwrap_remove( 
void * pc , const char *filename )
{
int rc;

if (is_mpi_inited)
posix_remove_pre(pc,
			filename);
	rc = __real_remove(  (filename));

if (is_mpi_inited)
posix_remove_post(rc, pc,
			filename);
	return rc;
}

extern int  __wrap_remove(  const char *filename )
{
	int rc = 0;
	void *pc = 0x0;
	GET_FP;
	//DEFINE_PC;
	//GATHER_PC;
	rc = gwrap_remove(pc,
			filename );
	return rc;
}

/*--------------------------------------------- fopen */

extern FILE * __real_fopen(  const char *filename ,
		const char *filename1 );

static int
posix_fopen_immediate_local_pre(umpi_op_t *op)
{

{
{
	if(start_flag > 0){
		createEvent(&event, op->op, my_rank);
		recordStats(event, tailEvent(&trace), PHASE_COMP);
	  #ifdef IO_COMM
		resetStats(event, PHASE_COMM);
	  #endif
	}
}
}
return 0;
}


static int
posix_fopen_pre( 
void * pc , const char *filename ,
const char *filename1 )

{
int rc = 0;
umpi_op_t *uop = (umpi_op_t *)calloc(sizeof(umpi_op_t), 1);

assert(uop);
uop->op = umpi_fopen;
uop->rank = umpi_rank;
uop->seq_num = umpi_task_seq_num++;
uop->pc = pc;
uop->data.mpi.filename = (char *) malloc((strlen(filename)+1) * sizeof(char));
assert (uop->data.mpi.filename);
bcopy (filename, uop->data.mpi.filename, (strlen(filename)+1) * sizeof(char));
uop->data.mpi.filename1 = (char *) malloc((strlen(filename1)+1) * sizeof(char));
assert (uop->data.mpi.filename1);
bcopy (filename1, uop->data.mpi.filename1, (strlen(filename1)+1) * sizeof(char));
umpi_inc_ref_count (uop);
#ifdef UMPI_DEBUG_LEVEL_2
q_append (umpi_task_op_q, uop);
#endif

uop->order = umpi_preop;

rc = posix_fopen_immediate_local_pre(uop);
umpi_dec_ref_count (uop, UMPI_TASK_SYNCHRONOUS);
return 0;
}

static int
posix_fopen_immediate_local_post(umpi_op_t *op)
{

{
{ 
	#ifndef FEATURE_SKIP_IO
	if(start_flag > 0){
	  #ifdef IO_COMM
		recordStats(event, tailEvent(&trace), PHASE_COMM);
	  #endif
		addCharValue(event, FILENAME, op->data.mpi.filename,my_rank);
		addCharValue(event, POSIX_MODE, op->data.mpi.filename1, my_rank);
		if(!Issystem_open(op->data.mpi.filename)){
			struct stat info;
			stat(op->data.mpi.filename, &info);
			addScalarValue(event, COUNTS, info.st_size, my_rank);
			gettimeofday(&IOend, NULL);
			long long iotime = (IOend.tv_sec-IObegin.tv_sec)*1000000+(IOend.tv_usec-IObegin.tv_usec);
			addScalarValue(event, TIME, iotime, my_rank);
			gettimeofday(&IObegin, NULL);
			appendEvent(&trace, event);
		}
		resetStats(headEvent(&trace), PHASE_COMP);
	}
	#endif
}
}
return 0;
}


static int
posix_fopen_post( 
int MPI_rc, 
void * pc , const char *filename ,
const char *filename1 )

{
int rc = 0;
umpi_op_t *uop = (umpi_op_t *)calloc(sizeof(umpi_op_t), 1);

assert(uop);
uop->op = umpi_fopen;
uop->rank = umpi_rank;
uop->seq_num = umpi_task_seq_num++;
uop->pc = pc;
uop->data.mpi.filename = (char *) malloc((strlen(filename)+1) * sizeof(char));
assert (uop->data.mpi.filename);
bcopy (filename, uop->data.mpi.filename, (strlen(filename)+1) * sizeof(char));
uop->data.mpi.filename1 = (char *) malloc((strlen(filename1)+1) * sizeof(char));
assert (uop->data.mpi.filename1);
bcopy (filename1, uop->data.mpi.filename1, (strlen(filename1)+1) * sizeof(char));
umpi_inc_ref_count (uop);
#ifdef UMPI_DEBUG_LEVEL_2
q_append (umpi_task_op_q, uop);
#endif

uop->order = umpi_postop;
uop->res = MPI_rc;

rc = posix_fopen_immediate_local_post(uop);
umpi_dec_ref_count (uop, UMPI_TASK_SYNCHRONOUS);
return rc;
}

static FILE * 
gwrap_fopen( 
void * pc , const char *filename ,
const char *filename1 )
{
int rc;

if (is_mpi_inited)
posix_fopen_pre(pc,
			filename,
			filename1);
	FILE *fp = (FILE *)malloc(sizeof(FILE));
	fp = __real_fopen(  (filename),
(filename1));
add_ffiles_handle_entry(record_ptr, fp);
addScalarValue(event, POSIX_FD, ffiles_handle_to_index(record_ptr, fp), my_rank);
long offset = ftell(fp);
addScalarValue(event, OFFSET, offset, my_rank);
if(Issystem_open(filename))
   add_fexclusions(fp);

if (is_mpi_inited)
posix_fopen_post(rc, pc,
			filename,
			filename1);
	return fp;
}

extern FILE * __wrap_fopen(  const char *filename ,
		const char *filename1 )
{
	int rc = 0;
	void *pc = 0x0;
	GET_FP;
	//DEFINE_PC;
	//GATHER_PC;
	FILE *fp = (FILE *)malloc(sizeof(FILE));
	 fp = gwrap_fopen( pc,
			filename,
			filename1 );
	return fp;
}

/*--------------------------------------------- fclose */

extern int  __real_fclose(  FILE *filestream );

static int
posix_fclose_immediate_local_pre(umpi_op_t *op)
{

{
{
	#ifndef FEATURE_SKIP_IO
	if(start_flag > 0){
		createEvent(&event, op->op, my_rank);
		addScalarValue(event, POSIX_FD, ffiles_handle_to_index(record_ptr, op->data.mpi.filestream), my_rank);
		remove_ffiles_handle_entry(record_ptr, op->data.mpi.filestream);
		recordStats(event, tailEvent(&trace), PHASE_COMP);
	  #ifdef IO_COMM
		resetStats(event, PHASE_COMM);
	  #endif
	}
	#endif
}
}
return 0;
}


static int
posix_fclose_pre( 
void * pc , FILE *filestream )

{
int rc = 0;
umpi_op_t *uop = (umpi_op_t *)calloc(sizeof(umpi_op_t), 1);

assert(uop);
uop->op = umpi_fclose;
uop->rank = umpi_rank;
uop->seq_num = umpi_task_seq_num++;
uop->pc = pc;
uop->data.mpi.filestream = filestream;
umpi_inc_ref_count (uop);
#ifdef UMPI_DEBUG_LEVEL_2
q_append (umpi_task_op_q, uop);
#endif

uop->order = umpi_preop;

rc = posix_fclose_immediate_local_pre(uop);
umpi_dec_ref_count (uop, UMPI_TASK_SYNCHRONOUS);
return 0;
}

static int
posix_fclose_immediate_local_post(umpi_op_t *op)
{

{
{
	#ifndef FEATURE_SKIP_IO
	if(start_flag > 0){
	  #ifdef IO_COMM
		recordStats(event, tailEvent(&trace), PHASE_COMM);
	  #endif
		gettimeofday(&IOend, NULL);
		long long iotime = (IOend.tv_sec-IObegin.tv_sec)*1000000+(IOend.tv_usec-IObegin.tv_usec);
		addScalarValue(event, TIME, iotime, my_rank);
		gettimeofday(&IObegin, NULL);
		appendEvent(&trace, event);
		resetStats(headEvent(&trace), PHASE_COMP);
	}
	#endif
}
}
return 0;
}


static int
posix_fclose_post( 
int MPI_rc, 
void * pc , FILE *filestream )

{
int rc = 0;
umpi_op_t *uop = (umpi_op_t *)calloc(sizeof(umpi_op_t), 1);

assert(uop);
uop->op = umpi_fclose;
uop->rank = umpi_rank;
uop->seq_num = umpi_task_seq_num++;
uop->pc = pc;
uop->data.mpi.filestream = filestream;
umpi_inc_ref_count (uop);
#ifdef UMPI_DEBUG_LEVEL_2
q_append (umpi_task_op_q, uop);
#endif

uop->order = umpi_postop;
uop->res = MPI_rc;

rc = posix_fclose_immediate_local_post(uop);
umpi_dec_ref_count (uop, UMPI_TASK_SYNCHRONOUS);
return rc;
}

static int
gwrap_fclose( 
void * pc , FILE *filestream )
{
int rc;

if (is_mpi_inited)
posix_fclose_pre(pc,
			filestream);
	rc = __real_fclose(  (filestream));

if (is_mpi_inited)
posix_fclose_post(rc, pc,
			filestream);
	return rc;
}

extern int  __wrap_fclose(  FILE *filestream )
{
	int rc = 0;
	void *pc = 0x0;
	GET_FP;
	//DEFINE_PC;
	//GATHER_PC;
	rc = gwrap_fclose(pc,
			filestream );
	return rc;
}

/*--------------------------------------------- fread */

extern size_t  __real_fread(  void *buffer ,
		size_t size ,
		size_t count ,
		FILE *filestream );

static int
posix_fread_immediate_local_pre(umpi_op_t *op)
{

{
{
	if(start_flag > 0){
		createEvent(&event, op->op, my_rank);
		recordStats(event, tailEvent(&trace), PHASE_COMP);
	  #ifdef IO_COMM
		resetStats(event, PHASE_COMM);
	  #endif
	}
}
}
return 0;
}


static int
posix_fread_pre( 
void * pc , void *buffer ,
size_t size ,
size_t count ,
FILE *filestream )

{
int rc = 0;
umpi_op_t *uop = (umpi_op_t *)calloc(sizeof(umpi_op_t), 1);

assert(uop);
uop->op = umpi_fread;
uop->rank = umpi_rank;
uop->seq_num = umpi_task_seq_num++;
uop->pc = pc;
uop->data.mpi.buffer = (void*)buffer;
		uop->data.mpi.size = size;
		uop->data.mpi.count = count;
uop->data.mpi.filestream = filestream;
umpi_inc_ref_count (uop);
#ifdef UMPI_DEBUG_LEVEL_2
q_append (umpi_task_op_q, uop);
#endif

uop->order = umpi_preop;

rc = posix_fread_immediate_local_pre(uop);
umpi_dec_ref_count (uop, UMPI_TASK_SYNCHRONOUS);
return 0;
}

static int
posix_fread_immediate_local_post(umpi_op_t *op)
{

{
{
	#ifndef FEATURE_SKIP_IO
	if(start_flag > 0){
	  #ifdef IO_COMM
		recordStats(event, tailEvent(&trace), PHASE_COMM);
	  #endif
		addScalarValue(event, SIZE, op->data.mpi.size, my_rank);
		addScalarValue(event, COUNT, op->data.mpi.count, my_rank);
		addScalarValue(event, POSIX_FD, ffiles_handle_to_index(record_ptr, op->data.mpi.filestream), my_rank);
		if(!Issystem_fio(op->data.mpi.filestream))
			appendEvent(&trace, event);
		resetStats(headEvent(&trace), PHASE_COMP);
	}
	#endif
}
}
return 0;
}


static int
posix_fread_post( 
int MPI_rc, 
void * pc , void *buffer ,
size_t size ,
size_t count ,
FILE *filestream )

{
int rc = 0;
umpi_op_t *uop = (umpi_op_t *)calloc(sizeof(umpi_op_t), 1);

assert(uop);
uop->op = umpi_fread;
uop->rank = umpi_rank;
uop->seq_num = umpi_task_seq_num++;
uop->pc = pc;
uop->data.mpi.buffer = (void*)buffer;
		uop->data.mpi.size = size;
		uop->data.mpi.count = count;
uop->data.mpi.filestream = filestream;
umpi_inc_ref_count (uop);
#ifdef UMPI_DEBUG_LEVEL_2
q_append (umpi_task_op_q, uop);
#endif

uop->order = umpi_postop;
uop->res = MPI_rc;

rc = posix_fread_immediate_local_post(uop);
umpi_dec_ref_count (uop, UMPI_TASK_SYNCHRONOUS);
return rc;
}

static int
gwrap_fread( 
void * pc , void *buffer ,
size_t size ,
size_t count ,
FILE *filestream )
{
int rc;

if (is_mpi_inited)
posix_fread_pre(pc,
			buffer,
			size,
			count,
			filestream);
	rc = __real_fread(  (buffer),
(size),
(count),
(filestream));

if (is_mpi_inited)
posix_fread_post(rc, pc,
			buffer,
			size,
			count,
			filestream);
	return rc;
}

extern size_t  __wrap_fread(  void *buffer ,
		size_t size ,
		size_t count ,
		FILE *filestream )
{
	int rc = 0;
	void *pc = 0x0;
	GET_FP;
	//DEFINE_PC;
	//GATHER_PC;
	rc = gwrap_fread(pc,
			buffer,
			size,
			count,
			filestream );
	return rc;
}

/*--------------------------------------------- fwrite */

extern size_t  __real_fwrite(  const void *buffer ,
		size_t size ,
		size_t count ,
		FILE *filestream );

static int
posix_fwrite_immediate_local_pre(umpi_op_t *op)
{

{
{
	if(start_flag > 0){
		createEvent(&event, op->op, my_rank);
		recordStats(event, tailEvent(&trace), PHASE_COMP);
	  #ifdef IO_COMM
		resetStats(event, PHASE_COMM);
	  #endif
	}
}
}
return 0;
}


static int
posix_fwrite_pre( 
void * pc , const void *buffer ,
size_t size ,
size_t count ,
FILE *filestream )

{
int rc = 0;
umpi_op_t *uop = (umpi_op_t *)calloc(sizeof(umpi_op_t), 1);

assert(uop);
uop->op = umpi_fwrite;
uop->rank = umpi_rank;
uop->seq_num = umpi_task_seq_num++;
uop->pc = pc;
uop->data.mpi.buffer = (void*)buffer;
		uop->data.mpi.size = size;
		uop->data.mpi.count = count;
uop->data.mpi.filestream = filestream;
umpi_inc_ref_count (uop);
#ifdef UMPI_DEBUG_LEVEL_2
q_append (umpi_task_op_q, uop);
#endif

uop->order = umpi_preop;

rc = posix_fwrite_immediate_local_pre(uop);
umpi_dec_ref_count (uop, UMPI_TASK_SYNCHRONOUS);
return 0;
}

static int
posix_fwrite_immediate_local_post(umpi_op_t *op)
{

{
{
	#ifndef FEATURE_SKIP_IO
	if(start_flag > 0){
	  #ifdef IO_COMM
		recordStats(event, tailEvent(&trace), PHASE_COMM);
	  #endif
		addScalarValue(event, SIZE, op->data.mpi.size, my_rank);
		addScalarValue(event, COUNT, op->data.mpi.count, my_rank);
		addScalarValue(event, POSIX_FD, ffiles_handle_to_index(record_ptr, op->data.mpi.filestream), my_rank);
		if(!Issystem_fio(op->data.mpi.filestream))
			appendEvent(&trace, event);
		resetStats(headEvent(&trace), PHASE_COMP);
	}
	#endif
}
}
return 0;
}


static int
posix_fwrite_post( 
int MPI_rc, 
void * pc , const void *buffer ,
size_t size ,
size_t count ,
FILE *filestream )

{
int rc = 0;
umpi_op_t *uop = (umpi_op_t *)calloc(sizeof(umpi_op_t), 1);

assert(uop);
uop->op = umpi_fwrite;
uop->rank = umpi_rank;
uop->seq_num = umpi_task_seq_num++;
uop->pc = pc;
uop->data.mpi.buffer = (void*)buffer;
		uop->data.mpi.size = size;
		uop->data.mpi.count = count;
uop->data.mpi.filestream = filestream;
umpi_inc_ref_count (uop);
#ifdef UMPI_DEBUG_LEVEL_2
q_append (umpi_task_op_q, uop);
#endif

uop->order = umpi_postop;
uop->res = MPI_rc;

rc = posix_fwrite_immediate_local_post(uop);
umpi_dec_ref_count (uop, UMPI_TASK_SYNCHRONOUS);
return rc;
}

static int
gwrap_fwrite( 
void * pc , const void *buffer ,
size_t size ,
size_t count ,
FILE *filestream )
{
int rc;

if (is_mpi_inited)
posix_fwrite_pre(pc,
			buffer,
			size,
			count,
			filestream);
	rc = __real_fwrite(  (buffer),
(size),
(count),
(filestream));

if (is_mpi_inited)
posix_fwrite_post(rc, pc,
			buffer,
			size,
			count,
			filestream);
	return rc;
}

extern size_t  __wrap_fwrite(  const void *buffer ,
		size_t size ,
		size_t count ,
		FILE *filestream )
{
	int rc = 0;
	void *pc = 0x0;
	GET_FP;
	//DEFINE_PC;
	//GATHER_PC;
	rc = gwrap_fwrite(pc,
			buffer,
			size,
			count,
			filestream );
	return rc;
}

/*--------------------------------------------- fseek */

extern int  __real_fseek(  FILE *filestream ,
		long offset ,
		int whence );

static int
posix_fseek_immediate_local_pre(umpi_op_t *op)
{

{
{
	if(start_flag > 0){
		createEvent(&event, op->op, my_rank);
		recordStats(event, tailEvent(&trace), PHASE_COMP);
	  #ifdef COM_COMM
		resetStats(event, PHASE_COMM);
	  #endif
	}
}
}
return 0;
}


static int
posix_fseek_pre( 
void * pc , FILE *filestream ,
long offset ,
int whence )

{
int rc = 0;
umpi_op_t *uop = (umpi_op_t *)calloc(sizeof(umpi_op_t), 1);

assert(uop);
uop->op = umpi_fseek;
uop->rank = umpi_rank;
uop->seq_num = umpi_task_seq_num++;
uop->pc = pc;
uop->data.mpi.filestream = filestream;
		uop->data.mpi.offset = offset;
		uop->data.mpi.whence = whence;
umpi_inc_ref_count (uop);
#ifdef UMPI_DEBUG_LEVEL_2
q_append (umpi_task_op_q, uop);
#endif

uop->order = umpi_preop;

rc = posix_fseek_immediate_local_pre(uop);
umpi_dec_ref_count (uop, UMPI_TASK_SYNCHRONOUS);
return 0;
}

static int
posix_fseek_immediate_local_post(umpi_op_t *op)
{

{
{
	#ifndef FEATURE_SKIP_IO
	if(start_flag > 0){
	  #ifdef COM_COMM
		recordStats(event, tailEvent(&trace), PHASE_COMM);
	  #endif
		addScalarValue(event, OFFSET, op->data.mpi.offset, my_rank);
		addScalarValue(event, POSIX_FD, ffiles_handle_to_index(record_ptr, op->data.mpi.filestream), my_rank);
		addScalarValue(event, WHENCE, op->data.mpi.whence, my_rank);
		appendEvent(&trace, event);
		resetStats(headEvent(&trace), PHASE_COMP);
	}
	#endif
}
}
return 0;
}


static int
posix_fseek_post( 
int MPI_rc, 
void * pc , FILE *filestream ,
long offset ,
int whence )

{
int rc = 0;
umpi_op_t *uop = (umpi_op_t *)calloc(sizeof(umpi_op_t), 1);

assert(uop);
uop->op = umpi_fseek;
uop->rank = umpi_rank;
uop->seq_num = umpi_task_seq_num++;
uop->pc = pc;
uop->data.mpi.filestream = filestream;
		uop->data.mpi.offset = offset;
		uop->data.mpi.whence = whence;
umpi_inc_ref_count (uop);
#ifdef UMPI_DEBUG_LEVEL_2
q_append (umpi_task_op_q, uop);
#endif

uop->order = umpi_postop;
uop->res = MPI_rc;

rc = posix_fseek_immediate_local_post(uop);
umpi_dec_ref_count (uop, UMPI_TASK_SYNCHRONOUS);
return rc;
}

static int
gwrap_fseek( 
void * pc , FILE *filestream ,
long offset ,
int whence )
{
int rc;

if (is_mpi_inited)
posix_fseek_pre(pc,
			filestream,
			offset,
			whence);
	rc = __real_fseek(  (filestream),
(offset),
(whence));

if (is_mpi_inited)
posix_fseek_post(rc, pc,
			filestream,
			offset,
			whence);
	return rc;
}

extern int  __wrap_fseek(  FILE *filestream ,
		long offset ,
		int whence )
{
	int rc = 0;
	void *pc = 0x0;
	GET_FP;
	//DEFINE_PC;
	//GATHER_PC;
	rc = gwrap_fseek(pc,
			filestream,
			offset,
			whence );
	return rc;
}


/*eof*/
